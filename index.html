<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
    <meta charset="utf-8">
    <meta name="baidu-site-verification" content="zhk0OujHw0" />
    <meta name="keywords" content="程序员个人博客,python,机器学习,算法,数据挖掘,网站技术,读书,笔记,翻译">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Frederick&#39;s blog : frederick.sun"/>
<meta property="og:site_name" content="nanshu wang blog"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="http://sun-friderick.github.io/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="0001-01-01"/>
<meta property="article:modified_time" content="0001-01-01"/>





    <meta name="google-site-verification" content="BHWZ_E95BFh9L12Z90adRkxTjXIxIGSQG4qiFkcLhUw" />
    <base href="http://sun-friderick.github.io/">
    <title>Frederick&#39;s blog</title>
    <link rel="canonical" href="http://sun-friderick.github.io/">
    <link href="http://sun-friderick.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Frederick&#39;s blog" />

    <link href='http://fonts.useso.com/css?family=Fjalla+One|Open+Sans:300' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/static/css/style.css">

</head>
<body lang="en">

<header id="header">
	<nav id="nav">
	<div id="title"><a href="/">Frederick Sun</a></div>
    <div><a href=mailto: mrsun.echo@gmail.com target="_blank" class="mailto"> </span> <span class="icon-mail"></span>eric</a></div>
	</nav>
    <nav id="nav">
    	        <ul id="mainnav">
            <li>
                <a href="/bar-work/">
                <span class="icon"> <i aria-hidden="true" class="icon-console"></i></span> 
                <span> 工作 </span>
            </a>
            </li>
            <li>
            <a href="/bar-technology/">
                <span class="icon"> <i aria-hidden="true" class="icon-stats"></i></span>
                <span> 技术 </span>
            </a>
            </li>
            <li>
            <a href="/bar-favor/">
                <span class="icon"> <i aria-hidden="true" class="icon-leaf"></i></span>
                <span> 爱好 </span>
            </a>
            </li>
            
            <li>
            <a href="/bar-living/">
                <span class="icon"> <i aria-hidden="true" class="icon-quill"></i></span>
                <span> 生活 </span>
            </a>
            </li>
            
            <li>
            <a href="/tags/">
                <span class="icon"> <i aria-hidden="true" class="icon-pencil"></i></span>
                <span> Tags </span>
            </a>
            </li>
            
            <li>
            <a href="/about">
                <span class="icon"> <i aria-hidden="true" class="icon-heart"></i></span>
                <span> 关于 </span>
            </a>
            </li>
        </ul>

    </nav>
    <nav id="nav">
       	        <ul id="social">
            
            <li id="share">
                <span class="title"> 友链 </span>
                <div class="dropdown share">
                    <ul class="social">
                      <li> <a href="http://xgezhang.com" target="_blank" title="xge技术博客" class="twitter">xge</a> </li>
                      <li> <a href="http://spf13.com" target="_blank" title="spf13 is Steve Francis" class="facebook">spf13</a> </li>
                      <li> <a href="http://libaier.net" target="_blank" title="Libaier" class="rss">Libaier</a> </li>
                      <li> <a href="http://read.douban.com/column/195295/" target="_blank" title="100个故事" class="douban">一百个故事</a></li>
                      <li> <a href="http://zhangwenli.com/blog/" target="_blank" title="羡辙杂俎" class="yangzhe">羡辙杂俎</a></li>
	      <li> <a href="http://nanshu.wang/" target="_blank" title="Hugo博客" class="hugo">Hugo博客</a></li>
                    </ul>
                <span class="icon icon-bubbles"> </span> <span class="subcount"></span> </div>
            </li>
                
            <li id="follow">
                <span class="title"> 驻留地 </span>
                <div class="dropdown follow">
                    <ul class="social">
                    
                        <li> <a href="http://weibo.com/2235647167/profile/" target="_blank" title="微博" class="weibo">微博</a> </li>
                        <li> <a href="http://www.doc88.com/123_echo_" target="_blank" title="道客巴巴" class="doc88">道客巴巴</a> </li>
                        <li> <a href="http://www.zhihu.com/people/eric-sun-11" target="_blank" title="知乎" class="zhihu">知乎</a> </li>
                        <li> <a href="http://github.com/sun-friderick/" target="_blank" title="GitHub" class="github">GitHub</a> </li>                         
                        <li> <a href="http://www.cnblogs.com/sun-frederick/" target="_blank" title="博客园" class="cnblogs"> 博客园</a></li>
                        <li> <a href="http://instagram.com/ainedrag22" target="_blank" title="Instagram" class="instagram">Instagram</a> </li>
                        
                    </ul>
                <span class="icon icon-rocket"> </span> <span class="subcount"></span> </div>
            </li>
            
            
        </ul>

	</nav>
</header>


<section id="main">
  <div>
      <h1 id="title">Carpe Diem</h1>
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-1">Markdown语法 </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	Markdown语法 #1、标题： 两种标题的语法，Setext 和 atx 形式（共有六级）： 第一种：Setext 形式是用底线的形式，通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 一级标题 二级标题 第二种：Atx 形式，在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 #2、列表： 有序列表：使用数字后面跟上句号。（还要有空格） 1. 有序一 2. 有序二 3. 有序三 注意：在“1.”与文本之间有空格； 无序列表：在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） - 无序一 - 无序二 - 无序三 无序一 无序二 无序三 Red Green Blue 注意：在“-”或“*”与文本之间有空格； #3、引用： 区块引言可以有级别（例如：引言内的引言），只要根据级别加上不同数量的 &gt; &gt; 引用 &gt;&gt; 引用 &gt;&gt;&gt;&gt; 引用 注意： 符号“&gt;”与文本之间需要有空格； #4、字体强调： 星号（*）和底线（_）作为标记强调字词的符号 斜体：将需要设置为斜体的文字两端使用1个“ * ”或者“ _ ”夹起来 这是斜体字 这也是斜体字 粗体：将需要设置为斜体的文字两端使用2个“ * ”或者“ _ ”夹起来 这是粗体字 这也是粗体字 注意： 在“*”或“**”与文本之间是没有空格的； #5、代码：两种方式： 第一种：简单文字出现一个代码框，使用“”字符。（不是单引号而是左上角的ESC下面~中的） 行内代码： 这里是行内代码int a = 123456;`; 独立代码段： #include &lt;stdio.h&gt; int main(int argc, char** argv) { int a = 12345; int i = 0； for(i = 10; i &gt;= 0; i--) a = a + i; if(a &gt;= 20) printf(&quot;a= [%d]\n&quot;, a); return 0; } 第二种：大片文字需要实现代码框。使用Tab或四个空格。 #include &lt;stdio.h&gt; int main(int argc, char** argv) { int a = 12345; int i = 0； for(i = 10; i &gt;= 0; i--) a = a + i; if(a &gt;= 20) printf(&quot;a= [%d]\n&quot;, a); return 0; } #6、链接（Links）： 有两种方式，实现链接，分别为内联方式和引用参考方式，链接的文字都是用 [方括号] 来标记。 内联方式： This is an inline link.
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-1'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-7">gdb调试 </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	#gdb 跟踪调试命令整理 gdb常用命令： | 命令 | 描述 | Cool | | &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; |:&mdash;&mdash;&mdash;&mdash;-:| | backtrace（或bt） | 查看各级函数调用及参数，运行时的堆栈 | | finish | 连续运行到当前函数返回为止，然后停下来等待命令 | | frame（或f）帧编号 | 选择栈帧 | | info（或i） locals | 查看当前栈帧局部变量的值 | | list（或l） | 列出源代码，接着上次的位置往下列，每次列10行 | | list 行号 | 列出从第几行开始的源代码 | | list 函数名 | 列出某个函数的源代码 | | next（或n） | 单步调试，执行下一行语句 | | print（或p） | 打印表达式的值，通过表达式可以修改变量的值或者调用函数 | | quit（或q） | 退出gdb调试环境 | | set var | 修改变量的值 | | start | 开始执行程序，停在main函数第一行语句前面等待命令 | | step（或s） | 执行下一行语句，如果有函数调用则进入到函数中 | #GDB 调试 要进行调试程序首先要生成一个含有调试信息的执行程序命令如下: gcc(g++) -g -o 文件名 源文件.c(源文件.cpp) gcc(g++) -ggdb3 -o 文件名 源文件.c(源文件.cpp) 此时便会生成一个含有调试信息的可执行文件,然后便可以用 gdb 去调试这个程序了,进入调试程序命令,但是如果用 gdb 去调试一个未包含调试信息的可执行文件则会发生错误 gdb 执行文件名(含调试信息) #运行 GDB ##运行 gdb gdb &lt;program&gt; -- program也就是你的执行文件,一般在当然目录下.
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-7'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-6">gdb调试命令的使用及总结 </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	#gdb调试命令的使用及总结 1.基本命令 1）进入GDB #gdb test test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb) 。 2）查看源码 (gdb) l 源码会进行行号提示。 如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。 3）设置断点 (gdb) b 6 这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。 4）查看断点处情况 (gdb) info b 可以键入&rdquo;info b&rdquo;来查看断点处情况，可以设置多个断点； 5）运行代码 (gdb) r 6）显示变量值 (gdb) p n 在程序暂停时，键入&rdquo;p 变量名&rdquo;(print)即可； GDB在显示变量值时都会在对应值之前加上&rdquo;$N&rdquo;标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写作&rdquo;$N&rdquo;，而无需写冗长的变量名； 7）观察变量 (gdb) watch n 在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令&rdquo;watch&rdquo;来观察变量的变化情况，GDB在&rdquo;n&rdquo;设置了观察点； 8）单步运行 (gdb) n 9）程序继续运行 (gdb) c 使程序继续往下运行，直到再次遇到断点或程序结束； 10）退出GDB (gdb) q 2.断点调试 命令格式 例子 作用 break + 设置断点的行号 break n 在n行处设置断点 tbreak + 行号或函数名 tbreak n/func 设置临时断点，到达后被自动删除 break + filename + 行号 break main.c:10 用于在指定文件对应行设置断点 break + break 0x3400a 用于在内存某一位置处暂停 break + 行号 + if + 条件 break 10 if i==3 用于设置条件断点，在循环中使用非常方便 info breakpoints/watchpoints [n] info break n表示断点号，查看断点/观察点的情况 clear + 要清除的断点行号 clear 10 用于清除对应行的断点，要给出断点的行号，清除时GDB会给出提示 delete + 要清除的断点编号 delete 3 用于清除断点和自动显示的表达式的命令，要给出断点的编号，清除时GDB不会给出任何提示 disable/enable + 断点编号 disable 3 让所设断点暂时失效/使能，如果要让多个编号处的断点失效/使能，可将编号之间用空格隔开 awatch/watch + 变量 awatch/watch i 设置一个观察点，当变量被读出或写入时程序被暂停 rwatch + 变量 rwatch i 设置一个观察点，当变量被读出时，程序被暂停 catch 设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常 tcatch 只设置一次捕捉点，当程序停住以后，应点被自动删除 3.数据命令 display +表达式 display a 用于显示表达式的值，每当程序运行到断点处都会显示表达式的值 info display 用于显示当前所有要显示值的表达式的情况 delete + display 编号 delete 3 用于删除一个要显示值的表达式，被删除的表达式将不被显示 disable/enable + display 编号 disable/enable 3 使一个要显示值的表达式暂时失效/使能 undisplay + display 编号 undisplay 3 用于结束某个表达式值的显示 whatis + 变量 whatis i 显示某个表达式的数据类型 print(p) + 变量/表达式 p n 用于打印变量或表达式的值 set + 变量 = 变量值 set i = 3 改变程序中某个变量的值 在使用print命令时，可以对变量按指定格式进行输出，其命令格式为print /变量名 + 格式 其中常用的变量格式：x：十六进制；d：十进制；u：无符号数；o：八进制；c：字符格式；f：浮点数。 4.调试运行环境相关命令 set args set args arg1 arg2 设置运行参数 show args show args 参看运行参数 set width + 数目 set width 70 设置GDB的行宽 cd + 工作目录 cd ../ 切换工作目录 run r/run 程序开始执行 step(s) s 进入式（会进入到所调用的子函数中）单步执行，进入函数的前提是，此函数被编译有debug信息 next(n) n 非进入式（不会进入到所调用的子函数中）单步执行 finish finish 一直运行到函数返回并打印函数返回时的堆栈地址和返回值及参数值等信息 until + 行数 u 3 运行到函数某一行 continue&copy; c 执行到下一个断点或程序结束 return &lt;返回值&gt; return 5 改变程序流程，直接结束当前函数，并将指定值返回 call + 函数 call func 在当前位置执行所要运行的函数 5.堆栈相关命令 backtrace/bt bt 用来打印栈帧指针，也可以在该命令后加上要打印的栈帧指针的个数，查看程序执行到此时，是经过哪些函数呼叫的程序，程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）。每个函数及其变量都被分配了一个“帧”，最近调用的函数在 0 号帧中（“底部”帧） frame frame 1 用于打印指定栈帧 info reg info reg 查看寄存器使用情况 info stack info stack 查看堆栈使用情况 up/down up/down 跳到上一层/下一层函数 6.跳转执行 jump 指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。 7.信号命令 signal signal SIGXXX 产生XXX信号，如SIGINT。一种速查Linux查询信号的方法：# kill -l handle 在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几种关键字的一个或多个： nostop/stop 当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号/GDB会停住你的程序 print/noprint 当被调试的程序收到信号时，GDB会显示出一条信息/GDB不会告诉你收到信号的信息 pass noignore 当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。 nopass ignore 当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。 info signals info handle 可以查看哪些信号被GDB处理，并且可以看到缺省的处理方式 single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。 8.运行Shell命令 如(gdb)shell ls来运行ls。 9.更多程序运行选项和调试 1、程序运行参数。 set args 可指定运行时参数。（如：set args 10 20 30 40 50） show args 命令可以查看设置好的运行参数。 2、运行环境。 path 可设定程序的运行路径。 show paths 查看程序的运行路径。 set environment varname [=value] 设置环境变量。如：set env USER=hchen show environment [varname] 查看环境变量。 3、工作目录。 cd 相当于shell的cd命令。 pwd 显示当前的所在目录。 4、程序的输入输出。 info terminal 显示你程序用到的终端的模式。 使用重定向控制程序输出。如：run &gt; outfile tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb 5、调试已运行的程序 两种方法： (1)在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在运行的程序。 (2)先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。 6、暂停 / 恢复程序运行 当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops），如果要恢复程序运行，可以使用c或是continue命令。 7、线程（Thread Stops） 如果程序是多线程，可以定义断点是否在所有的线程上，或是在某个特定的线程。 break thread break thread if &hellip; linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread 则表示断点设在所有线程上面。还可以为某线程指定断点条件。如： (gdb) break frik.c:13 thread 28 if bartab &gt; lim 当你的程序被GDB停住时，所有的运行线程都会被停住。这方便查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。 10.调试core文件 Core Dump：Core的意思是内存，Dump的意思是扔出来，堆出来。开发和使用Unix程序时，有时程序莫名其妙的down了，却没有任何的提示(有时候会提示core dumped)，这时候可以查看一下有没有形如core.进程号的文件生成，这个文件便是操作系统把程序down掉时的内存内容扔出来生成的, 它可以做为调试程序的参考 (1)生成Core文件 一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。修改后才能生成core文件。 #设置core大小为无限 ulimit -c unlimited #设置文件大小为无限 ulimit unlimited 这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限 core文件生成路径:输入可执行文件运行命令的同一路径下。若系统生成的core文件不带其他任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。 1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。 可通过以下命令修改此文件： echo &ldquo;1&rdquo; &gt; /proc/sys/kernel/core_uses_pid 2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。 可通过以下命令修改此文件： echo &ldquo;/corefile/core-%e-%p-%t&rdquo; &gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳 以下是参数列表: %p - insert pid into filename 添加pid %u - insert current uid into filename 添加当前uid %g - insert current gid into filename 添加当前gid %s - insert signal that caused the coredump into the filename 添加导致产生core的信号 %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间 %h - insert hostname where the coredump happened into filename 添加主机名 %e - insert coredumping executable name into filename 添加命令名 (2)用gdb查看core文件 发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-6'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-8">gdb调试方法精粹 </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	#一、多线程调试 ###1. 多线程调试,最重要的几个命令: info threads 查看当前进程的线程。 GDB会为每个线程分配一个ID, 后面操作线程的时候会用到这个ID. 前面有*的是当前调试的线程. thread 切换调试的线程为指定ID的线程。 break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。 set scheduler-locking off|on|step 在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的, 怎么只让被调试程序执行呢？ 通过这个命令就可以实现这个需求。 off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况 (熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外， 只有当前线程会执行。 thread apply ID1 ID2 command 让一个或者多个线程执行GDB命令command thread apply all command 让所有被调试线程执行GDB命令command。 ###2. 使用示例: 线程产生通知：在产生新的线程时, gdb会给出提示信息 &gt;(gdb) r Starting program: /root/thread [New Thread 1073951360 (LWP 12900)] [New Thread 1082342592 (LWP 12907)]&mdash;以下三个为新产生的线程 [New Thread 1090731072 (LWP 12908)] [New Thread 1099119552 (LWP 12909)] 查看线程：使用info threads可以查看运行的线程。 &gt;(gdb) info threads 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ??
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-8'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-4">内存泄露 </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	PCIe应用程序调试时，发现程序出现内存泄露，经过自己的摸索，以及向软件同学请教，最终解决了此问题。 现象描述 应用程序开发环境为VC++,运用其debug功能进行单步调试时，程序总是报出内存泄露的错误，报告内容如下所示： Detected memory leaks! Dumping objects -&gt; strcore.cpp(118) : {143} normal block at 0x009A3E60, 53 bytes long. Data: &lt; ( ( F:\p&gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70 Object dump complete. The thread 0x9BC has exited with code 0 (0x0). The program 'F:\program\SP5301\SP5301GUI\Debug\SP5301GUI.exe' has exited with code 0 (0x0). 经过网上查阅相关资料，得知报告中相关参数含义如下： 118：内存泄露的位置在strcore.cpp中第118行 143：内存分配编号。 内存可能是在多次分配之后才出现泄露。 normal block：块类型为普通型。 0x009A3E60：内存位置。 53 bytes long：块大小为53字节。 第四行显示前 16 字节的内容为“&lt; ( (F:\p&gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70”。 第五行显示内存泄露的线程，以及返回值。 调试过程 虽然报告中显示内存泄露的位置在strcore.cpp中第118行。但是，此文件不在我的工程文件中。那么它应该是在程序运行时被调用过。而且它可能被多次调用。到底是哪次调用时出现的内存泄露，我们不得而知。为了解决内存泄露问题，准确定位内存泄露的位置是关键。 首先进入单步调试，然后打开VC++菜单中view-&gt;debug windows-&gt;Memory。通过报告中给出的内存地址0x009A3E60，查看该地址存储的内容为&rdquo;F:\program\SP5301\s6_tfg484_pcie\testdata.txt&rdquo;。结合程序内容，我猜测此字符串应该为我定义的字符串指针filepath。打开watch窗口，查看filepath的值，发现果然与上面看到的一致。于是定位了内存泄露的位置为filepath变量。 此字符串指针最初是在一个类里面定义的。最后赋给它的值是一个文件的路径。怀疑是该指针最后没有成功释放才导致的内存泄露。于是，我将filepath从类里面移出来，放在函数里面作为局部变量来定义。最终解决了内存泄露问题。 归纳总结 发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。 常见的内存错误及其对策如下： (1) 内存分配未成功，却使用了它。 编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。 (2) 内存分配虽然成功，但是尚未初始化就引用它。 犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。 (3) 内存分配成功并且已经初始化，但操作越过了内存的边界。 例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。 (4) 忘记了释放内存，造成内存泄露。 含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。 动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。 (5) 释放了内存却继续使用它。 有三种情况： A.
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-4'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-2">用GDB调试程序 </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	#用GDB调试程序 GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序 列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行 软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可 以做出一个非常强大的功能。 于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成 更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于 各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有 所短”，图形化工具还是有不如命令行的地方。 #用GDB调试程序 ##GDB概述 ———— GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那 种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你 会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长， 尺有所短”就是这个道理。 一般来说，GDB主要帮忙你完成下面四个方面的功能： 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3、当程序被停住时，可以检查此时你的程序中所发生的事。 4、动态的改变你程序的执行环境。 从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细 节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有 时候，命令行的调试工具却有着图形化工具所不能完成的功能。让我们一一看来。 ##一个调试示例 —————— 源程序：tst.c 1 #include 2 3 int func(int n) 4 { 5 int sum=0,i; 6 for(i=0; i cc -g tst.c -o tst 使用GDB调试： hchen/test&gt; gdb tst &lt;&mdash;&mdash;&mdash;- 启动GDB GNU gdb 5.1.1 Copyright 2002 Free Software Foundation, Inc. GDB is free software, covered by the GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions.
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-2'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-3">用gdb调试程序笔记: 以段错误(Segmental fault) </a> </h2>
      <div class="post-meta">Sun, Nov 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	用gdb调试程序笔记: 以段错误(Segmental fault)为例[转] 1.背景介绍 2.程序中常见的bug分类 3.程序调试器(如gdb)有什么用 4.段错误(Segmental fault)介绍 5.gdb调试入门 一、背景介绍 这个笔记主要介绍开源的程序调试器(gdb)的入门知识，目的是使unix/linux环境的编程新手能够快速学会使用gdb调试程序的方法，同时也是对我使用gdb的一个经验总结。 本文假设你能使用简单的unix/linux命令并能用gcc(GNU C Compiler， GNU C 语言编译器)编译程序，当然有编程经验更好。：） 为帮助你理解和操作，我将使用我遇到过的真实事例来演示使用gdb调试有缺陷(bug)的程序过程，你看过这篇笔记后能自己动手练一下最好。 二、程序中常见的缺陷(bug)分类 程序(编译型程序，perl、python，php等脚本程序除外)中常见的bug通常分为两类： 语法错误和逻辑错误，或者编译时错误和运行是错误。 语法错误(编译时错误)是我们在编写源代码时没有按照相关的语言规范(如ANSI C标准)导致编译时出错，编译失败。这种错误的检查和调试一般是比较简单和直接的：因为编译器(如gcc)通常会明确告诉你错误的原因和大致的范围(注意不一定是准确的错误行)。例如下面的一个简单demo.c程序的第8行缺失了一个分号，gcc指示第10行前少了一个分号。这就是一个典型的语法错误。 geekard@geekard:~/test$ cat -n demo.c 1 #include 2 3 int 4 main(){ 5 6 int n; 7 8 printf(&ldquo;the n is:%c&rdquo;, n) 9 10 return 0; 11 } geekard@geekard:~/test$ gcc demo.c -o demo demo.c: In function ‘main’:demo.c:10: error: expected ‘;’ before ‘return’ 添加了分号再编译一次，这下没有出现问题，运行程序的结果如下： geekard@geekard:~/test$ ./demo the n is:6680564 另外注意这个程序中的变量n，我定义其为整型变量但并没有对其初始化赋值，这就是一个逻辑错误：编译器不会指示这个错误，只有在实际运行或测试时才能发现。 这个小程序只是一个故意的编造，但在实际编程中无论你多高明，经验多丰富，难免会在此处犯些小错误(想想吧：当你需要编写或维护一个成千上万行的代码，这种小概率事件就是确定事件了，：）)，而通常这些错误又是那么的浅显而易于消除，但是手工“除虫”（debug），往往是效率低下且让人厌烦的，本文将就&rdquo;段错误&rdquo;这个内存访问越界的错误谈谈如何使用gdb快速定位这些&rdquo;段错误&rdquo;的语句。 三、程序调试器(如gdb)有什么用？(参考自gdb的在线帮助手册, 可用命令：man gdb， 或 info gdb查看) 程序调试器(如gdb)的主要目的是让你能够查看正在执行的程序其内部特性(如执行流程、变量值、函数调用、堆栈等)，也可以程序崩溃时刻或以前都发生了什么。 Gdb对程序的调试能力主要体现在以下四个方面(当然不止这些): .
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-3'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-03-03-1">经过省察的人生The examined life </a> </h2>
      <div class="post-meta">Tue, Mar 3, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	<p>译自<a href="http://books.google.lt/books?id=WwpZVuylPgYC&amp;pg=PA228&amp;hl=zh-CN&amp;source=gbs_toc_r&amp;cad=3#v=onepage&amp;q&amp;f=false">《A companion to Socrates》第14章</a>，作者Richard Kraut</p>

<h1 id="经过省察的人生:f856045648ed1256c7d09f14d1393f16">经过省察的人生</h1>

<p>“未经省察过的人生是不值得过的人生”（《申辩》38a5-6）。这句苏格拉底耳熟能详的名言，也许是有史以来一个哲学家嘴中最肆无忌惮的话。苏格拉底的哲学思想和他的生活方式的本质也蕴含在这句话中。苏格拉底把自己的人生作为——或者更确切地说，柏拉图把他的人生作为——真正经过了省察的人生。要了解我们如何才能达到这种人生的要求，必须从柏拉图的作品出发，来好好学习苏格拉底给我们树立起来的好榜样。</p>

	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-03-03-1'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-01-31">Hugo静态网站生成器中文教程 </a> </h2>
      <div class="post-meta">Sat, Jan 31, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	<h1 id="前言:d605f9890f3528aea462ac7515ece633">前言</h1>

<p><a href="http://gohugo.io">Hugo</a>是什么？官方文档是这样介绍它的：</p>

<blockquote>
<p>Hugo is a general-purpose website framework. Technically speaking, Hugo is a static site generator.</p>
</blockquote>

<p>Hugo是一种通用的网站框架。严格来说，Hugo应该被称作静态网站生成器。</p>

<p>静态网站生成器从字面上来理解，就是将你的内容生成静态网站。所谓“静态”的含义其实反映在网站页面的生成的时间。一般的web服务器（WordPress, Ghost, Drupal等等）在收到页面请求时，需要调用数据库生成页面（也就是HTML代码），再返回给用户请求。而静态网站则不需要在收到请求后生成页面，而是在整个网站建立起之前就将所有的页面全部生成完成，页面一经生成便称为静态文件，访问时直接返回现成的静态页面，不需要数据库的参与。</p>

	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-01-31'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2015-11-29-5">gdb多线程调试 </a> </h2>
      <div class="post-meta">Thu, Jan 29, 2015 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	gdb对于多线程程序的调试有如下的支持： 线程产生通知：在产生新的线程时, gdb会给出提示信息 (gdb) r Starting program: /root/thread [New Thread 1073951360 (LWP 12900)] [New Thread 1082342592 (LWP 12907)]&mdash;以下三个为新产生的线程 [New Thread 1090731072 (LWP 12908)] [New Thread 1099119552 (LWP 12909)] 查看线程：使用info threads可以查看运行的线程。 (gdb) info threads 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? () 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? () 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? () * 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21 (gdb) 注意，行首的蓝色文字为gdb分配的线程号，对线程进行切换时，使用该该号码，而不是上文标出的绿色数字。 另外，行首的红色星号标识了当前活动的线程 切换线程：使用 thread THREADNUMBER 进行切换，THREADNUMBER 为上文提到的线程号。下例显示将活动线程从 1 切换至 4。 (gdb) info threads 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ??
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2015-11-29-5'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2014-09-15">孤独的反思——读《孤独六讲》 </a> </h2>
      <div class="post-meta">Mon, Sep 15, 2014 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	<p>第一次知道蒋勋，是默存同学送给我的一本《蒋勋的卢浮宫》。我对西方美术完全没有了解，这本书一开始我也很不以为然。蒋勋用他自己的美学视角，写的一本卢浮宫导游书。读一遍下来我一直以为蒋勋是一位年轻的艺术家，因为他的文字就像是一个人在你身旁慢慢说话，没有任何艰深难懂的地方，把我所以为很难懂的美术讲成了一个个平常的故事，不夸张也不造作，有一种原来美术是这样来理解的恍然大悟。</p>

<p>后来，开始慢慢听《蒋勋说红楼梦》，才知道他原来主要是研究文学。也多亏他，我才意识到《红楼梦》是多么精彩而伟大的小说，以前走马观花的阅读失去了多少趣味。</p>

	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2014-09-15'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2014-01-09">《恋爱的犀牛》 </a> </h2>
      <div class="post-meta">Thu, Jan 9, 2014 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	<p>看现场的话剧比书本上的对话明朗了许多，说到最后这也不过是一个“我爱你，你不爱我”的故事。用最近从《程序员的数学》上学来的分组方法，爱情的分组不外乎是一下三种：</p>

<ol>
<li>我爱你，你也爱我</li>
<li>我爱你，你不爱我</li>
<li>你爱我，我也爱你</li>
<li>你爱我，我不爱你</li>
</ol>

<p>其中，1,3都是Happy ending（如果没有婆媳矛盾，身世之谜种种阻挠），然而大部分陷入爱情的迷阵里的青年，都在2,4里苦苦挣扎：有的有幸在2,4的循环里进入了1,3的接口，终止了自己的不幸；有的却在这个循环里咒骂爱情的无情，不得逃脱。</p>

<p>以前我总觉得，聪明的人一定会冲着2,4move on：要么从2到1，积极努力不行再换个人；要么从4到3，自己的信再铁石心肠也会有被打动的一天吧。然而《恋爱的犀牛》却不是讲着完全相反的故事，爱着明明的马路不停得重复这句告白：</p>

<blockquote>
<p>一切白的东西和你相比都成了黑墨水而自惭形秽，一切无知的鸟兽因为不能说出你的名字而绝望万分。</p>
</blockquote>

	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2014-01-09'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/post/2013-01-04">经过检验的应用软件The examined software </a> </h2>
      <div class="post-meta">Fri, Jan 4, 2013 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	<p>在图书馆看关于苏格拉底的一篇文章《The examined life》，越看越觉得人生不值得过。不过对于应用软件来说，好像道理也是一样，套用苏格拉底的话来说就是 The unexaminedsoftware is not worth applicating.未经检验的软件是不值得应用的软件。按下win键发现还是有好些软件在电脑里的存活时间挺长了，也可以算是经过检验了，心血来潮数了数。（排名不分先后）</p>

<p>1.Ginger
英文写作纠错工具，语法检查还行，比较好的是能够根据上下文给出用词的建议。</p>

<p>2.ManicTime</p>

	</article>
    <footer>
        <a href='http://sun-friderick.github.io/post/2013-01-04'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
      
        <article class="post">
    <header>
      <h2><a href="http://sun-friderick.github.io/bar-work/%E4%BA%94%E6%AD%A5%E8%AE%A9%E4%BD%A0%E6%88%90%E4%B8%BA%E4%B8%93%E5%AE%B6%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98/"> </a> </h2>
      <div class="post-meta">Mon, Jan 1, 0001 </div>
    </header>
    <article itemprop="articleBody" id="content">
    	date: 2015-11-29T10:30:03+08:00 description: &ldquo;&rdquo; tags: [&ldquo;五步成为专家&rdquo;,&ldquo;成为专家级程序员&rdquo;,&ldquo;程序员&rdquo;,&ldquo;编程&rdquo;] title: &ldquo;五步让你成为专家级程序员&rdquo; topics: [] draft: false url: /post/2015-11-29-9 Mark Lassoff是一位高级技术培训师，从事培训工作已有10余年。他培训的客户包括美国国防部、Lockheed Martin等。在多年的培训生涯中，他总结了一些如何快速学习一门语言的技巧，这些技巧非常简单，但是却让人受益匪浅。 我已经从事10年的技术培训工作，一直教人如何编程。这些人包括学生、已经走上工作岗位的开发人员。在多年的工作生涯中，我注意到一些正确/错误学习编程语言的方式，下面我分享一些正确学习语言的5种技巧，虽然它们看起来都很浅显，但只要你认真执行，绝对会有很大效果和提升。 ##1.了解语言背后的“哲学” 我在初次学习Java时，觉得它即冗长又存在不必要的复杂。那时，我还不是个经验的程序员，并且习惯使用C来编码。Java是一门伟大的语言，但我并不能体会其中的精华——甚至是它的用途，因为我无法理解Java的面向对象原理。 后来，我在德克萨斯大学奥斯汀分校的Browne博士课堂上理解了面向对象方法，并采用它进行计算机科学编程。这对我更好地理解Java的核心思想以及编程方法起了非常大作用。 如今已有成千上万个编程语言，不同的编程语言解决和优化不同类型的编程问题，并且在计算机系统中处于不同的级别。而你需要做的是了解你所学语言是什么、目标。理解是至关重要的，然后运用它来解决实际问题。 ##2.亲自输入所有的代码实例 话说，实践是检验真理的唯一标准。学习一门语言，除了知道其中的原理外，最快的学习方法莫过于实践，编写代码，远远大于读书或看视频所产生的效果。输入代码并且让它们运行起来是学习一门语言至关重要的一步。即使你对该们语言是完全陌生的，在编写的时候你也会发现它们的语法结构，渐渐明白其中的含义。 在编写的过程中，你肯定会犯错，发现错误并纠正它，这个过程也是不可忽视的，错误越多，你就会花更多的心思研究，这样理解就会越加深刻。 ##3.更进一步 无论是做实验还是练习，都尝试着更进一步地了解与学习。经常这样做将会给你带来无穷的收获，驱使你不断查阅所学语言相关资料。这样做有两大优势：第一，学习该语言的文档结构并熟悉它；第二，加深概念，帮你解决一些细小问题。 例如，你正在听一堂学习如何使用HTML5和JavaScript制作音频的课，那么你应该进一步问问自己：“该如何控制音量呢？”解决这个问题后，你就可以更加深入的掌握代码。 ##4.通过许多小例子学习——而不是大项目 在多年的培训中，我一直把重点放在客户端的网络语言上，比如Java以及后来的移动开发。在课堂上，每节课都会有相应的课件，每个课件都会演示些例子，最后把这些例子组合成一个项目。在早期常会犯这样的错误，没有进行相互隔离。 其实，采用隔离的方式学习各种语言技能是很重要的。比起学习个人技能，集成是个更复杂的过程。在你对一门语言有了坚实的基础后，集成确实是最好的学习方式，否则很有可能会混淆概念。 ##5.让程序运行 一定要让程序跑起来。即使出现多个bug，也要认真调试，直到能够正确运行。想要打开一扇门，则必须要关闭一扇门。当你学习一门新的语言技能时，肯定希望以后能有较高的技能水平。有时，你很容易放弃或者跳过某个小缺陷，使该问题一直处于悬而未决的状态——这样做很危险。 除此之外，没有比这个更兴奋的事情了——第一次看到自己编写的应用程序跑起来。
	</article>
    <footer>
        <a href='http://sun-friderick.github.io/bar-work/%E4%BA%94%E6%AD%A5%E8%AE%A9%E4%BD%A0%E6%88%90%E4%B8%BA%E4%B8%93%E5%AE%B6%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98/'><nobr>Read more →</nobr></a>
    </footer>
</article>

      
    
  </div>
</section>

<aside id="meta"> </aside>

<footer>
  <div>
    <p>
    &copy; 2015 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Frederick Sun.</span></span>
        Powered by <a href="http://hugo.spf13.com">Hugo</a>.
        Theme by <a href="http://spf13.com">Steve Francia</a>.
    </p>
  </div>
</footer>
<script type="text/javascript">
(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>






<style> 
    BODY {
        min-height:800px;
    }
    #goTopBtn {
        POSITION: fixed; TEXT-ALIGN: center; LINE-HEIGHT: 50px; WIDTH: 50px; BOTTOM: 35px; HEIGHT: 50px; FONT-SIZE: 12px; CURSOR: pointer; RIGHT: 0px; _position: absolute; _right: auto;
    }
</style>
<script type="text/javascript">
    function goTopEx() { 
        var obj = document.getElementById("goTopBtn"); 
        function getScrollTop() { 
            return document.documentElement.scrollTop + document.body.scrollTop; 
        } 
        function setScrollTop(value) { 
            if (document.documentElement.scrollTop) { 
                document.documentElement.scrollTop = value; 
            } else { 
                document.body.scrollTop = value; 
            } 
        } 
        window.onscroll = function() { 
            getScrollTop() > 0 ? obj.style.display = "": obj.style.display = "none"; 
        } 
        obj.onclick = function() { 
            var goTop = setInterval(scrollMove, 10); 
            function scrollMove() { 
                setScrollTop(getScrollTop() / 1.1); 
            if (getScrollTop() < 1) 
                clearInterval(goTop); 
            } 
        } 
    } 
</script>
<div style="display: none" id="goTopBtn"><img src='/media/top.gif' /></div>
<script type="text/javascript">goTopEx();</script>


</body>
</html>

