<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on Frederick&#39;s blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://sun-friderick.github.io/</link>
    <language>en-us</language>
    <author>Frederick Sun</author>
    <copyright>Copyright (c) 2015, Frederick Sun; all rights reserved.</copyright>
    <updated>Sun, 29 Nov 2015 10:30:03 CST</updated>
    
    <item>
      <title>五步让你成为专家级程序员</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-9</link>
      <pubDate>Sun, 29 Nov 2015 10:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-9</guid>
      <description>&lt;p&gt;Mark Lassoff是一位高级技术培训师，从事培训工作已有10余年。他培训的客户包括美国国防部、Lockheed Martin等。在多年的培训生涯中，他总结了一些如何快速学习一门语言的技巧，这些技巧非常简单，但是却让人受益匪浅。&lt;/p&gt;

&lt;p&gt;我已经从事10年的技术培训工作，一直教人如何编程。这些人包括学生、已经走上工作岗位的开发人员。在多年的工作生涯中，我注意到一些正确/错误学习编程语言的方式，下面我分享一些正确学习语言的5种技巧，虽然它们看起来都很浅显，但只要你认真执行，绝对会有很大效果和提升。&lt;/p&gt;

&lt;p&gt;##1.了解语言背后的“哲学”&lt;/p&gt;

&lt;p&gt;我在初次学习Java时，觉得它即冗长又存在不必要的复杂。那时，我还不是个经验的程序员，并且习惯使用C来编码。Java是一门伟大的语言，但我并不能体会其中的精华——甚至是它的用途，因为我无法理解Java的面向对象原理。&lt;/p&gt;

&lt;p&gt;后来，我在德克萨斯大学奥斯汀分校的Browne博士课堂上理解了面向对象方法，并采用它进行计算机科学编程。这对我更好地理解Java的核心思想以及编程方法起了非常大作用。&lt;/p&gt;

&lt;p&gt;如今已有成千上万个编程语言，不同的编程语言解决和优化不同类型的编程问题，并且在计算机系统中处于不同的级别。而你需要做的是了解你所学语言是什么、目标。理解是至关重要的，然后运用它来解决实际问题。&lt;/p&gt;

&lt;p&gt;##2.亲自输入所有的代码实例&lt;/p&gt;

&lt;p&gt;话说，实践是检验真理的唯一标准。学习一门语言，除了知道其中的原理外，最快的学习方法莫过于实践，编写代码，远远大于读书或看视频所产生的效果。输入代码并且让它们运行起来是学习一门语言至关重要的一步。即使你对该们语言是完全陌生的，在编写的时候你也会发现它们的语法结构，渐渐明白其中的含义。&lt;/p&gt;

&lt;p&gt;在编写的过程中，你肯定会犯错，发现错误并纠正它，这个过程也是不可忽视的，错误越多，你就会花更多的心思研究，这样理解就会越加深刻。&lt;/p&gt;

&lt;p&gt;##3.更进一步&lt;/p&gt;

&lt;p&gt;无论是做实验还是练习，都尝试着更进一步地了解与学习。经常这样做将会给你带来无穷的收获，驱使你不断查阅所学语言相关资料。这样做有两大优势：第一，学习该语言的文档结构并熟悉它；第二，加深概念，帮你解决一些细小问题。&lt;/p&gt;

&lt;p&gt;例如，你正在听一堂学习如何使用HTML5和JavaScript制作音频的课，那么你应该进一步问问自己：“该如何控制音量呢？”解决这个问题后，你就可以更加深入的掌握代码。&lt;/p&gt;

&lt;p&gt;##4.通过许多小例子学习——而不是大项目&lt;/p&gt;

&lt;p&gt;在多年的培训中，我一直把重点放在客户端的网络语言上，比如Java以及后来的移动开发。在课堂上，每节课都会有相应的课件，每个课件都会演示些例子，最后把这些例子组合成一个项目。在早期常会犯这样的错误，没有进行相互隔离。&lt;/p&gt;

&lt;p&gt;其实，采用隔离的方式学习各种语言技能是很重要的。比起学习个人技能，集成是个更复杂的过程。在你对一门语言有了坚实的基础后，集成确实是最好的学习方式，否则很有可能会混淆概念。&lt;/p&gt;

&lt;p&gt;##5.让程序运行&lt;/p&gt;

&lt;p&gt;一定要让程序跑起来。即使出现多个bug，也要认真调试，直到能够正确运行。想要打开一扇门，则必须要关闭一扇门。当你学习一门新的语言技能时，肯定希望以后能有较高的技能水平。有时，你很容易放弃或者跳过某个小缺陷，使该问题一直处于悬而未决的状态——这样做很危险。&lt;/p&gt;

&lt;p&gt;除此之外，没有比这个更兴奋的事情了——第一次看到自己编写的应用程序跑起来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Markdown语法</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-1</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-1</guid>
      <description>

&lt;p&gt;Markdown语法&lt;/p&gt;

&lt;p&gt;#1、标题：
两种标题的语法，Setext 和 atx 形式（共有六级）：
第一种：Setext 形式是用底线的形式，通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。&lt;/p&gt;

&lt;h1 id=&#34;一级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;二级标题&lt;/h2&gt;

&lt;p&gt;第二种：Atx 形式，在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）&lt;/p&gt;

&lt;h1 id=&#34;一级标题-1:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题-1:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;二级标题&lt;/h2&gt;

&lt;h3 id=&#34;三级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;三级标题&lt;/h3&gt;

&lt;h4 id=&#34;四级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;四级标题&lt;/h4&gt;

&lt;h5 id=&#34;五级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;五级标题&lt;/h5&gt;

&lt;h6 id=&#34;六级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;六级标题&lt;/h6&gt;

&lt;p&gt;#2、列表：&lt;br /&gt;
有序列表：使用数字后面跟上句号。（还要有空格）&lt;br /&gt;
   1. 有序一&lt;br /&gt;
   2. 有序二&lt;br /&gt;
   3. 有序三&lt;/p&gt;

&lt;p&gt;注意：在“1.”与文本之间有空格；&lt;/p&gt;

&lt;p&gt;无序列表：在文字开头添加(&lt;em&gt;, +, and -)实现无序列表。但是要注意在(&lt;/em&gt;, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）&lt;br /&gt;
   - 无序一&lt;br /&gt;
   - 无序二&lt;br /&gt;
   - 无序三&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无序一&lt;/li&gt;
&lt;li&gt;无序二&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无序三&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Red&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Green&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blue&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在“-”或“*”与文本之间有空格；&lt;/p&gt;

&lt;p&gt;#3、引用：&lt;br /&gt;
区块引言可以有级别（例如：引言内的引言），只要根据级别加上不同数量的 &amp;gt;&lt;br /&gt;
&amp;gt; 引用&lt;br /&gt;
&amp;gt;&amp;gt; 引用&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; 引用&lt;/p&gt;

&lt;p&gt;注意： 符号“&amp;gt;”与文本之间需要有空格；&lt;/p&gt;

&lt;p&gt;#4、字体强调：&lt;br /&gt;
星号（*）和底线（_）作为标记强调字词的符号&lt;br /&gt;
斜体：将需要设置为斜体的文字两端使用1个“ * ”或者“ _ ”夹起来&lt;br /&gt;
   &lt;em&gt;这是斜体字&lt;/em&gt;&lt;br /&gt;
   &lt;em&gt;这也是斜体字&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;粗体：将需要设置为斜体的文字两端使用2个“ * ”或者“ _ ”夹起来&lt;br /&gt;
   &lt;strong&gt;这是粗体字&lt;/strong&gt;&lt;br /&gt;
   &lt;strong&gt;这也是粗体字&lt;/strong&gt;&lt;br /&gt;
注意： 在“*”或“**”与文本之间是没有空格的；&lt;/p&gt;

&lt;p&gt;#5、代码：两种方式：
第一种：简单文字出现一个代码框，使用“&lt;code&gt;”字符。（&lt;/code&gt;不是单引号而是左上角的ESC下面~中的&lt;code&gt;）  
行内代码：  
   这里是行内代码&lt;/code&gt;int a = 123456;`;&lt;br /&gt;
独立代码段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;   #include &amp;lt;stdio.h&amp;gt;
   
   int main(int argc, char** argv)
   {
       int a = 12345;
       int i = 0；
       for(i = 10; i &amp;gt;= 0; i--)
           a = a + i;
           
       if(a &amp;gt;= 20)
           printf(&amp;quot;a= [%d]\n&amp;quot;, a);
           
        return 0;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：大片文字需要实现代码框。使用Tab或四个空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv)
{
   int a = 12345;
   int i = 0；
   for(i = 10; i &amp;gt;= 0; i--)
       a = a + i;

   if(a &amp;gt;= 20)
       printf(&amp;quot;a= [%d]\n&amp;quot;, a);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#6、链接（Links）：
有两种方式，实现链接，分别为内联方式和引用参考方式，链接的文字都是用 [方括号] 来标记。&lt;br /&gt;
内联方式：&lt;br /&gt;
   This is an &lt;a href=&#34;http://example.com/&#34;&gt;inline link&lt;/a&gt;.&lt;br /&gt;
   &lt;a href=&#34;http://example.net/&#34;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt;

&lt;p&gt;I get 10 times more traffic from &lt;a href=&#34;http://google.com/&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt; than from &lt;a href=&#34;http://search.yahoo.com/&#34; title=&#34;Yahoo Search&#34;&gt;Yahoo&lt;/a&gt; or &lt;a href=&#34;http://search.msn.com/&#34; title=&#34;MSN Search&#34;&gt;MSN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;引用参考方式：&lt;br /&gt;
   I get 10 times more traffic from &lt;a href=&#34;http://google.com/&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt; than from &lt;a href=&#34;http://search.yahoo.com/&#34; title=&#34;Yahoo Search&#34;&gt;Yahoo&lt;/a&gt; or &lt;a href=&#34;http://search.msn.com/&#34; title=&#34;MSN Search&#34;&gt;MSN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#7、图片（Images）：
图片的处理方式和链接的处理方式，非常的类似，允许两种样式： 行内和引用参考。&lt;br /&gt;
内联方式：&lt;br /&gt;
&lt;img src=&#34;http://mouapp.com/Mou_128.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;br /&gt;
或者&lt;br /&gt;
&lt;img src=&#34;http://mouapp.com/Mou_128.png&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;引用参考方式：&lt;br /&gt;
&lt;img src=&#34;http://mouapp.com/Mou_128.png&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;#8、脚注（footnote）：&lt;br /&gt;
hello&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;#9、表格：&lt;br /&gt;
| Tables        | Are           | Cool  |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:| &amp;mdash;&amp;ndash;:|&lt;br /&gt;
| col 3 is      | right-aligned | $1600 |&lt;br /&gt;
| col 2 is      | centered      |   $12 |&lt;br /&gt;
| zebra stripes | are neat      |    $1 |&lt;/p&gt;

&lt;p&gt;#10、分割线：&lt;br /&gt;
可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号中间插入空白。也在空白行下方添加三条“-”横线时。（前面讲过在文字下方添加“-”，实现的2级标题）；&lt;br /&gt;
使用“*”号：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;使用“-”号：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;使用下划线“_”：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;#11、LaTex公式：&lt;br /&gt;
行内公式：&lt;br /&gt;
   这里是行内公式 $ y = x + 1 $ ;&lt;br /&gt;
独立公式段：
  $$ a^2 + b^2 = c^2 $$&lt;/p&gt;

&lt;p&gt;#12、转义字符&lt;br /&gt;
支持在下面这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;

&lt;p&gt;\   反斜杠&lt;br /&gt;
`   反引号&lt;br /&gt;
*   星号&lt;br /&gt;
_   底线&lt;br /&gt;
{}  大括号&lt;br /&gt;
[]  方括号&lt;br /&gt;
()  括号&lt;/p&gt;

&lt;h1 id=&#34;井字号:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;井字号&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;加号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;减号&lt;br /&gt;
.   英文句点&lt;br /&gt;
!   惊叹号&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
        A--&amp;gt;B;
        A--&amp;gt;C;
        B--&amp;gt;D;
        C--&amp;gt;E;
        D--&amp;gt;E;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;hi的意思；
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-7</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-7</guid>
      <description>

&lt;p&gt;#gdb 跟踪调试命令整理&lt;/p&gt;

&lt;h1 id=&#34;gdb常用命令:27ab83445e035e5774461847bd2aa236&#34;&gt;gdb常用命令：&lt;/h1&gt;

&lt;p&gt;|                命令        | 描述           | Cool  |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:|&lt;br /&gt;
| backtrace（或bt）    |    查看各级函数调用及参数，运行时的堆栈   |&lt;br /&gt;
| finish                              |    连续运行到当前函数返回为止，然后停下来等待命令    |&lt;br /&gt;
| frame（或f）帧编号  |   选择栈帧       |&lt;br /&gt;
| info（或i） locals       |   查看当前栈帧局部变量的值   |&lt;br /&gt;
| list（或l）                     |    列出源代码，接着上次的位置往下列，每次列10行       |&lt;br /&gt;
| list 行号                          |   列出从第几行开始的源代码        |&lt;br /&gt;
| list 函数名                     |    列出某个函数的源代码   |&lt;br /&gt;
| next（或n）                 |    单步调试，执行下一行语句        |&lt;br /&gt;
| print（或p）                |    打印表达式的值，通过表达式可以修改变量的值或者调用函数     |&lt;br /&gt;
| quit（或q）                 |     退出gdb调试环境  |&lt;br /&gt;
| set var                           |     修改变量的值       |&lt;br /&gt;
| start                               |     开始执行程序，停在main函数第一行语句前面等待命令       |&lt;br /&gt;
| step（或s）                 |     执行下一行语句，如果有函数调用则进入到函数中  |&lt;/p&gt;

&lt;p&gt;#GDB 调试&lt;/p&gt;

&lt;p&gt;要进行调试程序首先要生成一个含有调试信息的执行程序命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc(g++) -g -o 文件名 源文件.c(源文件.cpp)
gcc(g++) -ggdb3 -o 文件名 源文件.c(源文件.cpp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时便会生成一个含有调试信息的可执行文件,然后便可以用 gdb 去调试这个程序了,进入调试程序命令,但是如果用 gdb 去调试一个未包含调试信息的可执行文件则会发生错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb 执行文件名(含调试信息)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#运行 GDB&lt;/p&gt;

&lt;p&gt;##运行 gdb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb &amp;lt;program&amp;gt; -- program也就是你的执行文件,一般在当然目录下.
gdb &amp;lt;program&amp;gt; core -- 用 gdb 同时调试一个运行程序和 core 文件,core 是程序非法执行后 core dump 后产生的文件.
gdb &amp;lt;program&amp;gt; &amp;lt;PID&amp;gt; -- 调试正在运行的程序. program 为需要调试的程序文件, PID 为当前正在运行的程序.或是先用 gdb &amp;lt;program&amp;gt; 关联上源代码进入 gdb,后用 attach 命令来挂接进程的 PID.并用 detach 来取消挂接的进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 启动常用的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从指定文件中读取符号表
    -symbols &amp;lt;file&amp;gt;
    -s &amp;lt;file&amp;gt;
从指定文件中读取符号表信息,并把他用在可执行文件中
    -se file
调试时 core dump 的 core 文件
    -core &amp;lt;file&amp;gt;
    -c &amp;lt;file&amp;gt;
加入一个源文件的搜索路径.默认搜索路径是环境变量中 PATH 所定义的路径
    -directory &amp;lt;directory&amp;gt;
    -d &amp;lt;directory&amp;gt;
设置启动时候参数
    --args arglist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 帮助文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help -- 查看 gdb 的命令种类
help &amp;lt;CmdType&amp;gt; -- 查看 CmdType 种类的 gdb 命令
apropos &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 的相关命令
info &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 调试信息
show &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord gdb 本身设置信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 中运行 unix 的 shell 程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shell &amp;lt;command string&amp;gt; -- 调用 unix 的 shell 来执行 &amp;lt;command string&amp;gt;,环境变量 shell 中定义的 unix 的 shell 将会被用来执行 &amp;lt;command string&amp;gt;,如果 shell 没有定义,那就使用 unix 的标准 shell：/bin/sh.(在 windows 中使用 command.com 或 cmd.exe)
make &amp;lt;make-args&amp;gt; -- 等价于 “shell make &amp;lt;make-args&amp;gt;”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##历史记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当你用 gdb 的 print 查看程序运行时的数据时,你每一个 print 都会被 gdb 记录下来.gdb 会以 $1, $2, $3 ...这样的方式为你每一个 print 命令编上号.于是,你可以使用这个编号访问以前的表达式,如 $1.这个功能所带来的好处是,如果你先前输入了一个比较长的表达式,如果你还想查看这个表达式的值,你可以使用历史记录来访问,省去了重复输入.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##启动程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run &amp;lt;arg ...&amp;gt; -- 启动程序,&amp;lt;arg ...&amp;gt; 为程序运行时候需要输入的参数.也可用 set args 命令去设置运行参数.简写为 r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 环境设置&lt;/p&gt;

&lt;p&gt;##gdb 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置显示选项
    地址
        set print address &amp;lt;on/off&amp;gt; -- 打开地址输出,当程序显示函数信息时,gdb会显出函数的参数地址.系统默认为打开.
        show print address -- 查看 print address 选项信息
    数组元素单独行显示
        set print array &amp;lt;on/off&amp;gt; -- 打开时数组显示时,每个元素占一行,如果不打开的话,每个元素则以逗号分隔.这个选项默认是关闭的.
        show print array -- 查看 print array 选项信息
    显示数组元素显示
        set print elements &amp;lt;number-of-elements&amp;gt; -- 设置数组的显示的最大长度,设置为 0,则表示不限制.
        show print elements -- 查看 print elements 选项信息.
    设置字符串显示
        set print null-stop &amp;lt;on/off&amp;gt; -- 如果打开那么当显示字符串时,遇到结束符则停止显示.这个选项默认为 off.
        show print null-stop -- 查看 print null-stop 选项信息
    设置结构体变量显示
        set print pretty &amp;lt;on/off&amp;gt; -- 结构体优雅显示
        show print pretty -- 查看 gdb 是如何显示结构体的.
    设置字符显示
        set print sevenbit-strings &amp;lt;on/off&amp;gt; -- 符显示,是否按“/nnn”的格式显示,如果打开,则字符串或字符数据按/nnn显示,如“/065”.
        show print sevenbit-strings -- 查看字符显示开关是否打开.
    设置联合体显示
        set print union &amp;lt;on/off&amp;gt; -- 设置显示结构体时,是否显式其内的联合体数据.
        show print union -- 查看联合体数据的显示方式
    设置对象显示
        set print object &amp;lt;on/off&amp;gt; -- 在 C++ 中,如果一个对象指针指向其派生类,如果打开这个选项,gdb 会自动按照虚方法调用的规则显示输出,如果关闭这个选项的话,gdb 就不管虚函数表了.这个选项默认是 off.
        show print object -- 查看对象选项的设置.
    设置静态成员显示
        set print static-members &amp;lt;on/off&amp;gt; -- 这个选项表示,当显示一个 C++ 对象中的内容是,是否显示其中的静态数据成员.默认是 on.
        show print static-members -- 查看静态数据成员选项设置.
    设置虚函数表显示
        set print vtbl &amp;lt;on/off&amp;gt; -- 当此选项打开时,gdb 将用比较规整的格式来显示虚函数表时.其默认是关闭的.
        show print vtbl -- 查看虚函数显示格式的选项.
设置运行程序的相关环境及其参数
    指定源文件的路径
        directory &amp;lt;dirname ... &amp;gt; -- 加一个源文件路径到当前路径的前面.如果你要指定多个路径,UNIX 下你可以使用“:”,Windows 下你可以使用“;”.缩写 dir
        directory -- 清除所有的自定义的源文件搜索路径信息.
        show directories -- 显示定义了的源文件搜索路径.
    运行参数
        set args -- 可指定运行时参数
        show args -- 命令可以查看设置好的运行参数
    运行环境
        path &amp;lt;dir&amp;gt; -- 可设定程序的运行路径
        show paths -- 查看程序的运行路径
        set environment varname=value -- 设置环境变量
        show environment [varname] -- 查看环境变量
    工作目录
        cd &amp;lt;dir&amp;gt; -- 相当于shell的cd命令
        pwd -- 显示当前的所在目录
    程序的输入输出
        info terminal -- 显示你程序用到的终端的模式
        tty -- 命令可以指写输入输出的终端设备
        重定向控制程序输出
    堆栈帧设置
        set backtrace &amp;lt;limit&amp;gt; -- 设置堆栈帧的最大显示数量,默认是没有限制
    调试模式
        set step-mode [on | off] -- step-mode 模式,于是,在进行单步跟踪时,程序不会因为没有debug信息而不停住.这个参数有很利于查看机器码. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 源码查看&lt;/p&gt;

&lt;p&gt;##显示源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list &amp;lt;linenum&amp;gt; -- 显示程序第 linenum 行的周围的源程序.
list &amp;lt;function&amp;gt; -- 显示函数名为 function 的函数的源程序.
list &amp;lt;filename:linenum&amp;gt; -- 哪个文件的哪一行.
list &amp;lt;filename:function&amp;gt; -- 哪个文件中的哪个函数.
list &amp;lt;offset&amp;gt; -- 当前行号的正/负 offset 偏移量那那行.
list -- 显示当前行后面的源程序.
list - -- 显示当前行前面的源程序.
list &amp;lt;first&amp;gt;, &amp;lt;last&amp;gt; -- 显示从 first 行到 last 行之间的源代码.若无 first 则显示从当前行到 last 之间的源代码.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##设置和获得显示源码的行数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set listsize &amp;lt;count&amp;gt; -- 设置一次显示源代码的行数.
show listsize -- 查看当前listsize的设置.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##搜索源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forward-search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
reverse-search &amp;lt;regexp&amp;gt; -- 向前面搜索.正则表达式为 regexp 的关键字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##源代码的内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info line &amp;lt;linenum&amp;gt; -- 查看行号为 linenum 源代码在内存中的地址.
info line &amp;lt;function&amp;gt; -- 查看函数在源代码在内存中的地址.
info line &amp;lt;filename:linenum&amp;gt; -- 查看 filename 文件的第 linenum 行源代码在内存中的地址.
info line &amp;lt;filename:function&amp;gt; -- 查看 filename 文件的 function 函数在源代码在内存中的地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看汇编代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disassemble -- 查看源程序的当前执行时的机器码,这个命令会把目前内存中的指令 dump 出来.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 停止点设置及维护&lt;/p&gt;

&lt;p&gt;##断点(BreakPoint)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置断点:(threadno 指定了线程的 ID,注意,这个 ID 是 gdb 分配的,可以通过 &amp;quot;info threads&amp;quot; 命令来查看正在运行程序中的线程信息)
    break thread &amp;lt;threadno&amp;gt; -- break命令没有参数时,表示在下一条指令处停住.
    break +offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的后面的 offset 行停住.(offiset 为自然数)
    break -offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的前面的 offset 行停住.(offiset 为自然数)
    break &amp;lt;linenum&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在指定行号停住.
    break filename:linenum thread &amp;lt;threadno&amp;gt; -- 在源文件filename的linenum行处停住.
    break &amp;lt;function&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在进入指定函数时停住.
    break filename:function thread &amp;lt;threadno&amp;gt; --在源文件filename的function函数的入口处停住.
    break *address -- 在程序运行的内存地址处停住.
    break ... thread &amp;lt;threadno&amp;gt; if &amp;lt;condition&amp;gt; -- ...可以是上述的参数,condition表示条件,在条件成立时停住.比如在循环境体中,可以设置break if i=100,表示当i为100时停住程序.
    tbreak -- 设置只停止一次的断点.用法和 break 类似
查看断点
    info breakpoints [n]
    info break [n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##观察点(WatchPoint) &amp;ndash; 观察点一般来观察某个表达式(变量也是一种表达式)的值是否有变化了,如果有变化,马上停住程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设在观察点
    watch &amp;lt;expr&amp;gt; -- 为表达式(变量)expr设置一个观察点.一量表达式值有变化时,马上停住程序.
    rwatch &amp;lt;expr&amp;gt; -- 当表达式(变量)expr被读时,停住程序.
    awatch &amp;lt;expr&amp;gt; -- 当表达式(变量)的值被读或被写时,停住程序.
查看观察点
    info watchpoints -- 列出当前所设置了的所有观察点.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##捕捉点(CatchPoint) &amp;ndash; 设置捕捉点来补捉程序运行时的一些事件.如:载入共享库(动态链接库)或是 C++ 的异常《/p&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置捕捉点
    catch &amp;lt;event&amp;gt; -- 当event发生时,停住程序.event可以是下面的内容：
        throw 一个 C++ 抛出的异常.(throw 为关键字)
        catch 一个 C++ 捕捉到的异常.(catch 为关键字)
        exec 调用系统调用 exec 时.(exec 为关键字,目前此功能只在 HP-UX 下有用)
        fork 调用系统调用 fork 时.(fork 为关键字,目前此功能只在 HP-UX 下有用)
        vfork 调用系统调用 vfork 时.(vfork 为关键字,目前此功能只在 HP-UX 下有用)
        load 或 load &amp;lt;libname&amp;gt; 载入共享库(动态链接库)时.(load 为关键字,目前此功能只在 HP-UX 下有用)
        unload 或 unload &amp;lt;libname&amp;gt; 卸载共享库(动态链接库)时.(unload 为关键字,目前此功能只在 HP-UX 下有用)
    tcatch &amp;lt;event&amp;gt; -- 只设置一次捕捉点,当程序停住以后,应点被自动删除.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##维护停止点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;清除停止点
    clear -- 所有的已定义的停止点.
    clear &amp;lt;function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;filename:function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
    clear &amp;lt;filename:linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
删除停止点
    delete [range] -- 删除停止点.其简写命令为 d.
禁用停止点
    disable [range] -- 禁用停止点
启用停止点
    enable [range] -- 启用停止点.
    enable once [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable count [rang] -- 启用停止点 count 次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable delete [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动删除.
停止条件维护 -- 以用 condition 命令来修改断点的条件.(只有break和watch命令支持if,catch目前暂不支持if)
    condition &amp;lt;bnum&amp;gt; &amp;lt;expression&amp;gt; -- 修改断点号为bnum的停止条件为expression.
    condition &amp;lt;bnum&amp;gt; -- 清除断点号为bnum的停止条件.
忽略停止点 N 次
    ignore &amp;lt;bnum&amp;gt; &amp;lt;count&amp;gt; -- 表示忽略断点号为 bnum 的停止条件 count 次.
为停止点设定运行命令
    格式:
    commands [bnum]
           ... command-list ...
           // 为断点号 bnumi写一个命令列表.当程序被该断点停住时,gdb 依次运行命令列表中的命令.
    end
    例如：
    break foo if x&amp;gt;0
    　　commands
           printf &amp;quot;x is %d/n&amp;quot;,x
           continue
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#信号(Signals)&lt;/p&gt;

&lt;p&gt;##添加信号处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle &amp;lt;signal&amp;gt; &amp;lt;keywords...&amp;gt;
在 gdb 中定义一个信号处理.信号 &amp;lt;signal&amp;gt; 可以以 SIG 开头或不以 SIG 开头,可以用定义一个要处理信号的范围(如：SIGIO-SIGKILL,表示处理从 SIGIO 信号到 SIGKILL 的信号,其中包括 SIGIO, SIGIOT, SIGKILL 三个信号),也可以使用关键字 all 来标明要处理所有的信号.一旦被调试的程序接收到信号,运行程序马上会被 gdb 停住,以供调试.其 &amp;lt;keywords&amp;gt; 可以是以下几种关键字的一个或多个.若没有 keywords 则查看奇信号的处理状态
    nostop -- 当被调试的程序收到信号时,gdb 不会停住程序的运行,但会打出消息告诉你收到这种信号.
    stop -- 当被调试的程序收到信号时,gdb 会停住你的程序.
    print -- 当被调试的程序收到信号时,gdb 会显示出一条信息.
    noprint -- 当被调试的程序收到信号时,gdb 不会告诉你收到信号的信息.
    pass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    noignore -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    nopass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    1gnore -- 当被调试的程序收到信号时,gdb 不会让被调试程序来处理这个信号.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看处理信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info signals -- 查看有哪些信号在被 gdb 检测中.
info handle -- 查看有哪些信号在被 gdb 检测中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 程序调试&lt;/p&gt;

&lt;p&gt;##恢复执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;continue [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
fg [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##单步调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step &amp;lt;count&amp;gt; -- 单步跟踪,如果有函数调用,它会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
next &amp;lt;count&amp;gt; -- 同样单步跟踪,如果有函数调用,他不会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跟踪机器指令
       与之一样有相同功能的命令是 “display/i $pc” ,当运行完这个命令后,单步跟踪会在打出程序代码的同时打出机器指令(也就是汇编代码)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stepi 或 si -- 单步跟踪一条机器指令,简写 si
nexti 或 ni -- 单步跟踪一条机器指令,简写 ni
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##函数调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;finish -- 运行程序,直到当前函数完成返回.并打印函数返回时的堆栈地址和返回值及参数值等信息.
return &amp;lt;expression&amp;gt; -- 使函数以 expression 表达式返回出去,忽略还没有执行的语句.若无返回 void 出去
call &amp;lt;expr&amp;gt; -- 表达式中可以一是函数,以此达到强制调用函数的目的.并显示函数的返回值,如果函数返回值是void,那么就不显示.
print 与 printf 也可以做到类似的功能和 call 的不同是,如果函数返回 void,call 则不显示,print 则显示函数返回值,并把该值存入历史数据中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##循环体调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until -- 可以运行程序直到退出循环体.简写 u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##修改变量值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print varname=var -- 修改被调试程序运行时的变量值
set var varname=value -- 修改被调试程序运行时的变变量
whatis varname -- 查看变量的类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跳转执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jump &amp;lt;linespec&amp;gt; -- 指定下一条语句的运行点.&amp;lt;linespce&amp;gt; 可以是文件的行号,可以是 file:line 格式,可以是 +num 这种偏移量格式.表式着下一条运行语句从哪里开始.
jump &amp;lt;address&amp;gt; -- 跳转到指定的程序内存地址运行.&amp;lt;address&amp;gt; 是代码行的内存地址.
注意
    jump 指令不会改变当前的程序栈中的内容,所以,当你从一个函数跳到另一个函数时,当函数运行完返回时进行弹栈操作时必然会发生错误.
    jump 命令只是改变了指令寄存器中的值.于是可以使用 “set $pc” 来更改跳转执行的地址.如： set $pc = 0x485
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##产生信号量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signal &amp;lt;signal&amp;gt; -- 产生一个 signal 信号.UNIX 的系统信号量通常从 1 到 15.所以 &amp;lt;signal&amp;gt; 取值也在这个范围.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 运行是数据&lt;/p&gt;

&lt;p&gt;##查看运行时数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print /&amp;lt;f&amp;gt; &amp;lt;expr&amp;gt; -- 查看当前程序的运行数据.简写 p.
    &amp;lt;expr&amp;gt; 是表达式
        @ -- 是一个和数组有关的操作符,在后面会有更详细的说明.在 @ 左边是数组的地址,右边是数组的长度,eg: array@len
        :: -- 指定一个在文件或是一个函数中的变量.
        {&amp;lt;type&amp;gt;} &amp;lt;addr&amp;gt; --表示一个指向内存地址&amp;lt;addr&amp;gt;的类型为type的一个对象.
    &amp;lt;f&amp;gt;是输出的格式
        d -- 按十进制格式显示变量.
        u -- 按十六进制格式显示无符号整型.
        o -- 按八进制格式显示变量.
        t -- 按二进制格式显示变量.
        a -- 按十六进制格式显示变量.
        c -- 按字符格式显示变量.
        f -- 按浮点数格式显示变量.
    注意:
        1.若出现变量重名,局部变量会隐藏全局变量.若想查看全局变量的值时,可以使用“::”操作符.
        2.可以通过这种形式指定你所想查看的变量 eg:
            *&#39;filename&#39;::variable
            *function::variable
printf &amp;quot;fmt&amp;quot;,arg,... -- 打印格式化字符灿 fmt.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;examine/&amp;lt;n/f/u&amp;gt; &amp;lt;addr&amp;gt; -- 来查看内存地址中的值.简写 x
    &amp;lt;n/f/u&amp;gt;
        n 是一个正整数,表示显示内存的长度,也就是说从当前地址向后显示几个地址的内容.
        f 表示显示的格式
            s -- 按字符串格式显示内存地址内容.
            i -- 查看内存地址的机器指令内容
            x -- 按十六进制格式显示地址内容.
            d -- 按十进制格式显示地址内容.
            u -- 按十六进制格式显示无符号整型.
            o -- 按八进制格式显示地址内容.
            t -- 按二进制格式显示地址内容.
            a -- 按十六进制格式显示地址内容.
            c -- 按字符格式显示地址内容.
            f -- 按浮点数格式显示地址内容.
        u 表示从当前地址往后请求的字节数,如果不指定的话,gdb默认是 4 个 bytes.
            b -- 表示单字节
            h -- 表示双字节
            w -- 表示四字节
            g -- 表示八字节
    &amp;lt;addr&amp;gt; 表示一个内存地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##自动显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置自动显示
    display/&amp;lt;fmt&amp;gt; &amp;lt;expr&amp;gt; -- 自动显示 expr 表达式
    display/&amp;lt;fmt&amp;gt; &amp;lt;addr&amp;gt; -- 自动显示 addr 地址
        fmt 表示显示的格式
        i -- 输出格式为机器指令码,也就是汇编.
        s -- 输出格式为字符串
删除自动显示
    undisplay &amp;lt;range&amp;gt; -- 删除自动显示
    delete display &amp;lt;range&amp;gt; -- 删除自动显示
启用和禁自动显示
    sable display &amp;lt;range&amp;gt; -- 禁用自动显示
    enable display &amp;lt;range&amp;gt; -- 启动自动显示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看栈信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backtrace &amp;lt;n&amp;gt; -- 擦看函数栈信息,简写 bt
    n 若是正数,只打印栈顶上 n 层的栈信息,
    若是负数,只打印栈顶下 n 层的栈信息,
    若无则打印当前的函数调用栈的所有信息
frame -- 会打印出这些信息:栈的层编号,当前的函数名,函数参数值,函数所在文件及行号,函数执行到的语句.
info frame -- 这个命令会打印出更为详细的当前栈层的信息,只不过,大多数都是运行时的内内地址.
info args -- 打印出当前函数的参数名及其值.
info locals -- 打印出当前函数中所有局部变量及其值.
info catch -- 打印出当前的函数中的异常处理信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##切换函数栈位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frame &amp;lt;n&amp;gt; -- 切换到第 n 层函数栈位置,简写 f.
p &amp;lt;n&amp;gt; -- 表示上面移动 n 层,可以不打 n,表示向上移动一层.
down &amp;lt;n&amp;gt; -- 表示向栈的下面移动 n 层,可以不打 n,表示向下移动一层.
select-frame &amp;lt;n&amp;gt; -- 类似 frame 命令.不打印出栈层信息.
up-silently &amp;lt;n&amp;gt; -- 类似 up 命令.不打印出栈层信息.
down-silently &amp;lt;n&amp;gt; -- 类似 down 命令.不打印出栈层信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看寄存器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info registers -- 查看寄存器的情况.(除了浮点寄存器)
info all-registers -- 查看所有寄存器的情况.(包括浮点寄存器)
info registers &amp;lt;regname&amp;gt; -- 查看所指定的寄存器的情况.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##线程查看与切换线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info threads -- 查看当前线程
thread &amp;lt;threadno&amp;gt; -- 切换到 threadno 的线程,简写 t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自定义命令&lt;/p&gt;

&lt;p&gt;##定义一个命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;格式
define comdName
      ...
end
条件语句
if cond_expr
      ...
else
      ...
end
循环语句
while cond_expr
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##定义一个命令的文档信息（在 help cmdName 的时候显示）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document cmdName
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看自定命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help user-define -- 查看所有用户自定义的命令
show user cmdName -- 查看用户定义的 cmdName 的命令.
help cmdName -- 查看用户自定义的 cmdName 的帮助文档
show max-user-call-depth -- 查看用户自定义命令的递归最大深度,缺省是 1024
set-user-call-depth &amp;lt;limit&amp;gt;-- 设置用户自定义命令的递归最大深度.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试命令的使用及总结</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-6</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-6</guid>
      <description>

&lt;p&gt;#gdb调试命令的使用及总结
1.基本命令&lt;/p&gt;

&lt;p&gt;1）进入GDB　　#gdb test&lt;/p&gt;

&lt;p&gt;　　test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb) 。&lt;/p&gt;

&lt;p&gt;2）查看源码　　(gdb) l&lt;/p&gt;

&lt;p&gt;　　源码会进行行号提示。&lt;/p&gt;

&lt;p&gt;　　如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。&lt;/p&gt;

&lt;p&gt;3）设置断点　　(gdb) b 6&lt;/p&gt;

&lt;p&gt;　　这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。&lt;/p&gt;

&lt;p&gt;4）查看断点处情况　　(gdb) info b&lt;/p&gt;

&lt;p&gt;　　可以键入&amp;rdquo;info b&amp;rdquo;来查看断点处情况，可以设置多个断点；&lt;/p&gt;

&lt;p&gt;5）运行代码　　(gdb) r&lt;/p&gt;

&lt;p&gt;6）显示变量值　　(gdb) p n&lt;/p&gt;

&lt;p&gt;　　在程序暂停时，键入&amp;rdquo;p 变量名&amp;rdquo;(print)即可；&lt;/p&gt;

&lt;p&gt;　　GDB在显示变量值时都会在对应值之前加上&amp;rdquo;$N&amp;rdquo;标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写作&amp;rdquo;$N&amp;rdquo;，而无需写冗长的变量名；&lt;/p&gt;

&lt;p&gt;7）观察变量　　(gdb) watch n&lt;/p&gt;

&lt;p&gt;在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令&amp;rdquo;watch&amp;rdquo;来观察变量的变化情况，GDB在&amp;rdquo;n&amp;rdquo;设置了观察点；&lt;/p&gt;

&lt;p&gt;8）单步运行　　(gdb) n&lt;/p&gt;

&lt;p&gt;9）程序继续运行　　(gdb) c&lt;/p&gt;

&lt;p&gt;　　使程序继续往下运行，直到再次遇到断点或程序结束；&lt;/p&gt;

&lt;p&gt;10）退出GDB　　(gdb) q&lt;/p&gt;

&lt;p&gt;2.断点调试&lt;/p&gt;

&lt;p&gt;命令格式　　                      例子             　　　　　　作用&lt;/p&gt;

&lt;p&gt;break + 设置断点的行号　　break n　　　　　　在n行处设置断点&lt;/p&gt;

&lt;p&gt;tbreak + 行号或函数名　　tbreak n/func　　　　设置临时断点，到达后被自动删除&lt;/p&gt;

&lt;p&gt;break + filename + 行号　　break main.c:10　　用于在指定文件对应行设置断点&lt;/p&gt;

&lt;p&gt;break + &lt;0x...&gt;　　break 0x3400a　　　　　　用于在内存某一位置处暂停&lt;/p&gt;

&lt;p&gt;break + 行号 + if + 条件　　break 10 if i==3　　　用于设置条件断点，在循环中使用非常方便&lt;/p&gt;

&lt;p&gt;info breakpoints/watchpoints [n]　　info break　　n表示断点号，查看断点/观察点的情况&lt;/p&gt;

&lt;p&gt;clear + 要清除的断点行号　　clear 10　　　　用于清除对应行的断点，要给出断点的行号，清除时GDB会给出提示&lt;/p&gt;

&lt;p&gt;delete + 要清除的断点编号　　delete 3　　　　用于清除断点和自动显示的表达式的命令，要给出断点的编号，清除时GDB不会给出任何提示&lt;/p&gt;

&lt;p&gt;disable/enable + 断点编号　　disable 3　　　　让所设断点暂时失效/使能，如果要让多个编号处的断点失效/使能，可将编号之间用空格隔开&lt;/p&gt;

&lt;p&gt;awatch/watch + 变量　　awatch/watch i　　　　设置一个观察点，当变量被读出或写入时程序被暂停&lt;/p&gt;

&lt;p&gt;rwatch + 变量　　　　　　rwatch i　　　　　　　　设置一个观察点，当变量被读出时，程序被暂停&lt;/p&gt;

&lt;p&gt;catch　　　　　　　　　　　　　　　　　　设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常&lt;/p&gt;

&lt;p&gt;tcatch　　　　　　　　　　　　　　　　　　只设置一次捕捉点，当程序停住以后，应点被自动删除&lt;/p&gt;

&lt;p&gt;3.数据命令&lt;/p&gt;

&lt;p&gt;display +表达式　　display a　　用于显示表达式的值，每当程序运行到断点处都会显示表达式的值&lt;/p&gt;

&lt;p&gt;info display　　　　　　用于显示当前所有要显示值的表达式的情况&lt;/p&gt;

&lt;p&gt;delete + display 编号　　delete 3　　用于删除一个要显示值的表达式，被删除的表达式将不被显示&lt;/p&gt;

&lt;p&gt;disable/enable + display 编号　　disable/enable 3　　使一个要显示值的表达式暂时失效/使能&lt;/p&gt;

&lt;p&gt;undisplay + display 编号　　undisplay 3　　用于结束某个表达式值的显示&lt;/p&gt;

&lt;p&gt;whatis + 变量　　whatis i　　显示某个表达式的数据类型&lt;/p&gt;

&lt;p&gt;print(p) + 变量/表达式　　p n　　用于打印变量或表达式的值&lt;/p&gt;

&lt;p&gt;set + 变量 = 变量值　　set i = 3　　改变程序中某个变量的值&lt;/p&gt;

&lt;p&gt;　　在使用print命令时，可以对变量按指定格式进行输出，其命令格式为print /变量名 + 格式&lt;/p&gt;

&lt;p&gt;　　其中常用的变量格式：x：十六进制；d：十进制；u：无符号数；o：八进制；c：字符格式；f：浮点数。&lt;/p&gt;

&lt;p&gt;4.调试运行环境相关命令&lt;/p&gt;

&lt;p&gt;set args　　set args arg1 arg2　　设置运行参数&lt;/p&gt;

&lt;p&gt;show args　　show args　　参看运行参数&lt;/p&gt;

&lt;p&gt;set width + 数目　　set width 70　　设置GDB的行宽&lt;/p&gt;

&lt;p&gt;cd + 工作目录　　cd ../　　切换工作目录&lt;/p&gt;

&lt;p&gt;run　　r/run　　程序开始执行&lt;/p&gt;

&lt;p&gt;step(s)　　s　　进入式（会进入到所调用的子函数中）单步执行，进入函数的前提是，此函数被编译有debug信息&lt;/p&gt;

&lt;p&gt;next(n)　　n　　非进入式（不会进入到所调用的子函数中）单步执行&lt;/p&gt;

&lt;p&gt;finish　　finish　　一直运行到函数返回并打印函数返回时的堆栈地址和返回值及参数值等信息&lt;/p&gt;

&lt;p&gt;until + 行数　　u 3　　运行到函数某一行&lt;/p&gt;

&lt;p&gt;continue&amp;copy;　　c　　执行到下一个断点或程序结束&lt;/p&gt;

&lt;p&gt;return &amp;lt;返回值&amp;gt;　　return 5　　改变程序流程，直接结束当前函数，并将指定值返回&lt;/p&gt;

&lt;p&gt;call + 函数　　call func　　在当前位置执行所要运行的函数&lt;/p&gt;

&lt;p&gt;5.堆栈相关命令&lt;/p&gt;

&lt;p&gt;backtrace/bt　　bt　　用来打印栈帧指针，也可以在该命令后加上要打印的栈帧指针的个数，查看程序执行到此时，是经过哪些函数呼叫的程序，程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）。每个函数及其变量都被分配了一个“帧”，最近调用的函数在 0 号帧中（“底部”帧）&lt;/p&gt;

&lt;p&gt;frame　　frame 1　　用于打印指定栈帧&lt;/p&gt;

&lt;p&gt;info reg　　info reg　　查看寄存器使用情况&lt;/p&gt;

&lt;p&gt;info stack　　info stack　　查看堆栈使用情况&lt;/p&gt;

&lt;p&gt;up/down　　up/down　　跳到上一层/下一层函数&lt;/p&gt;

&lt;p&gt;6.跳转执行&lt;/p&gt;

&lt;p&gt;jump  指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。&lt;/p&gt;

&lt;p&gt;7.信号命令&lt;/p&gt;

&lt;p&gt;signal 　　signal SIGXXX 　　产生XXX信号，如SIGINT。一种速查Linux查询信号的方法：# kill -l&lt;/p&gt;

&lt;p&gt;handle 　　在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几种关键字的一个或多个：
　　nostop/stop
　　　　当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号/GDB会停住你的程序&lt;br /&gt;
　　print/noprint
　　　　当被调试的程序收到信号时，GDB会显示出一条信息/GDB不会告诉你收到信号的信息
　　pass
　　noignore
　　　　当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。
　　nopass
　　ignore
　　　　当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
　　info signals
　　info handle
　　　　可以查看哪些信号被GDB处理，并且可以看到缺省的处理方式&lt;/p&gt;

&lt;p&gt;　　single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。&lt;/p&gt;

&lt;p&gt;8.运行Shell命令&lt;/p&gt;

&lt;p&gt;　　如(gdb)shell ls来运行ls。　　&lt;/p&gt;

&lt;p&gt;9.更多程序运行选项和调试&lt;/p&gt;

&lt;p&gt;1、程序运行参数。
　　set args 可指定运行时参数。（如：set args 10 20 30 40 50）
　　show args 命令可以查看设置好的运行参数。
2、运行环境。
　　path 可设定程序的运行路径。
　　show paths 查看程序的运行路径。&lt;/p&gt;

&lt;p&gt;　　set environment varname [=value] 设置环境变量。如：set env USER=hchen&lt;/p&gt;

&lt;p&gt;　　show environment [varname] 查看环境变量。&lt;/p&gt;

&lt;p&gt;3、工作目录。&lt;/p&gt;

&lt;p&gt;　　cd　　  相当于shell的cd命令。&lt;/p&gt;

&lt;p&gt;　　pwd　　显示当前的所在目录。
4、程序的输入输出。
　　info terminal 显示你程序用到的终端的模式。
　　使用重定向控制程序输出。如：run &amp;gt; outfile
　　tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb&lt;/p&gt;

&lt;p&gt;5、调试已运行的程序&lt;/p&gt;

&lt;p&gt;两种方法：
　　(1)在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在运行的程序。
　　(2)先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。&lt;/p&gt;

&lt;p&gt;6、暂停 / 恢复程序运行　　当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops），如果要恢复程序运行，可以使用c或是continue命令。&lt;/p&gt;

&lt;p&gt;7、线程（Thread Stops）&lt;/p&gt;

&lt;p&gt;如果程序是多线程，可以定义断点是否在所有的线程上，或是在某个特定的线程。
　　break thread
　　break thread if &amp;hellip;
　　linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread 则表示断点设在所有线程上面。还可以为某线程指定断点条件。如：
　　(gdb) break frik.c:13 thread 28 if bartab &amp;gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。&lt;/p&gt;

&lt;p&gt;10.调试core文件&lt;/p&gt;

&lt;p&gt;Core Dump：Core的意思是内存，Dump的意思是扔出来，堆出来。开发和使用Unix程序时，有时程序莫名其妙的down了，却没有任何的提示(有时候会提示core dumped)，这时候可以查看一下有没有形如core.进程号的文件生成，这个文件便是操作系统把程序down掉时的内存内容扔出来生成的, 它可以做为调试程序的参考&lt;/p&gt;

&lt;p&gt;(1)生成Core文件
　　一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。修改后才能生成core文件。&lt;/p&gt;

&lt;p&gt;　　#设置core大小为无限
　　ulimit -c unlimited
　　#设置文件大小为无限
　　ulimit unlimited&lt;/p&gt;

&lt;p&gt;　　这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限&lt;/p&gt;

&lt;p&gt;core文件生成路径:输入可执行文件运行命令的同一路径下。若系统生成的core文件不带其他任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。&lt;/p&gt;

&lt;p&gt;1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。
可通过以下命令修改此文件：
echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/kernel/core_uses_pid&lt;/p&gt;

&lt;p&gt;2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。
可通过以下命令修改此文件：
echo &amp;ldquo;/corefile/core-%e-%p-%t&amp;rdquo; &amp;gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳
以下是参数列表:
    %p - insert pid into filename 添加pid
    %u - insert current uid into filename 添加当前uid
    %g - insert current gid into filename 添加当前gid
    %s - insert signal that caused the coredump into the filename 添加导致产生core的信号
    %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
    %h - insert hostname where the coredump happened into filename 添加主机名
    %e - insert coredumping executable name into filename 添加命令名&lt;/p&gt;

&lt;p&gt;(2)用gdb查看core文件&lt;/p&gt;

&lt;p&gt;　　发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.
　　gdb [exec file] [core file]
　　如:
　　gdb ./test core&lt;/p&gt;

&lt;p&gt;　　或gdb ./a.out
 　　core-file core.xxxx
　　gdb后, 用bt命令backtrace或where查看程序运行到哪里, 来定位core dump的文件-&amp;gt;行.&lt;/p&gt;

&lt;p&gt;　　待调试的可执行文件，在编译的时候需要加-g，core文件才能正常显示出错信息&lt;/p&gt;

&lt;p&gt;　　1）gdb -core=core.xxxx
　　file ./a.out
　　bt
　　2）gdb -c core.xxxx
　　file ./a.out
　　bt&lt;/p&gt;

&lt;p&gt;(3)用gdb实时观察某进程crash信息&lt;/p&gt;

&lt;p&gt;　　启动进程
　　gdb -p PID
　　c
　　运行进程至crash
　　gdb会显示crash信息
　　bt&lt;/p&gt;

&lt;p&gt;#gdb调试命令说明&lt;/p&gt;

&lt;h1 id=&#34;1-对于在应用程序中加入参数进行调试的方法:a705e2985626516966a98e6f6a34e407&#34;&gt;1: 对于在应用程序中加入参数进行调试的方法：&lt;/h1&gt;

&lt;p&gt;直接用 gdb app -p1 -p2 这样进行调试是不行的。
   需要像以下这样使用：
    #gdb app
    (gdb) r -p1 -p2
    或者在运行run命令前使用set args命令：
    （gdb） set args p1 p2
    可以用show args 命令来查看&lt;/p&gt;

&lt;h1 id=&#34;2-加入断点:a705e2985626516966a98e6f6a34e407&#34;&gt;2. 加入断点：&lt;/h1&gt;

&lt;p&gt;break &lt;linenumber&gt;
   break &lt;funcName&gt;
   break +offset
   break -offset
   (在当前行号的前面或后面的offset行停住。)&lt;/p&gt;

&lt;p&gt;break filename:linenum
   在源文件filename的linenum行处停住。&lt;/p&gt;

&lt;p&gt;break filename:function
   在源文件filename的function函数的入口处停住。&lt;/p&gt;

&lt;p&gt;break &amp;hellip; if
  &amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设置     break if i=100，表示当i为100时停住程序。&lt;/p&gt;

&lt;h1 id=&#34;3-查看运行时的堆栈:a705e2985626516966a98e6f6a34e407&#34;&gt;3. 查看运行时的堆栈：&lt;/h1&gt;

&lt;p&gt;使用bt命令&lt;/p&gt;

&lt;h1 id=&#34;4-打印某个变量的值:a705e2985626516966a98e6f6a34e407&#34;&gt;4. 打印某个变量的值：&lt;/h1&gt;

&lt;p&gt;print val&lt;/p&gt;

&lt;h1 id=&#34;5-单步-n:a705e2985626516966a98e6f6a34e407&#34;&gt;5. 单步： n&lt;/h1&gt;

&lt;p&gt;继续运行：　c
　　step
　　单步跟踪，如果有函数调用，他会进入该函数。
　　next
　　同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。
　　set step-mode
　　set step-mode on
　　打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。
　　set step-mod off
　　关闭step-mode模式。
　　finish
　　运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
　　until 或 u
　　当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。&lt;/p&gt;

&lt;h1 id=&#34;6-在gdb中执行shell命令:a705e2985626516966a98e6f6a34e407&#34;&gt;6.在gdb中执行shell命令：&lt;/h1&gt;

&lt;p&gt;　在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
　eg. shell make&lt;/p&gt;

&lt;h1 id=&#34;7-运行环境:a705e2985626516966a98e6f6a34e407&#34;&gt;7. 运行环境&lt;/h1&gt;

&lt;p&gt;可设定程序的运行路径。
  show paths 查看程序的运行路径。
  set environment varname [=value] 设置环境变量。如：set env USER=hchen
  show environment [varname] 查看环境变量。&lt;/p&gt;

&lt;h1 id=&#34;8-观察点-watchpoint:a705e2985626516966a98e6f6a34e407&#34;&gt;8.观察点（WatchPoint）&lt;/h1&gt;

&lt;p&gt;观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程 序。我们有下面的几种方法来设置观察点：
  watch
   为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
  rwatch
   当表达式（变量）expr被读时，停住程序。
  awatch
   当表达式（变量）的值被读或被写时，停住程序。
  info watchpoints
   列出当前所设置了的所有观察点。&lt;/p&gt;

&lt;h1 id=&#34;9-维护breakpoint:a705e2985626516966a98e6f6a34e407&#34;&gt;9. 维护breakpoint&lt;/h1&gt;

&lt;p&gt;clear
    清除所有的已定义的停止点。
   clear func
    清除所有设置在函数上的停止点。
  delete [breakpoints] [range&amp;hellip;]
  删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。
  比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。
  disable [breakpoints] [range&amp;hellip;]
   disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止 点。简写命令是dis.
  enable [breakpoints] [range&amp;hellip;]
   enable所指定的停止点，breakpoints为停止点号。&lt;/p&gt;

&lt;h1 id=&#34;10-程序变量:a705e2985626516966a98e6f6a34e407&#34;&gt;10、程序变量&lt;/h1&gt;

&lt;p&gt;查看文件中某变量的值：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
gdb) p &amp;lsquo;f2.c&amp;rsquo;::x&lt;/p&gt;

&lt;p&gt;查看数组的值
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。&lt;/p&gt;

&lt;h1 id=&#34;10-1-输出格式:a705e2985626516966a98e6f6a34e407&#34;&gt;10-1.输出格式&lt;/h1&gt;

&lt;p&gt;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：&lt;/p&gt;

&lt;p&gt;x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &amp;lsquo;e&amp;rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101&lt;/p&gt;

&lt;h1 id=&#34;11-查看内存:a705e2985626516966a98e6f6a34e407&#34;&gt;11.查看内存&lt;/h1&gt;

&lt;p&gt;使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。
u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。&lt;/p&gt;

&lt;p&gt;n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。&lt;/p&gt;

&lt;h1 id=&#34;12-自动显示:a705e2985626516966a98e6f6a34e407&#34;&gt;12.自动显示&lt;/h1&gt;

&lt;p&gt;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。
display
display/
display/ expr
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。&lt;/p&gt;

&lt;p&gt;格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc&lt;/p&gt;

&lt;p&gt;undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。&lt;/p&gt;

&lt;p&gt;disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。&lt;/p&gt;

&lt;p&gt;info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。&lt;/p&gt;

&lt;h1 id=&#34;13-设置显示选项:a705e2985626516966a98e6f6a34e407&#34;&gt;13. 设置显示选项&lt;/h1&gt;

&lt;p&gt;set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
show print address
查看当前地址显示选项是否打开。&lt;/p&gt;

&lt;p&gt;set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。&lt;/p&gt;

&lt;p&gt;set print array off
show print array&lt;/p&gt;

&lt;p&gt;set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。&lt;/p&gt;

&lt;p&gt;show print elements
查看print elements的选项信息。&lt;/p&gt;

&lt;p&gt;set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。&lt;/p&gt;

&lt;p&gt;set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。&lt;/p&gt;

&lt;h1 id=&#34;14-关于显示源码list:a705e2985626516966a98e6f6a34e407&#34;&gt;14.关于显示源码list&lt;/h1&gt;

&lt;p&gt;以下是list命令的說明。
參數                                     說明
list filename:number  列出某檔案的第幾行，檔案是可省略的。
list [function]                  列出某函數的程式碼
list                                       繼續印出程式碼
list -                                     印出上一次list的程式碼的前一段程式碼(類似向上翻動)
show listsize   顯示現在一次印出幾行
set listsize  設定一次印出幾行&lt;/p&gt;

&lt;p&gt;备常用命令：&lt;/p&gt;

&lt;h2 id=&#34;１-常看源码-list-ｌ:a705e2985626516966a98e6f6a34e407&#34;&gt;１.常看源码：list（ｌ）　&lt;/h2&gt;

&lt;p&gt;　　list　＜linenumber＞　行号
　　list　＜＋offset＞　当前行号的正偏移
　　list　＜－offset＞　当前行号的负偏移
　　list　＜filename：linenumber＞　哪个文件的哪一行
　　list　＜function＞　函数名
　　list　＜filename：function＞　文件的哪个函数
　　list　＜＊address＞　程序运行时语句在内存中的地址&lt;/p&gt;

&lt;h2 id=&#34;２-设置断点-break-ｂ:a705e2985626516966a98e6f6a34e407&#34;&gt;２．设置断点：break（ｂ）&lt;/h2&gt;

&lt;p&gt;　　break　＜function＞　指定函数断点
　　break　＜linenumber＞　指定行号断点
　　break　＜＋offset／－offset＞　当前行号的正／负偏移
　　break　＜filename：linenumber＞　哪个文件的哪一行
　　break　＜＊address＞　运行中的内存地址
　　break　不带参数，下一条指令停止处
　　break &amp;hellip;　if　＜condition＞　在运行中，当condition条件满足时停止。
　　　　ｅｇ．　break　if　ｉ＝100 //当i=100时，立即停止
                 break foo if i=100   //断点设置在foo中，断点条件是i-100, 一点在函数foo中，i的值等于100,被停止。&lt;/p&gt;

&lt;h2 id=&#34;３-查看信息-info:a705e2985626516966a98e6f6a34e407&#34;&gt;３．查看信息： info&lt;/h2&gt;

&lt;p&gt;　　info　break　查看断点信息
    info locals 打印出当前函数中所有局部变量及其值
　　info　stack　查看栈中信息
    info frame 更详细的栈层地址信息
　　info　args　查看参数信息
　　info　registers／info　all－registers　查看（所有）寄存器信息
　　info　sources　查看项目的源代码信息&lt;/p&gt;

&lt;h2 id=&#34;４-维护breakpoint-disable-enable-clear-delete:a705e2985626516966a98e6f6a34e407&#34;&gt;４．维护breakpoint：disable/enable/clear/delete&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; disable(dis) 【breakpoints】 【range...】
   如果没有参数，则停止所有的断点，
 enable 【breakpoints】【range】
 clear &amp;lt;function&amp;gt;/&amp;lt;filename:function&amp;gt;/&amp;lt;linenum&amp;gt;/&amp;lt;filename:linenum&amp;gt;
    清楚已定义的停止点
  delete [breakpoints] [ranga...]
     删除指定的断点
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;５-恢复程序运行:a705e2985626516966a98e6f6a34e407&#34;&gt;５．恢复程序运行：&lt;/h2&gt;

&lt;p&gt;　　continue（c）
　　&lt;/p&gt;

&lt;h2 id=&#34;6-until和finish:a705e2985626516966a98e6f6a34e407&#34;&gt;6.until和finish&lt;/h2&gt;

&lt;p&gt;until 跳出循环比较有用
    help finish
     Execute until selected stack frame returns.
     Upon return, the value returned is printed and put in the value history.
  finish 用来跳出函数比较有用。
    help until
     Execute until the program reaches a source line greater than the current
     or a specified location (same args as break command) within the current frame&lt;/p&gt;

&lt;p&gt;##一、多线程调试&lt;br /&gt;
多线程调试重要就是下面几个命令：&lt;br /&gt;
info thread 查看当前进程的线程。&lt;br /&gt;
thread &lt;ID&gt; 切换调试的线程为指定ID的线程。&lt;br /&gt;
break file.c:100 thread all  在file.c文件第100行处为所有经过这里的线程设置断点。   set scheduler-locking off|on|step，这个是问得最多的。&lt;br /&gt;
  * 在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。&lt;br /&gt;
  * off 不锁定任何线程，也就是所有线程都执行，这是默认值。&lt;br /&gt;
  * on 只有当前被调试程序会执行。&lt;br /&gt;
  * step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;

&lt;p&gt;##二、调试宏
这个问题超多。在GDB下，我们无法print宏定义，因为宏是预编译的。但是我们还是有办法来调试宏，这个需要GCC的配合。&lt;br /&gt;
在GCC编译程序的时候，加上-ggdb3参数，这样，你就可以调试宏了。&lt;br /&gt;
另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。&lt;br /&gt;
info macro – 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。&lt;br /&gt;
macro – 你可以查看宏展开的样子。&lt;/p&gt;

&lt;p&gt;##三、源文件
这个问题问的也是很多的，太多的朋友都说找不到源文件。在这里我想提醒大家做下面的检查：&lt;br /&gt;
编译程序员是否加上了-g参数以包含debug信息。 路径是否设置正确了。使用GDB的directory命令来设置源文件的目录。&lt;br /&gt;
下面给一个调试/bin/ls的示例（ubuntu下）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get sourcecoreutils  
$ sudoapt-get installcoreutils-dbgsym  
$ gdb /bin/ls  
GNU gdb (GDB) 7.1-ubuntu  
(gdb) list main  
1192    ls.c: No such fileor directory.  
inls.c  
(gdb) directory ~/src/coreutils-7.4/src/  
Source directories searched: /home/hchen/src/coreutils-7.4:$cdir:$cwd  
(gdb) list main  
1192        }  
1193    }  
1194  
1195    int  
1196    main (int argc, char **argv)  
1197    {  
1198      int i;  
1199      struct pending *thispend;  
1200      int n_files;  
1201  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##四、条件断点
条件断点是语法是：&lt;code&gt;break  [where] if [condition]&lt;/code&gt;，这种断点真是非常管用。尤其是在一个循环或递归中，或是要监视某个变量。&lt;br /&gt;
注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。&lt;/p&gt;

&lt;p&gt;##五、命令行参数
有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。&lt;br /&gt;
其实，有两种方法：&lt;br /&gt;
- gdb命令行的 –args 参数&lt;br /&gt;
- gdb环境中 set args命令。&lt;/p&gt;

&lt;p&gt;##六、gdb的变量
有时候，在调试程序时，我们不单单只是查看运行时的变量，我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，或是switch的分支语句。使用set命令可以修改程序中的变量。&lt;br /&gt;
另外，你知道gdb中也可以有变量吗？就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set$i = 0

(gdb) p a[$i++]

...  #然后就一路回车下去了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。&lt;/p&gt;

&lt;p&gt;##七、x命令
也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。&lt;br /&gt;
- x/x 以十六进制输出&lt;br /&gt;
- x/d 以十进制输出&lt;br /&gt;
- x/c 以单字符输出&lt;br /&gt;
- x/i  反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）&lt;br /&gt;
- x/s 以字符串输出&lt;/p&gt;

&lt;p&gt;##八、command命令
有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) breakfunc
Breakpoint 1 at 0x3475678: filetest.c, line 12.
(gdb) command1
Type commands forwhen breakpoint 1 is hit, one per line.
End with a line saying just &amp;quot;end&amp;quot;.
&amp;gt;print arg1
&amp;gt;print arg2
&amp;gt;print arg3
&amp;gt;end
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。&lt;/p&gt;

&lt;p&gt;#设置core环境
uname -a 查看机器参数&lt;br /&gt;
ulimit -a 查看默认参数&lt;br /&gt;
ulimit -c 1024  设置core文件大小为1024&lt;br /&gt;
ulimit -c unlimit 设置core文件大小为无限&lt;/p&gt;

&lt;p&gt;多线程如果dump，多为段错误，一般都涉及内存非法读写。可以这样处理，使用下面的命令打开系统开关，让其可以在死掉的时候生成 core文件。&lt;br /&gt;
ulimit -c unlimited&lt;/p&gt;

&lt;p&gt;#线程调试命令
1. (gdb)info threads&lt;br /&gt;
显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。
前面有*的是当前调试的线程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;(gdb)thread ID&lt;br /&gt;
切换当前调试的线程为指定ID的线程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)thread apply ID1 ID2 command&lt;br /&gt;
让一个或者多个线程执行GDB命令command。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)thread apply all command&lt;br /&gt;
让所有被调试线程执行GDB命令command。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)set scheduler-locking off|on|step&lt;br /&gt;
估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;off 不锁定任何线程，也就是所有线程都执行，这是默认值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;on 只有当前被调试程序会执行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//显示线程堆栈信息&lt;br /&gt;
6. (gdb) bt&lt;br /&gt;
察看所有的调用栈&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;(gdb) f 3
调用框层次&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb) i locals&lt;br /&gt;
显示所有当前调用栈的所有变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试方法精粹</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-8</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-8</guid>
      <description>&lt;p&gt;#一、多线程调试
###1. 多线程调试,最重要的几个命令:
info threads                        查看当前进程的线程。
                                          GDB会为每个线程分配一个ID, 后面操作线程的时候会用到这个ID.
                                          前面有*的是当前调试的线程.
thread                      切换调试的线程为指定ID的线程。
break file.c:100 thread all    在file.c文件第100行处为所有经过这里的线程设置断点。
set scheduler-locking off|on|step&lt;br /&gt;
      在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的,
      怎么只让被调试程序执行呢？
      通过这个命令就可以实现这个需求。
         off      不锁定任何线程，也就是所有线程都执行，这是默认值。
         on       只有当前被调试程序会执行。
         step     在单步的时候，除了next过一个函数的情况
                  (熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，
                  只有当前线程会执行。
thread apply ID1 ID2 command        让一个或者多个线程执行GDB命令command
thread apply all command            让所有被调试线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;###2. 使用示例:
线程产生通知：在产生新的线程时, gdb会给出提示信息
&amp;gt;(gdb) r
Starting program: /root/thread
[New Thread 1073951360 (LWP 12900)]
[New Thread 1082342592 (LWP 12907)]&amp;mdash;以下三个为新产生的线程
[New Thread 1090731072 (LWP 12908)]
[New Thread 1099119552 (LWP 12909)]&lt;/p&gt;

&lt;p&gt;查看线程：使用info threads可以查看运行的线程。
&amp;gt;(gdb) info threads
  4 Thread 1099119552 (LWP 12940)   0xffffe002 in ?? ()
  3 Thread 1090731072 (LWP 12939)   0xffffe002 in ?? ()
  2 Thread 1082342592 (LWP 12938)   0xffffe002 in ?? ()
* 1 Thread 1073951360 (LWP 12931)   main (argc=1, argv=0xbfffda04) at thread.c:21
(gdb)&lt;/p&gt;

&lt;p&gt;注意，行首为gdb分配的线程ID号，对线程进行切换时，使用该ID号码。
另外，行首的星号标识了当前活动的线程
切换线程：
使用 thread THREADNUMBER 进行切换，THREADNUMBER 为上文提到的线程ID号。
下例显示将活动线程从 1 切换至 4。
&amp;gt;(gdb) info threads
   4 Thread 1099119552 (LWP 12940)   0xffffe002 in ?? ()
   3 Thread 1090731072 (LWP 12939)   0xffffe002 in ?? ()
   2 Thread 1082342592 (LWP 12938)   0xffffe002 in ?? ()
* 1 Thread 1073951360 (LWP 12931)   main (argc=1, argv=0xbfffda04) at thread.c:21
(gdb) thread 4
[Switching to thread 4 (Thread 1099119552 (LWP 12940))]#0   0xffffe002 in ?? ()
(gdb) info threads
* 4 Thread 1099119552 (LWP 12940)   0xffffe002 in ?? ()
   3 Thread 1090731072 (LWP 12939)   0xffffe002 in ?? ()
   2 Thread 1082342592 (LWP 12938)   0xffffe002 in ?? ()
   1 Thread 1073951360 (LWP 12931)   main (argc=1, argv=0xbfffda04) at thread.c:21
(gdb)&lt;/p&gt;

&lt;p&gt;以上即为使用gdb提供的对多线程进行调试的一些基本命令。
另外，gdb也提供对线程的断点设置以及对指定或所有线程发布命令的命令&lt;/p&gt;

&lt;p&gt;#二、调试宏
在GDB下, 我们无法print宏定义，因为宏是预编译的。
但是我们还是有办法来调试宏，这个需要GCC的配合。
在GCC编译程序的时候，加上
  -ggdb3   参数，这样，你就可以调试宏了。&lt;/p&gt;

&lt;p&gt;另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。
info macro   查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。
macro         查看宏展开的样子。&lt;/p&gt;

&lt;p&gt;#三、源文件
GDB时,提示找不到源文件。
需要做下面的检查:
编译程序员是否加上了 -g参数 以包含debug信息。
路径是否设置正确了。
使用GDB的directory命令来设置源文件的目录。&lt;/p&gt;

&lt;p&gt;下面给一个调试/bin/ls的示例(ubuntu下)
&amp;gt;$ apt-get source coreutils
$ sudo apt-get install coreutils-dbgsym
$ gdb /bin/ls
GNU gdb (GDB) 7.1-ubuntu
(gdb) list main
1192    ls.c: No such file or directory.
in ls.c
(gdb) directory ~/src/coreutils-7.4/src/
Source directories searched: /home/hchen/src/coreutils-7.4:$cdir:$cwd
(gdb) list main
1192        }
1193    }
1194
1195    int
1196    main (int argc, char **argv)
1197    {
1198      int i;
1199      struct pending *thispend;
1200      int n_files;
1201&lt;/p&gt;

&lt;p&gt;#四、条件断点
条件断点是语法是：
  break  [where] if [condition]
这种断点真是非常管用。
尤其是在一个循环或递归中，或是要监视某个变量。
注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。&lt;/p&gt;

&lt;p&gt;#五、命令行参数
有时候，我们需要调试的程序需要有命令行参数, 有三种方法：
gdb命令行的 -args 参数
gdb环境中   set args命令。
gdb环境中   run 参数&lt;/p&gt;

&lt;p&gt;#六、gdb的变量
有时候，在调试程序时，我们不单单只是查看运行时的变量，
我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，
或是switch的分支语句。使用set命令可以修改程序中的变量。
另外，你知道gdb中也可以有变量吗？
就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：
(gdb) set $i = 0
(gdb) p a[$i++]
&amp;hellip;  #然后就一路回车下去了
当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。&lt;/p&gt;

&lt;p&gt;#七、x命令
也许，你很喜欢用p命令。
所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。
x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。
x/x 以十六进制输出
x/d 以十进制输出
x/c 以单字符输出
x/i  反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）
x/s 以字符串输出&lt;/p&gt;

&lt;p&gt;#八、command命令
如何自动化调试。
这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。
下面是一个示例：
&amp;gt;(gdb) break func
&amp;gt;Breakpoint 1 at 0x3475678: file test.c, line 12.
&amp;gt;(gdb) command 1
&amp;gt;Type commands for when breakpoint 1 is hit, one per line.
&amp;gt;End with a line saying just &amp;ldquo;end&amp;rdquo;.
&amp;gt;print arg1
&amp;gt;print arg2
&amp;gt;print arg3
&amp;gt;end
&amp;gt;(gdb)&lt;/p&gt;

&lt;p&gt;当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>内存泄露</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-4</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-4</guid>
      <description>&lt;p&gt;PCIe应用程序调试时，发现程序出现内存泄露，经过自己的摸索，以及向软件同学请教，最终解决了此问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;现象描述&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;应用程序开发环境为VC++,运用其debug功能进行单步调试时，程序总是报出内存泄露的错误，报告内容如下所示：&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;Detected memory leaks!
Dumping objects -&amp;gt;
strcore.cpp(118) : {143} normal block at 0x009A3E60, 53 bytes long.
 Data: &amp;lt;    (   (   F:\p&amp;gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70
Object dump complete.
The thread 0x9BC has exited with code 0 (0x0).
The program &#39;F:\program\SP5301\SP5301GUI\Debug\SP5301GUI.exe&#39; has exited with code 0 (0x0).
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;经过网上查阅相关资料，得知报告中相关参数含义如下：&lt;/p&gt;

&lt;p&gt;118：内存泄露的位置在strcore.cpp中第118行&lt;/p&gt;

&lt;p&gt;143：内存分配编号。 内存可能是在多次分配之后才出现泄露。
    normal block：块类型为普通型。
    0x009A3E60：内存位置。
    53 bytes long：块大小为53字节。
    第四行显示前 16 字节的内容为“&amp;lt; ( (F:\p&amp;gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70”。&lt;/p&gt;

&lt;p&gt;第五行显示内存泄露的线程，以及返回值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调试过程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然报告中显示内存泄露的位置在strcore.cpp中第118行。但是，此文件不在我的工程文件中。那么它应该是在程序运行时被调用过。而且它可能被多次调用。到底是哪次调用时出现的内存泄露，我们不得而知。为了解决内存泄露问题，准确定位内存泄露的位置是关键。&lt;/p&gt;

&lt;p&gt;首先进入单步调试，然后打开VC++菜单中view-&amp;gt;debug windows-&amp;gt;Memory。通过报告中给出的内存地址0x009A3E60，查看该地址存储的内容为&amp;rdquo;F:\program\SP5301\s6_tfg484_pcie\testdata.txt&amp;rdquo;。结合程序内容，我猜测此字符串应该为我定义的字符串指针filepath。打开watch窗口，查看filepath的值，发现果然与上面看到的一致。于是定位了内存泄露的位置为filepath变量。&lt;/p&gt;

&lt;p&gt;此字符串指针最初是在一个类里面定义的。最后赋给它的值是一个文件的路径。怀疑是该指针最后没有成功释放才导致的内存泄露。于是，我将filepath从类里面移出来，放在函数里面作为局部变量来定义。最终解决了内存泄露问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;归纳总结&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。&lt;/p&gt;

&lt;p&gt;常见的内存错误及其对策如下：&lt;/p&gt;

&lt;p&gt;(1)      内存分配未成功，却使用了它。&lt;/p&gt;

&lt;p&gt;编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。&lt;/p&gt;

&lt;p&gt;(2)      内存分配虽然成功，但是尚未初始化就引用它。&lt;/p&gt;

&lt;p&gt;犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。&lt;/p&gt;

&lt;p&gt;(3)      内存分配成功并且已经初始化，但操作越过了内存的边界。&lt;/p&gt;

&lt;p&gt;例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。&lt;/p&gt;

&lt;p&gt;(4)      忘记了释放内存，造成内存泄露。&lt;/p&gt;

&lt;p&gt;含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。&lt;/p&gt;

&lt;p&gt;动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。&lt;/p&gt;

&lt;p&gt;(5)      释放了内存却继续使用它。&lt;/p&gt;

&lt;p&gt;有三种情况：&lt;/p&gt;

&lt;p&gt;A.        程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。&lt;/p&gt;

&lt;p&gt;B.        函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。&lt;/p&gt;

&lt;p&gt;C.        使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。&lt;/p&gt;

&lt;p&gt;在产品的开发中，通过对当前系统消耗内存总量的统计，可以对产品所需内存总量进行精确的评估，从而选择合适的内存芯片与大小，降低产品的成本。在遇到内存泄露类问题时，经常会对此束手无策，本文通过对proc下进程相关的文件进行分析，精确评估系统消耗内存的大小，还可以对内存泄露类问题的解决提供一种定位手段。
       Linux在内存使用上的原则是：如果内存充足，不用白不用，尽量使用内存来缓存一些文件，从而加快进程的运行速度，而当内存不足时，会通过相应的内存回收策略收回cache内存，供进程使用。&lt;/p&gt;

&lt;p&gt;一、系统总内存的分析。
可以从proc目录下的meminfo文件了解到当前系统内存的使用情况汇总，其中可用的物理内存=memfree+buffers+cached，当memfree不够时，内核会通过回写机制(pdflush线程)把cached和buffered内存回写到后备存储器，从而释放相关内存供进程使用，或者通过手动方式显式释放cache内存
       echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/p&gt;

&lt;p&gt;下图是海思平台下当前系统内存的总体使用情况，其中可以看到，系统消耗掉了29M的内存，下面继续分析这些内存都是被谁消耗掉了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/meminfo
MemTotal:        68956 kB
MemFree:         18632 kB
Buffers:          4096 kB
Cached:          17260 kB
SwapCached:          0 kB
Active:          21304 kB
Inactive:        19248 kB
SwapTotal:           0 kB
SwapFree:            0 kB
Dirty:               0 kB
Writeback:           0 kB
AnonPages:       19216 kB
Mapped:           2472 kB
Slab:             6900 kB
SReclaimable:      924 kB
SUnreclaim:       5976 kB
PageTables:        460 kB
NFS_Unstable:        0 kB
Bounce:              0 kB
CommitLimit:     62060 kB
Committed_AS:    28864 kB
VmallocTotal:   442368 kB
VmallocUsed:     46984 kB
VmallocChunk:   393212 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、进程使用内存的统计
在32位操作系统中，每个进程拥有4G的虚拟内存空间，其中0~3GB是每个进程的私有用户空间，这个空间对系统中其他进程是不可见的。3~4GB是linux内核空间，由系统所有的进程以及内核所共享的。通过访问/proc/{pid}/下相关文件，可以了解每个线程虚拟内存空间的使用情况，从而了解每个线程所消耗内存的多少。
由于我们的产品都是使用多线程方式实现的，多个线程共享一个进程的用户态虚拟地址空间，虚拟地址空间包含若干区域，主要有如下几个区域：
1、当前执行文件的代码段，该代码段称为text段。
2、执行文件的数据段，主要存储执行文件用到的全局变量，静态变量。
3、存储全局变量和动态产生的数据的堆。
4、用于保存局部变量和实现函数调用的栈。
5、采用mmap方式映射到虚拟地址空间中的内存段&lt;/p&gt;

&lt;p&gt;所以只需要查看任意一个线程的用户态虚拟地址空间分配即可知道属于同一进程的所有线程占用总内存的大小。可以通过查看/proc/{pid}/maps文件来获取相关的虚拟地址空间内容，下文摘列部分典型的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/568/maps
00008000-0036a000 r-xp 00000000 00:0e 236        /home/hik/hicore
00372000-003a5000 rw-p 00362000 00:0e 236        /home/hik/hicore
003a5000-00e28000 rwxp 003a5000 00:00 0          [heap]
40000000-40005000 r-xp 00000000 01:00 94         /lib/ld-uClibc.so.0
416db000-41770000 rw-s c2005000 00:0f 68         /dev/mem

b51fc000-b5200000 rwxp b51fc000 00:00 0
…….
be1fc000-be200000 rwxp be1fc000 00:00 0
be93b000-be950000 rwxp befeb000 00:00 0          [stack]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行：从r-xp可知其权限为只读、可执行，该段内存地址对应于执行文件的
代码段，程序的代码段需加载到内存中才可以执行。由于其只读，不会
被修改，所以在整个系统内共享。
第二行：从rw-p可知其权限为可读写，不可执行，该段内存地址对应于执行文件的数据段，存放执行文件所用到的全局变量、静态变量。
第三行：从rwxp可知其权限是可读写，可执行，地址空间向上增长，而且不对应文件，是堆段，进程使用malloc申请的内存放在堆段。每个进程只有一个堆段，不论是主进程，还是不同的线程申请的内存，都反映到到进程的堆段。堆段向上增长，最大可以增长到1GB的位置，即0x40000000，如果大于1GB，glibc将采用mmap的方式，为堆申请一块内存。
第四行：是程序连接的共享库的内存地址。
第五行：是以mmap方式映射的虚拟地址空间。
第六、七行：是线程的栈区地址段，每个线程的栈大小都是16K。
第八行：是进程的栈区。关于栈段，每个线程都有一个，如果进程中有多个线程，则包含多个栈段。&lt;/p&gt;

&lt;p&gt;三、当前系统总内存的统计
    1、进程占用的总内存可以通过上述maps表计算出来。
    2、当系统运行起来以后，会把应用层相关的文件挂载到tmpfs文件系统下，海思系统下这部分大概有13M左右，这部分内存是以cache方式统计出来的，但是这部分内存cache无法通过回收策略或者显式的调用释放掉。
    3、根文件系统ramdisk占用的内存。
    4、当前系统保留内存的大小，可以通过查看/proc/sys/vm/min_free_kbytes来获取或者修改此内存的大小。
    5、当然，当系统运行起来后，还应该留有一定的内存用于在硬盘读写时做cache或者网络负荷比较高时分配skb等，一般需要30M以上。&lt;/p&gt;

&lt;p&gt;四、对调试内存泄露类问题的一些启示
   当进程申请内存时，实际上是glibc中内置的内存管理器接收了该请求，随着进程申请内存的增加，内存管理器会通过系统调用陷入内核，从而为进程分配更多的内存。
针对堆段的管理，内核提供了两个系统调用brk和mmap，brk用于更改堆顶地址，而mmap则为进程分配一块虚拟地址空间。
当进程向glibc申请内存时，如果申请内存的数量大于一个阀值的时候，glibc会采用mmap为进程分配一块虚拟地址空间，而不是采用brk来扩展堆顶的指针。缺省情况下，此阀值是128K，可以通过函数来修改此值。
             #include
             Int mallopt(int param, int value)
Param的取值分别为M_MMAP_THRESHOLD、M_MMAP_MAX。
Value的取值是以字节为单位的。
M_MMAP_THRESHOLD是glibc中申请大块内存阀值，大于该阀值的内存申请，内存管理器将使用mmap系统调用申请内存，如果小于该阀值的内存申请，内存管理器使用brk系统调用扩展堆顶指针。
M_MMAP_MAX是该进程中最多使用mmap分配地址段的数量。&lt;/p&gt;

&lt;p&gt;如果在实际的调试过程中，怀疑某处发生了内存泄露，可以查看该进程的maps表，看进程的堆段或者mmap段的虚拟地址空间是否持续增加，如果是，说明很可能发生了内存泄露，如果mmap段虚拟地址空间持续增加，还可以看到各个段的虚拟地址空间的大小，从而可以确定是申请了多大的内存，对调试内存泄露类问题可以起到很好的定位作用。&lt;/p&gt;

&lt;p&gt;如何检测内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏的问题，在百度是遇到最多的，阿里相对少点。与内存泄漏斗争了很久，我总结下常用的一些有效测试方法吧。
　　1、valgrind，这是非常好用的工具，虽然参数很多，输出结果较多，但是只要认真看下，就很容易发现问题，报告是很详细的，不要被吓倒。valgrind检测的内存泄漏是非常准的，可以精确定位到代码行甚至是变量。valgrind基于valginrd core框架，这是个非常有强大的框架，他的作用不仅仅在于检测内存泄漏的，强烈建议测试新手通读下全部的文档。valgind自己也会有误报和漏报，所有具体场景需要具体分析。报告中一旦出现definitely lost的标记，就表示一定会有内存泄漏，泄漏的字节数也会报告出来，可以根据泄漏的内存大小和请求次数计算出到底是那个变量没有释放。
　　2、利用pmap+gdb，pmap可以列出特定进程的所有内存分配的地址和大小，通过gdb就可以直接看这些地址属于什么变量，通过统计这些内存地址的大小，就可以很容易的发现问题。利用自动化的gdb调试工具也可以很方便的定位。
　　3、其他的还包括memprof、商业工具Purify IBM出品，官方宣传说的不错，但是这种不开放的技术，在业界得不到认可，国内大公司一般那都不用，只有人傻钱多的公司在用。
　　4、利用一些trace工具，比如ptrace，strace之类的工具，这些trace工具会追踪特定的api，只需要统计malloc和free的调用次数就可以简单的发现是否有泄漏，但是无法定位代码行。另外还有一个更高深的工具，SystemTap，这个在国内应用还不多，但是非常厉害，可以方便hook程序的关键逻辑并插入探针。从而可以方便的检测内存泄漏。Systemtap目前还不通用，而且安装复杂，暂时不推荐使用，可以关注下，过几年可能会大规模应用。
　　valgrind是首选，因为他的设计就是为了解决所有的c++的内存问题。一些valgrind不能简单发现的，我一般会review代码，然后通过gdb自动调试技术来发现问题。通过valgrind+gdb，可以解决所有的内存泄漏。
　　另外，内存的泄漏也并不完全是没有及时的free，还有可能是其他的原因，比如设计问题等。需要靠一定的开发经验判断。
　　要尽量把静态测试和动态测试尽早的加入到持续集成中，以尽早的发现问题，不然一旦代码复杂，追查的成本就会增大。&lt;/p&gt;

&lt;p&gt;目的：
本文是《一种定位内存泄露的方法（Solaris）》对应的Linux版本，调试器使用gdb。主要介绍实例部分。其他请见《一种定位内存泄露的方法（Solaris）》。&lt;/p&gt;

&lt;p&gt;实例：
模拟new失败的程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdexcept&amp;gt;
class ABC
{
public:
        virtual ~ABC(){}
        int i;
        int j;
};

void f()
{
        for (int i = 0; i &amp;lt; 1000; ++i)
        {
                ABC* p = new ABC;
        }
        throw std::bad_alloc();
}

int main()
{
        f();
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1） 编译运行此段代码。产生一个core文件
2） 用gdb打开这个core文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb a.out core
(gdb) run
Starting program: /test/new_fail/a.out
terminate called after throwing an instance of &#39;std::bad_alloc&#39;
  what():  std::bad_alloc

Program received signal SIGABRT, Aborted.
0x00007ffff733f645 in raise () from /lib64/libc.so.6
(gdb) info proc
process 10683
cmdline = &#39;/test/new_fail/a.out&#39;
cwd = &#39;/test/new_fail&#39;
exe = &#39;/test/new_fail/a.out&#39;
(gdb) shell pmap 10683
10683: a.out
START               SIZE     RSS     PSS   DIRTY    SWAP PERM MAPPING
0000000000400000      4K      4K      4K      0K      0K r-xp /test/new_fail/a.out
0000000000600000      4K      4K      4K      4K      0K r--p /test/new_fail/a.out
0000000000601000      4K      4K      4K      4K      0K rw-p /test/new_fail/a.out
0000000000602000    132K     32K     32K     32K      0K rw-p [heap]
…（略）
Total:            11468K   1048K    684K    180K      0K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;360K writable-private, 11108K readonly-private, 0K shared, and 1048K referenced&lt;/p&gt;

&lt;p&gt;可以看到heap空间的起始地址是0x0000000000602000，共132K字节，即132*1024=135168字节。
3） 因为是64位应用程序，所以指针占8字节。所以需要遍历的指针个数为135168/8=16896。
4） 将结果输出到日志文件gdb.txt中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set height 0
(gdb) set logging on
Copying output to gdb.txt.
(gdb) x/16896a 0x0000000000602000
gdb.txt的内容：
0x602000:       0x0     0x21
0x602010:       0x400b30 &amp;lt;_ZTV3ABC+16&amp;gt;  0x0
0x602020:       0x0     0x21
0x602030:       0x400b30 &amp;lt;_ZTV3ABC+16&amp;gt;  0x0
….
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5） 过滤gdb.txt：
awk &amp;lsquo;{print $2&amp;rdquo;/n&amp;rdquo;$3}&amp;rsquo; gdb.txt|c++filt|grep vtable&amp;gt;gdb_vtable.txt
gdb_vtable.txt的内容为：
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
….
6） 将gdb_vtable.txt的内容导入到SQLServer中（如果记录不多，可以用Excel代替）。表名为gdb_vtable，第一列Col001为符号。对其分组求和：
select Col001, count(1) quantity from gdb_vtable
group by Col001
order by quantity desc
结果为：
Col001                                                                                    quantity
&lt;vtable for ABC+16&gt;                                                              1000
&lt;vtable for std::bad_alloc@@GLIBCXX_3.4+16&gt;                1
可知core里有1000个ABC，遍历使用ABC的代码，可知存在泄漏。&lt;/p&gt;

&lt;p&gt;linux下调试内存泄露的利器Valgrind&lt;/p&gt;

&lt;p&gt;Valgrind的主要作者Julian Seward刚获得了今年的Google-O&amp;rsquo;Reilly开源大奖之一──Best Tool Maker。让我们一起来看一下他的作品。Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，它包含一个内核──一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务──调试，分析，或测试等。Valgrind可以检测内存泄漏和内存违例，还可以分析cache的使用等，灵活轻巧而又强大，能直穿程序错误的心脏，真可谓是程序员的瑞士军刀。&lt;/p&gt;

&lt;p&gt;更详细的文档可以参考：Valgrind Documentation&lt;/p&gt;

&lt;p&gt;一. Valgrind概观&lt;/p&gt;

&lt;p&gt;Valgrind的最新版是3.2.0，它一般包含下列工具：
1.Memcheck&lt;/p&gt;

&lt;p&gt;最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到， 一切对malloc()/free()/new/delete的调用都会被捕获。所以，它能检测以下问题：&lt;/p&gt;

&lt;p&gt;1.对未初始化内存的使用；&lt;/p&gt;

&lt;p&gt;2.读/写释放后的内存块；&lt;/p&gt;

&lt;p&gt;3.读/写超出malloc分配的内存块；&lt;/p&gt;

&lt;p&gt;4.读/写不适当的栈中内存块；&lt;/p&gt;

&lt;p&gt;5.内存泄漏，指向一块内存的指针永远丢失；&lt;/p&gt;

&lt;p&gt;6.不正确的malloc/free或new/delete匹配；&lt;/p&gt;

&lt;p&gt;7,memcpy()相关函数中的dst和src指针重叠。&lt;/p&gt;

&lt;p&gt;这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。
2.Callgrind&lt;/p&gt;

&lt;p&gt;和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。
3.Cachegrind&lt;/p&gt;

&lt;p&gt;Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。
4.Helgrind&lt;/p&gt;

&lt;p&gt;它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。
5. Massif&lt;/p&gt;

&lt;p&gt;堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。&lt;/p&gt;

&lt;p&gt;此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。我们就不做介绍了。
二. 使用Valgrind&lt;/p&gt;

&lt;p&gt;Valgrind的使用非常简单，valgrind命令的格式如下：&lt;/p&gt;

&lt;p&gt;valgrind [valgrind-options] your-prog [your-prog options]&lt;/p&gt;

&lt;p&gt;一些常用的选项如下：&lt;/p&gt;

&lt;p&gt;选项&lt;/p&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;-h &amp;ndash;help&lt;/p&gt;

&lt;p&gt;显示帮助信息。&lt;/p&gt;

&lt;p&gt;&amp;ndash;version&lt;/p&gt;

&lt;p&gt;显示valgrind内核的版本，每个工具都有各自的版本。&lt;/p&gt;

&lt;p&gt;-q &amp;ndash;quiet&lt;/p&gt;

&lt;p&gt;安静地运行，只打印错误信息。&lt;/p&gt;

&lt;p&gt;-v &amp;ndash;verbose&lt;/p&gt;

&lt;p&gt;打印更详细的信息。&lt;/p&gt;

&lt;p&gt;&amp;ndash;tool=&lt;toolname&gt; [default: memcheck]&lt;/p&gt;

&lt;p&gt;最常用的选项。运行valgrind中名为toolname的工具。如果省略工具名，默认运行memcheck。&lt;/p&gt;

&lt;p&gt;&amp;ndash;db-attach=&lt;yes|no&gt; [default: no]&lt;/p&gt;

&lt;p&gt;绑定到调试器上，便于调试错误。&lt;/p&gt;

&lt;p&gt;我们通过例子看一下它的具体使用。我们构造一个存在内存泄漏的C程序，如下：&lt;/p&gt;

&lt;p&gt;[cpp] view plaincopyprint?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
void f(void)  
{  
    int* x = malloc(10 * sizeof(int));  
    x[10] = 0; // problem 1: heap block overrun  
    } // problem 2: memory leak -- x not freed  
    int main(void)  
    {  
    int i;  
    f();  
    printf(&amp;quot;i=%d\n&amp;quot;,i); //problem 3: use uninitialised value.  
    return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存为memleak.c并编译，然后用valgrind检测。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -Wall -o memleak memleak.c
$ valgrind --tool=memcheck ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到如下错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== Invalid write of size 4
==3649== at 0x80483CF: f (in /home/wangcong/memleak)
==3649== by 0x80483EC: main (in /home/wangcong/memleak)
==3649== Address 0x4024050 is 0 bytes after a block of size 40 alloc&#39;d
==3649== at 0x40051F9: malloc (vg_replace_malloc.c:149)
==3649== by 0x80483C5: f (in /home/wangcong/memleak)
==3649== by 0x80483EC: main (in /home/wangcong/memleak)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的3649是程序运行时的进程号。第一行是告诉我们错误类型，这里是非法写入。下面的是告诉我们错误发生的位置，在main()调用的f()函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== Use of uninitialised value of size 4
==3649== at 0xC3A264: _itoa_word (in /lib/libc-2.4.so)
==3649== by 0xC3E25C: vfprintf (in /lib/libc-2.4.so)
==3649== by 0xC442B6: printf (in /lib/libc-2.4.so)
==3649== by 0x80483FF: main (in /home/wangcong/memleak)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个错误是使用未初始化的值，在main()调用的printf()函数中。这里的函数调用关系是通过堆栈跟踪的，所以有时会非常多，尤其是当你使用C++的STL时。其它一些错误都是由于把未初始化的值传递给libc函数而被检测到。在程序运行结束后，valgrind还给出了一个小的总结：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== ERROR SUMMARY: 20 errors from 6 contexts (suppressed: 12 from 1)
==3649== malloc/free: in use at exit: 40 bytes in 1 blocks.
==3649== malloc/free: 1 allocs, 0 frees, 40 bytes allocated.
==3649== For counts of detected errors, rerun with: -v
==3649== searching for pointers to 1 not-freed blocks.
==3649== checked 47,256 bytes.
==3649==
==3649== LEAK SUMMARY:
==3649== definitely lost: 40 bytes in 1 blocks.
==3649== possibly lost: 0 bytes in 0 blocks.
==3649== still reachable: 0 bytes in 0 blocks.
==3649== suppressed: 0 bytes in 0 blocks.
==3649== Use --leak-check=full to see details of leaked memory.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以很清楚地看出，分配和释放了多少内存，有多少内存泄漏。这对我们查找内存泄漏十分方便。然后我们重新编译程序并绑定调试器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -Wall -ggdb -o memleak memleak.c
$ valgrind --db-attach=yes --tool=memcheck ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一出现错误，valgrind会自动启动调试器（一般是gdb）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3893== ---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ---- y
starting debugger
==3893== starting debugger with cmd: /usr/bin/gdb -nw /proc/3895/fd/1014 3895
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出gdb后我们又能回到valgrind继续执行程序。&lt;/p&gt;

&lt;p&gt;还是用上面的程序，我们使用callgrind来分析一下它的效率：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ valgrind --tool=callgrind ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Callgrind会输出很多，而且最后在当前目录下生成一个文件： callgrind.out.pid。用callgrind_annotate来查看它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ callgrind_annotate callgrind.out.3949
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的信息就列出来了。而且，当callgrind运行你的程序时，你还可以使用callgrind_control来观察程序的执行，而且不会干扰它的运行。&lt;/p&gt;

&lt;p&gt;再来看一下cachegrind的表现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ valgrind --tool=cachegrind ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==4073== I refs: 147,500
==4073== I1 misses: 1,189
==4073== L2i misses: 679
==4073== I1 miss rate: 0.80%
==4073== L2i miss rate: 0.46%
==4073==
==4073== D refs: 61,920 (46,126 rd + 15,794 wr)
==4073== D1 misses: 1,759 ( 1,545 rd + 214 wr)
==4073== L2d misses: 1,241 ( 1,062 rd + 179 wr)
==4073== D1 miss rate: 2.8% ( 3.3% + 1.3% )
==4073== L2d miss rate: 2.0% ( 2.3% + 1.1% )
==4073==
==4073== L2 refs: 2,948 ( 2,734 rd + 214 wr)
==4073== L2 misses: 1,920 ( 1,741 rd + 179 wr)
==4073== L2 miss rate: 0.9% ( 0.8% + 1.1% )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的是指令缓存，I1和L2i缓存，的访问信息，包括总的访问次数，丢失次数，丢失率。&lt;/p&gt;

&lt;p&gt;中间的是数据缓存，D1和L2d缓存，的访问的相关信息，下面的L2缓存单独的信息。Cachegrind也生成一个文件，名为cachegrind.out.pid，可以通过cg_annotate来读取。输出是一个更详细的列表。Massif的使用和cachegrind类似，不过它也会生成一个名为massif.pid.ps的PostScript文件，里面只有一幅描述堆栈使用状况的彩图。&lt;/p&gt;

&lt;p&gt;以上只是简单的演示了valgrind的使用，更多的信息可以在它附带的文档中得到，也可以访问valgrind的主页：&lt;a href=&#34;http://www.valgrind.org。学会正确合理地使用valgrind对于调试程序会有很大的帮助。&#34;&gt;http://www.valgrind.org。学会正确合理地使用valgrind对于调试程序会有很大的帮助。&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用GDB调试程序</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-2</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-2</guid>
      <description>&lt;p&gt;#用GDB调试程序
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。
#用GDB调试程序
##GDB概述
————
GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那
种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你
会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，
尺有所短”就是这个道理。
一般来说，GDB主要帮忙你完成下面四个方面的功能：
1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
3、当程序被停住时，可以检查此时你的程序中所发生的事。
4、动态的改变你程序的执行环境。
从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细
节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有
时候，命令行的调试工具却有着图形化工具所不能完成的功能。让我们一一看来。
##一个调试示例
——————
源程序：tst.c
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i&lt;7; i++) {
8 sum+=i; 
9 } 
10 return sum; 
11 } 
12 
13 
14 main() 
15 { 
16 int i; 
17 long result = 0; 
18 for(i=1; i&lt;=100; i++) 
19 { 
20 result += i; 
21 } 
22 
23 printf(&#34;result[1-100] = %d /n&#34;, result ); 
24 printf(&#34;result[1-250] = %d /n&#34;, func(250) ); 
25 } 
编译生成执行文件：（Linux下） 
hchen/test&gt; cc -g tst.c -o tst
使用GDB调试：
hchen/test&amp;gt; gdb tst &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;- 启动GDB
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &amp;ldquo;show copying&amp;rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i386-suse-linux&amp;rdquo;&amp;hellip;
(gdb) l &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; l命令相当于list，从第一行开始例出原码。
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i 7 {
8 sum+=i;
9 }
10 return sum;
(gdb) &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 直接回车表示，重复上一次命令
11 }&lt;/p&gt;

&lt;p&gt;12
13
14 main()
15 {
16 int i;
17 long result = 0;
18 for(i=1; i&amp;lt;=100; i++)
19 {
20 result += i;
(gdb) break 16 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 设置断点，在源程序第16行处。
Breakpoint 1 at 0x8048496: file tst.c, line 16.
(gdb) break func &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 设置断点，在函数func()入口处。
Breakpoint 2 at 0x8048456: file tst.c, line 5.
(gdb) info break &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 查看断点信息。
Num Type Disp Enb Address What
1 breakpoint keep y 0x08048496 in main at tst.c:16
2 breakpoint keep y 0x08048456 in func at tst.c:5
(gdb) r &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 运行程序，run命令简写
Starting program: /home/hchen/test/tst
Breakpoint 1, main () at tst.c:17 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;- 在断点处停住。
17 long result = 0;
(gdb) n &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 单条语句执行，next命令简写。
18 for(i=1; i&amp;lt;=100; i++)
(gdb) n
20 result += i;
(gdb) n
18 for(i=1; i&amp;lt;=100; i++)
(gdb) n
20 result += i;
(gdb) c &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 继续运行程序，continue命令简写。
Continuing.
result[1-100] = 5050 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-程序输出。
Breakpoint 2, func (n=250) at tst.c:5
5 int sum=0,i;
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)
(gdb) p i &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 打印变量i的值，print命令简写。
$1 = 134513808
(gdb) n
8 sum+=i;
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)&lt;/p&gt;

&lt;p&gt;(gdb) p sum
$2 = 1
(gdb) n
8 sum+=i;
(gdb) p i
$3 = 2
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)
(gdb) p sum
$4 = 3
(gdb) bt &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 查看函数堆栈。
#0 func (n=250) at tst.c:5
#1 0x080484e4 in main () at tst.c:24
#2 0x400409ed in __libc_start_main () from /lib/libc.so.6
(gdb) finish &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 退出函数。
Run till exit from #0 func (n=250) at tst.c:5
0x080484e4 in main () at tst.c:24
24 printf(&amp;ldquo;result[1-250] = %d /n&amp;rdquo;, func(250) );
Value returned is $6 = 31375
(gdb) c &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 继续运行。
Continuing.
result[1-250] = 31375 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-程序输出。
Program exited with code 027. &amp;lt;&amp;mdash;&amp;mdash;&amp;ndash;程序退出，调试结束。
(gdb) q &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 退出gdb。
hchen/test&amp;gt;
好了，有了以上的感性认识，还是让我们来系统地认识一下gdb吧。
使用GDB
————
一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必
须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。
如：
&amp;gt; cc -g hello.c -o hello
&amp;gt; g++ -g hello.cpp -o hello
如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用
-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。
启动GDB的方法有以下几种：&lt;/p&gt;

&lt;p&gt;###1、gdb
program也就是你的执行文件，一般在当然目录下。
###2、gdb core
用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
###3、gdb
如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自
动attach上去，并调试他。program应该在PATH环境变量中搜索得到。
GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下
面只例举一些比较常用的参数：
-symbols
-s
从指定文件中读取符号表。
-se file
从指定文件中读取符号表信息，并把他用在可执行文件中。
-core
-c
调试时core dump的core文件。
-directory
-d
加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
#GDB的命令概貌
———————
启动gdb后，就你被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb
的命令可以使用help命令来查看，如下所示：
/home/hchen&amp;gt; gdb
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &amp;ldquo;show copying&amp;rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i386-suse-linux&amp;rdquo;.
(gdb) help&lt;/p&gt;

&lt;p&gt;List of classes of commands:
aliases &amp;ndash; Aliases of other commands
breakpoints &amp;ndash; Making program stop at certain points
data &amp;ndash; Examining data
files &amp;ndash; Specifying and examining files
internals &amp;ndash; Maintenance commands
obscure &amp;ndash; Obscure features
running &amp;ndash; Running the program
stack &amp;ndash; Examining the stack
status &amp;ndash; Status inquiries
support &amp;ndash; Support facilities
tracepoints &amp;ndash; Tracing of program execution without stopping the program
user-defined &amp;ndash; User-defined commands
Type &amp;ldquo;help&amp;rdquo; followed by a class name for a list of commands in that class.
Type &amp;ldquo;help&amp;rdquo; followed by command name for full documentation.
Command name abbreviations are allowed if unambiguous.
(gdb)
gdb的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看
种类中的命令，可以使用help 命令，如：help breakpoints，查看设置断点的所有命令。也
可以直接help 来查看命令的帮助。
gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令
的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐
命令的全称，如果有重复的，那么gdb会把其例出来。
示例一：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func
(gdb) b func
Breakpoint 1 at 0x8048458: file hello.c, line 10.
示例二：敲入b按两次TAB键，你会看到所有b打头的命令：
(gdb) b
backtrace break bt
(gdb)
示例三：只记得函数的前缀，可以这样：
(gdb) b make_ &amp;lt;按TAB键&amp;gt;
（再按下一次TAB键，你会看到:）
make_a_section_from_file make_environ
make_abs_section make_function_type
make_blockvector make_pointer_type&lt;/p&gt;

&lt;p&gt;make_cleanup make_reference_type
make_command make_symbol_completion&lt;em&gt;list
(gdb) b make&lt;/em&gt;
GDB把所有make开头的函数全部例出来给你查看。
示例四：调试C++的程序时，有可以函数名一样。如：
(gdb) b &amp;lsquo;bubble( M-?
bubble(double,double) bubble(int,int)
(gdb) b &amp;lsquo;bubble(
你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思）
要退出gdb时，只用发quit或命令简称q就行了。
GDB中运行UNIX的shell程序
————————————
在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
shell
调用UNIX的shell来执行，环境变量SHELL中定义的UNIX的shell将会被用来执行，如
果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。（在Windows中使用Command.com
或cmd.exe）
还有一个gdb命令是make：
make
可以在gdb中执行make命令来重新build自己的程序。这个命令等价于“shell make ”。
在GDB中运行程序
————————
当以gdb 方式启动gdb后，gdb会在PATH路径和当前目录中搜索的源文件。如要确认gdb
是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。
在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。
###1、程序运行参数。
set args 可指定运行时参数。（如：set args 10 20 30 40 50）
show args 命令可以查看设置好的运行参数。
###2、运行环境。
path
可设定程序的运行路径。
show paths 查看程序的运行路径。&lt;/p&gt;

&lt;p&gt;set environment varname [=value] 设置环境变量。如：set env USER=hchen
show environment [varname] 查看环境变量。
###3、工作目录。
cd
相当于shell的cd命令。
pwd 显示当前的所在目录。
###4、程序的输入输出。
info terminal 显示你程序用到的终端的模式。
使用重定向控制程序输出。如：run &amp;gt; outfile
tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb
#调试已运行的程序
————————
两种方法：
1、在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在
运行的程序。
2、先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用
detach来取消挂接的进程。
#暂停 / 恢复程序运行
—————————
调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序
的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变
量，以及运行时的流程。
当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停
的原因。
在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕
捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可
以使用c或是continue命令。
##一、设置断点（BreakPoint）
我们用break命令来设置断点。正面有几点设置断点的方法：
break
在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函&lt;/p&gt;

&lt;p&gt;数名。
break
在指定行号停住。
break +offset
break -offset
在当前行号的前面或后面的offset行停住。offiset为自然数。
break filename:linenum
在源文件filename的linenum行处停住。
break filename:function
在源文件filename的function函数的入口处停住。
break *address
在程序运行的内存地址处停住。
break
break命令没有参数时，表示在下一条指令处停住。
break &amp;hellip; if
&amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设
置break if i=100，表示当i为100时停住程序。
查看断点时，可使用info命令，如下所示：（注：n表示断点号）
info breakpoints [n]
info break [n]
##二、设置观察点（WatchPoint）
观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马
上停住程序。我们有下面的几种方法来设置观察点：
watch
为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
rwatch
当表达式（变量）expr被读时，停住程序。
awatch
当表达式（变量）的值被读或被写时，停住程序。&lt;/p&gt;

&lt;p&gt;info watchpoints
列出当前所设置了的所有观察点。
##三、设置捕捉点（CatchPoint）
你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++
的异常。设置捕捉点的格式为：
catch
当event发生时，停住程序。event可以是下面的内容：
1、throw 一个C++抛出的异常。（throw为关键字）
2、catch 一个C++捕捉到的异常。（catch为关键字）
3、exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）
4、fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）
5、vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）
6、load 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX
下有用）
7、unload 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在
HP-UX下有用）
tcatch
只设置一次捕捉点，当程序停住以后，应点被自动删除。
##四、维护停止点
上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你
觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来
进行维护。
clear
清除所有的已定义的停止点。
clear
clear
清除所有设置在函数上的停止点。
clear
clear
清除所有设置在指定行上的停止点。
delete [breakpoints] [range&amp;hellip;]
删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range
表示断点号的范围（如：3-7）。其简写命令为d。&lt;/p&gt;

&lt;p&gt;比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要
时，enable即可，就好像回收站一样。
disable [breakpoints] [range&amp;hellip;]
disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的
停止点。简写命令是dis.
enable [breakpoints] [range&amp;hellip;]
enable所指定的停止点，breakpoints为停止点号。
enable [breakpoints] once range&amp;hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。
enable [breakpoints] delete range&amp;hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。
##五、停止条件维护
前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这
是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点
设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以
用condition命令来修改断点的条件。（只有break和watch命令支持if，catch目前暂不支持
if）
condition
修改断点号为bnum的停止条件为expression。
condition
清除断点号为bnum的停止条件。
还有一个比较特殊的维护命令ignore，你可以指定程序运行时，忽略停止条件几次。
ignore
表示忽略断点号为bnum的停止条件count次。
##六、为停止点设定运行命令
我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的
程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于
GDB的自动化调试是一个强大的支持。
commands [bnum]&lt;/p&gt;

&lt;p&gt;&amp;hellip; command-list &amp;hellip;
end
为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的
命令。
例如：
break foo if x&amp;gt;0
commands
printf &amp;ldquo;x is %d/n&amp;rdquo;,x
continue
end
断点设置在函数foo中，断点条件是x&amp;gt;0，如果程序被断住后，也就是，一旦x的值在foo
函数中大于0，GDB会自动打印出x的值，并继续运行程序。
如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个
end就行了。
##七、断点菜单
在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break 不
能告诉GDB要停在哪个函数的入口。当然，你可以使用break 也就是把函数的参数类型告
诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的
断点。你只要输入你菜单列表中的编号就可以了。如：
(gdb) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
&amp;gt; 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the &amp;ldquo;delete&amp;rdquo; command to delete unwanted
breakpoints.
(gdb)&lt;/p&gt;

&lt;p&gt;可见，GDB列出了所有after的重载函数，你可以选一下列表编号就行了。0表示放弃设置
断点，1表示所有函数都设置断点。
##八、恢复程序运行和单步调试
当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。
也可以使用step或next命令单步跟踪程序。
continue [ignore-count]
c [ignore-count]
fg [ignore-count]
恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次
数。continue，c，fg三个命令都是一样的意思。
step
单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug
信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，
加表示执行后面的count条指令，然后再停住。
next
同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面
可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后
再停住。
set step-mode
set step-mode on
打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。
这个参数有很利于查看机器码。
set step-mod off
关闭step-mode模式。
finish
运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
until 或 u
当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
stepi 或 si
nexti 或 ni
单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步
执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单
步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）&lt;/p&gt;

&lt;p&gt;##九、信号（Signals）
信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤
其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT
表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示
子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下
非常重要的一种技术。
GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信
号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。
你可以用GDB的handle命令来完成这一功能。
handle
在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处
理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包
括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。
一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几
种关键字的一个或多个。
nostop
当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信
号。
stop
当被调试的程序收到信号时，GDB会停住你的程序。
print
当被调试的程序收到信号时，GDB会显示出一条信息。
noprint
当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。
pass
noignore
当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程
序会处理。
nopass
ignore
当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
info signals
info handle
查看有哪些信号在被GDB检测中。
##十、线程（Thread Stops）&lt;/p&gt;

&lt;p&gt;如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线
程。GDB很容易帮你完成这一工作。
break thread
break thread if &amp;hellip;
linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是
GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你
不指定thread 则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如：
(gdb) break frik.c:13 thread 28 if bartab &amp;gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体
情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。
#查看栈信息
—————
当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一
个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以
用GDB命令来查看当前的栈中的信息。
下面是一些查看函数调用栈信息的GDB命令：
backtrace
bt
打印当前的函数调用栈的所有信息。如：
(gdb) bt
#0 func (n=250) at tst.c:6
#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2 0x400409ed in &lt;strong&gt;libc_start_main () from /lib/libc.so.6
从上可以看出函数的调用栈信息：&lt;/strong&gt;libc_start_main &amp;ndash;&amp;gt; main() &amp;ndash;&amp;gt; func()
backtrace
bt
n是一个正整数，表示只打印栈顶上n层的栈信息。
backtrace &amp;lt;-n&amp;gt;
bt &amp;lt;-n&amp;gt;
-n表一个负整数，表示只打印栈底下n层的栈信息。
如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈&lt;/p&gt;

&lt;p&gt;就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。
frame
f
n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的
第二层。
up
表示向栈的上面移动n层，可以不打n，表示向上移动一层。
down
表示向栈的下面移动n层，可以不打n，表示向下移动一层。
上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三
个命令：
select-frame 对应于 frame 命令。
up-silently 对应于 up 命令。
down-silently 对应于 down 命令。
查看当前栈层的信息，你可以用以下GDB命令：
frame 或 f
会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数
执行到的语句。
info frame
info f
这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比
如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写
成的、函数参数地址及值、局部变量的地址等等。如：
(gdb) info f
Stack level 0, frame at 0xbffff5d4:
eip = 0x804845d in func (tst.c:6); saved eip 0x8048524
called by frame at 0xbffff60c
source language c.
Arglist at 0xbffff5d4, args: n=250
Locals at 0xbffff5d4, Previous frame&amp;rsquo;s sp is 0x0
Saved registers:
ebp at 0xbffff5d4, eip at 0xbffff5d8
info args&lt;/p&gt;

&lt;p&gt;打印出当前函数的参数名及其值。
info locals
打印出当前函数中所有局部变量及其值。
info catch
打印出当前的函数中的异常处理信息。
#查看源程序
—————
##一、显示源代码
GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程
序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序
停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源
代码的GDB命令吧。
list
显示程序第linenum行的周围的源程序。
list
显示函数名为function的函数的源程序。
list
显示当前行后面的源程序。
list -
显示当前行前面的源程序。
一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当
然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。
set listsize
设置一次显示源代码的行数。
show listsize
查看当前listsize的设置。
list命令还有下面的用法：
list ,&lt;/p&gt;

&lt;p&gt;显示从first行到last行之间的源代码。
list ,
显示从当前行到last行之间的源代码。
list +
往后显示源代码。
一般来说在list后面可以跟以下这们的参数：
行号。
&amp;lt;+offset&amp;gt; 当前行号的正偏移量。
&amp;lt;-offset&amp;gt; 当前行号的负偏移量。
哪个文件的哪一行。
函数名。
哪个文件中的哪个函数。
&amp;lt;*address&amp;gt; 程序运行时的语句在内存中的地址。
##二、搜索源代码
不仅如此，GDB还提供了源代码搜索的命令：
forward-search
search
向前面搜索。
reverse-search
全部搜索。
其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，
还请各位查看相关资料。
##三、指定源文件的路径
某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供
了可以让你指定源文件的路径的命令，以便GDB进行搜索。
directory
dir
加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，
Windows下你可以使用“;”。&lt;/p&gt;

&lt;p&gt;directory
清除所有的自定义的源文件搜索路径信息。
show directories
显示定义了的源文件搜索路径。
##四、源代码的内存
你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函
数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内
存地址，如：
(gdb) info line tst.c:func
Line 5 of &amp;ldquo;tst.c&amp;rdquo; starts at address 0x8048456 and ends at 0x804845d .
还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前
内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。
(gdb) disassemble func
Dump of assembler code for function func:
0x8048450 : push %ebp
0x8048451 : mov %esp,%ebp
0x8048453 : sub $0x18,%esp
0x8048456 : movl $0x0,0xfffffffc(%ebp)
0x804845d : movl $0x1,0xfffffff8(%ebp)
0x8048464 : mov 0xfffffff8(%ebp),%eax
0x8048467 : cmp 0x8(%ebp),%eax
0x804846a : jle 0x8048470
0x804846c : jmp 0x8048480
0x804846e : mov %esi,%esi
0x8048470 : mov 0xfffffff8(%ebp),%eax
0x8048473 : add %eax,0xfffffffc(%ebp)
0x8048476 : incl 0xfffffff8(%ebp)
0x8048479 : jmp 0x8048464
0x804847b : nop
0x804847c : lea 0x0(%esi,1),%esi
0x8048480 : mov 0xfffffffc(%ebp),%edx
0x8048483 : mov %edx,%eax
0x8048485 : jmp 0x8048487
0x8048487 : mov %ebp,%esp
0x8048489 : pop %ebp
0x804848a : ret
End of assembler dump.&lt;/p&gt;

&lt;p&gt;#查看运行时数据
———————
在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令
inspect来查看当前程序的运行数据。print命令的格式是：
print
print /
是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格
式，比如，如果要把表达式按16进制的格式输出，那么就是/x。
##一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据
来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函
数等内容。可惜的是GDB不能使用你在程序中所定义的宏。
表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本
文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）
在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。
@
是一个和数组有关的操作符，在后面会有更详细的说明。
::
指定一个在文件或是一个函数中的变量。
{}
表示一个指向内存地址的类型为type的一个对象。
##二、程序变量
在GDB中，你可以随时查看以下三种变量的值：
1、全局变量（所有文件可见的）
2、静态全局变量（当前文件可见的）
3、局部变量（当前Scope可见的）
如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局
变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函&lt;/p&gt;

&lt;p&gt;数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量
的值时，你可以使用“::”操作符：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看
文件f2.c中的全局变量x的值：
gdb) p &amp;lsquo;f2.c&amp;rsquo;::x
当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所
以你不必担心在调试C++程序时会出现异常。
另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过
的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为
优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB
调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结
果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支
持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决
这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
##三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大
小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右
边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其
保存在变量len中，其输出结果，大约是下面这个样子的：
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。
##四、输出格式&lt;/p&gt;

&lt;p&gt;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。
例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要
做到这样，你可以使用GDB的数据显示格式：
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &amp;lsquo;e&amp;rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101
##五、查看内存
你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是
指令地址，那么格式可以是i。&lt;/p&gt;

&lt;p&gt;u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可
以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当
我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作
一个值取出来。
表示一个内存地址。
n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3
表示三个单位，u表示按十六进制显示。
##六、自动显示
你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显
示。相关的GDB命令是display。
display
display/
display/
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一
个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。
格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc
$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇
编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的
功能。
下面是一些和display相关的GDB命令：
undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以
用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）
disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。&lt;/p&gt;

&lt;p&gt;info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多
少个自动显示设置，其中包括，设置的编号，表达式，是否enable。
##七、设置显示选项
GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。
set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
如：
(gdb) f
#0 set_quotes (lq=0x34c78 &amp;ldquo;&amp;lt;&amp;lt;&amp;ldquo;, rq=0x34c88 &amp;ldquo;&amp;gt;&amp;gt;&amp;rdquo;)
at input.c:530
530 if (lquote != def_lquote)
set print address off
关闭函数的参数地址显示，如：
(gdb) set print addr off
(gdb) f
#0 set_quotes (lq=&amp;rdquo;&amp;lt;&amp;lt;&amp;ldquo;, rq=&amp;rdquo;&amp;gt;&amp;gt;&amp;ldquo;) at input.c:530
530 if (lquote != def_lquote)
show print address
查看当前地址显示选项是否打开。
set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗
号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。
set print array off
show print array
set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的
最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。
show print elements&lt;/p&gt;

&lt;p&gt;查看print elements的选项信息。
set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。
set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：
$1 = {
next = 0x0,
flags = {
sweet = 1,
sour = 1
},
meat = 0x54 &amp;ldquo;Pork&amp;rdquo;
}
set print pretty off
关闭printf pretty这个选项，GDB显示结构体时会如下显示：
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54 &amp;ldquo;Pork&amp;rdquo;}
show print pretty
查看GDB是如何显示结构体的。
set print sevenbit-strings
设置字符显示，是否按“/nnn”的格式显示，如果打开，则字符串或字符数据按/nnn显示，
如“/065”。
show print sevenbit-strings
查看字符显示开关是否打开。
set print union
设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
Bug_forms;
struct thing {
Species it;
union {&lt;/p&gt;

&lt;p&gt;Tree_forms tree;
Bug_forms bug;
} form;
};
struct thing foo = {Tree, {Acorn}};
当打开这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
当关闭这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {&amp;hellip;}}
show print union
查看联合体数据的显示方式
set print object
在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法
调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是
off。
show print object
查看对象选项的设置。
set print static-members
这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是
on。
show print static-members
查看静态数据成员选项设置。
set print vtbl
当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。
show print vtbl
查看虚函数显示格式的选项。
##八、历史记录
当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB
会以$1, $2, $3 &amp;hellip;..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问
以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，
如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。&lt;/p&gt;

&lt;p&gt;##九、GDB环境变量
你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定
义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，
也是以$起头。如：
set $foo = *object_ptr
使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对
其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。
show convenience
该命令查看当前所设置的所有的环境变量。
这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。
例如：
set $i = 0
print bar[$i++]-&amp;gt;contents
于是，当你就不必，print bar[0]-&amp;gt;contents, print bar[1]-&amp;gt;contents地输入命令了。输入这样的
命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功
能。
##十、查看寄存器
要查看寄存器的值，很简单，可以使用如下命令：
info registers
查看寄存器的情况。（除了浮点寄存器）
info all-registers
查看所有寄存器的情况。（包括浮点寄存器）
info registers
查看所指定的寄存器的情况。
寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈
地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前
加一个$符号就可以了。如：p $eip。&lt;/p&gt;

&lt;p&gt;#改变程序的执行
———————
一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地
在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好
的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。
##一、修改变量值
修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。
如：
(gdb) print x=4
x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是
Pascal，那么你可以使用Pascal的语法：x:=4。
在某些时候，很有可能你的变量和GDB中的参数冲突，如：
(gdb) whatis width
type = double
(gdb) p width
$4 = 13
(gdb) set width=47
Invalid syntax in expression.
因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，
此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，
如：
(gdb) set var width=47
另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值
时，最好都使用set var格式的GDB命令。
##二、跳转执行
一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，
也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB
的jump命令来完：
jump&lt;/p&gt;

&lt;p&gt;指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏
移量格式。表式着下一条运行语句从哪里开始。
jump
这里的
是代码行的内存地址。
注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数
时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至
于产生程序Core Dump。所以最好是同一个函数中进行跳转。
熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，
jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行
的地址。如：
set $pc = 0x485
##三、产生信号量
使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便
于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，
这种精确地在某处产生信号非常有利程序的调试。
语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。
single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截
获的，而single命令所发出一信号则是直接发给被调试程序的。
##四、强制函数返回
如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数
忽略还没有执行的语句并返回。
return
return
使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认
作函数的返回值。
##五、强制调用函数&lt;/p&gt;

&lt;p&gt;call
表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返
回值是void，那么就不显示。
另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他
来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返
回值，并把该值存入历史数据中。
#在不同语言中使用GDB
——————————
GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和 Modula-2。一般说
来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”
的，GDB会认为是C程序。文件名后缀为“.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是
C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”
的会认为是汇编语言。
也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令
跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些表达式或
变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针的语法是*p，而在
Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言一同编译成的，那到在调
试过程中，GDB也能根据不同的语言自动地切换语言环境。这种跟着语言环境而改变的功
能，真是体贴开发人员的一种设计。
下面是几个相关于GDB语言环境的命令：
show language
查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默
认的环境。
info frame
查看当前函数的程序语言。
info source
查看当前文件的程序语言。
如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set
language命令即可做到。
当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：&lt;/p&gt;

&lt;p&gt;(gdb) set language
The currently understood settings are:
local or auto Automatic setting based on source file
c Use the C language
c++ Use the C++ language
asm Use the Asm language
chill Use the Chill language
fortran Use the Fortran language
java Use the Java language
modula-2 Use the Modula-2 language
pascal Use the Pascal language
scheme Use the Scheme language
于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。
#后记
——
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。（看到这句话时，希望各位千万再也不要认为
我就是“鄙视图形界面”，和我抬杠了 ）
我是根据版本为5.1.1的GDB所写的这篇文章，所以可能有些功能已被修改，或是又有更
为强劲的功能。而且，我写得非常仓促，写得比较简略，并且，其中我已经看到有许多错别
字了（我用五笔，所以错字让你看不懂），所以，我在这里对我文中的差错表示万分的歉意。
文中所罗列的GDB的功能时，我只是罗列了一些带用的GDB的命令和使用方法，其实，
我这里只讲述的功能大约只占GDB所有功能的60%吧，详细的文档，还是请查看GDB的
帮助和使用手册吧，或许，过段时间，如果我有空，我再写一篇GDB的高级使用。
我个人非常喜欢GDB的自动调试的功能，这个功能真的很强大，试想，我在UNIX下写个
脚本，让脚本自动编译我的程序，被自动调试，并把结果报告出来，调试成功，自动checkin
源码库。一个命令，编译带着调试带着checkin，多爽啊。只是GDB对自动化调试目前支持
还不是很成熟，只能实现半自动化，真心期望着GDB的自动化调试功能的成熟。&lt;/p&gt;

&lt;p&gt;如果各位对GDB或是别的技术问题有兴趣的话，欢迎和我讨论交流。本人目前主要在UNIX
下做产品软件的开发，所以，对UNIX下的软件开发比较熟悉，当然，不单单是技术，对软
件工程实施，软件设计，系统分析，项目管理我也略有心得。欢迎大家找我交流，（QQ是：
753640，MSN是：haoel@hotmail.com）
RelatedEntries：
文件操作 - 10 28, 2003
OSW:12.CVS设置与应用 - 10 28, 2003
MySQL AB Acquires Alzato - 10 24, 2003
cvs - 10 24, 2003
使用CVS进行版本管理 - 10 23, 2003&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用gdb调试程序笔记: 以段错误(Segmental fault)</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-3</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-3</guid>
      <description>&lt;p&gt;用gdb调试程序笔记: 以段错误(Segmental fault)为例[转]&lt;/p&gt;

&lt;p&gt;1.背景介绍
2.程序中常见的bug分类
3.程序调试器(如gdb)有什么用
4.段错误(Segmental fault)介绍
5.gdb调试入门&lt;/p&gt;

&lt;p&gt;一、背景介绍
这个笔记主要介绍开源的程序调试器(gdb)的入门知识，目的是使unix/linux环境的编程新手能够快速学会使用gdb调试程序的方法，同时也是对我使用gdb的一个经验总结。
本文假设你能使用简单的unix/linux命令并能用gcc(GNU C Compiler， GNU C 语言编译器)编译程序，当然有编程经验更好。：）
为帮助你理解和操作，我将使用我遇到过的真实事例来演示使用gdb调试有缺陷(bug)的程序过程，你看过这篇笔记后能自己动手练一下最好。&lt;/p&gt;

&lt;p&gt;二、程序中常见的缺陷(bug)分类
程序(编译型程序，perl、python，php等脚本程序除外)中常见的bug通常分为两类： 语法错误和逻辑错误，或者编译时错误和运行是错误。
语法错误(编译时错误)是我们在编写源代码时没有按照相关的语言规范(如ANSI C标准)导致编译时出错，编译失败。这种错误的检查和调试一般是比较简单和直接的：因为编译器(如gcc)通常会明确告诉你错误的原因和大致的范围(注意不一定是准确的错误行)。例如下面的一个简单demo.c程序的第8行缺失了一个分号，gcc指示第10行前少了一个分号。这就是一个典型的语法错误。
geekard@geekard:~/test$ cat -n demo.c
     1    #include&lt;stdio.h&gt;
     2&lt;br /&gt;
     3    int
     4    main(){
     5&lt;br /&gt;
     6        int n;
     7&lt;br /&gt;
     8        printf(&amp;ldquo;the n is:%c&amp;rdquo;, n)
     9&lt;br /&gt;
    10        return 0;
    11    }
geekard@geekard:~/test$ gcc demo.c -o demo
demo.c: In function ‘main’:demo.c:10:
error: expected ‘;’ before ‘return’
添加了分号再编译一次，这下没有出现问题，运行程序的结果如下：
geekard@geekard:~/test$ ./demo
the n is:6680564
另外注意这个程序中的变量n，我定义其为整型变量但并没有对其初始化赋值，这就是一个逻辑错误：编译器不会指示这个错误，只有在实际运行或测试时才能发现。
这个小程序只是一个故意的编造，但在实际编程中无论你多高明，经验多丰富，难免会在此处犯些小错误(想想吧：当你需要编写或维护一个成千上万行的代码，这种小概率事件就是确定事件了，：）)，而通常这些错误又是那么的浅显而易于消除，但是手工“除虫”（debug），往往是效率低下且让人厌烦的，本文将就&amp;rdquo;段错误&amp;rdquo;这个内存访问越界的错误谈谈如何使用gdb快速定位这些&amp;rdquo;段错误&amp;rdquo;的语句。&lt;/p&gt;

&lt;p&gt;三、程序调试器(如gdb)有什么用？(参考自gdb的在线帮助手册, 可用命令：man gdb， 或 info gdb查看)&lt;/p&gt;

&lt;p&gt;程序调试器(如gdb)的主要目的是让你能够查看正在执行的程序其内部特性(如执行流程、变量值、函数调用、堆栈等)，也可以程序崩溃时刻或以前都发生了什么。
Gdb对程序的调试能力主要体现在以下四个方面(当然不止这些):&lt;br /&gt;
. 启动你的程序，可以带任何影响其功能(或称行为)的参数。&lt;br /&gt;
. 能够使你的程序在指定条件下在指定的地方(断点)停止运行。&lt;br /&gt;
. 当你的程序在断点处停止时，你可以查看已执行的结果(如变量的值，函数之间的调用情况，执行到那一行代码，下一步该执行哪行代码)&lt;br /&gt;
. 改变你的程序中，你可以实验这种改变所带来的影响(如bug消除了，或者情况变得更糟糕)&lt;/p&gt;

&lt;p&gt;使用gdb，你可以调试C，C++，以及Modula-2语言编写的程序。&lt;/p&gt;

&lt;p&gt;四、段错误(Segmental fault)介绍
在用C/C++语言写程序的时侯，内存管理的绝大部分工作都是需要我们来做的。实际上，内存管理是一个比较繁琐的工作，所以像java和c#等语言采用了内存自动回收机制，避免了内存泄漏。如果程序试图往内存地址0处写东西时，内核就会向其发送段错误信号，如果程序没有捕获该信号，默认的操作时内核终止该程序的运行，例如我写的一个myls程序就遭遇了这种情况：
luck@geekard:~/codes/12.21$ ./myls -ld .
longlist 1, typelist 0, dirlist 1, filename .
Segmentation fault
luck@geekard:~/codes/12.21$&lt;/p&gt;

&lt;p&gt;常见的段错误原因如下：
1）往受到系统保护的内存地址写数据有些内存是内核占用的或者是其他程序正在使用，为了保证系统正常工作，所以会受到系统的保护，而不能任意访问
.2）内存越界(数组越界，变量类型不一致等)
下面我以上面的myls程序出现的错误为例介绍用gdb进行调试的方法和过程。&lt;/p&gt;

&lt;p&gt;五、gdb调试入门&lt;/p&gt;

&lt;p&gt;5.1 调试前的准备
我们首先要启动linux内核提供核心转储(core dump)机制：当程序中出现内存操作错误时，会发生崩溃并产生核心文件（core文件）。使用GDB可以对产生的核心文件进行分析，找出程序是在什么时候崩溃的和在崩溃之前程序都做了些什么。
首先，你的Segmentation Fault错误必须要能重现（废话…）。
然后，依参照下面的步骤来操作：
1）无论你是用Makefile来编译，还是直接在命令行手工输入命令来编译，都应该加上 -g 选项。如：
luck@geekard:~/codes/12.21$ ls
myls-0.0.c  myls-1.0.c  myls-2.0.c
luck@geekard:~/codes/12.21$ gcc -g -o myls myls-0.0.c
luck@geekard:~/codes/12.21$ ls
myls  myls-0.0.c  myls-1.0.c  myls-2.0.c
加了-g选项后，gcc就会在生成的可执行文件(这里-o myls表示输出(output)的可执行文件名时myls)里添加一些调试符号(debugging symbols)，有了这些调试符号后就可以在稍后用gdb调试时列出执行的程序的C源代码了。-g选项增大了文件体积，一般只是在刚开发出的程序调试时使用，当确定无误编译出实际使用的可执行文件时就不需要-g选项了。
2）一般来说，在默认情况下，在程序崩溃时，core文件是不生成的（很多Linux发行版在默认时禁止生成核心文件）。所以，你必须修改这个默认选项，在命令行执行：
ulimit -c unlimited     //unlimited 表示不限制生成的core文件的大小。
3）运行你的程序，不管用什么方法，使之重现Segmentation Fault错误。
luck@geekard:~/codes/12.21$ ./myls -ld .
longlist 1, typelist 0, dirlist 1, filename .
Segmentation fault (core dumped)
4）这时，你会发现在你程序同一目录下，生成了一个文件名为 core的文件，即核心文件。
luck@geekard:~/codes/12.21$ ls
core  myls  myls-0.0.c  myls-1.0.c  myls-2.0.cluck@geekard:~/codes/12.21$
5）用GDB调试它,在命令行执行：
luck@geekard:~/codes/12.21$ gdb ./myls   或者先启动gdb然后在gdb命令提示符中输入这两个文件：&lt;/p&gt;

&lt;p&gt;luck@geekard:~/codes/12.21$ gdb  //不带参数启动gdb调试程序
GNU gdb (GDB) 7.2-ubuntu
Copyright &amp;copy; 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;a href=&#34;http://gnu.org/licenses/gpl.html&#34;&gt;http://gnu.org/licenses/gpl.html&lt;/a&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;ldquo;show copying&amp;rdquo;
and &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i686-linux-gnu&amp;rdquo;.
For bug reporting instructions, please see:
&lt;a href=&#34;http://www.gnu.org/software/gdb/bugs/&#34;&gt;http://www.gnu.org/software/gdb/bugs/&lt;/a&gt;.
(gdb) file ./myls                    //输入file命令和你的可执行文件名和路径，这里为当前目录下的myls文件
Reading symbols from /home/luck/codes/12.21/myls&amp;hellip;done.
(gdb) run -ld ./                       //带参数(这里为 -ld ./)运行r(run)程序，这和在bash命令行上执行：./myls -ld ./效果时一致的。
Starting program: /home/luck/codes/12.21/myls -ld ./
longlist 1, typelist 0, dirlist 1, filename ./            //myls程序的输出&lt;/p&gt;

&lt;p&gt;Program received signal SIGSEGV, Segmentation fault.       //出错后退出
0x0016e78f in vfprintf () from /lib/libc.so.6
(gdb)
从这里我们还发现进程是由于收到了SIGSEGV信号而结束的。通过进一步的查阅文档(man 7 signal)，我们知道SIGSEGV默认handler的动作是打印”段错误&amp;rdquo;的出错信息，并产生Core文件。
查看一下我的当前目录，果然有core文件。&lt;/p&gt;

&lt;p&gt;luck@geekard:~/codes/12.21$ ls
core  myls  myls-0.0.c  myls-1.0.c  myls-2.0.c&lt;/p&gt;

&lt;p&gt;下面我们就用刚才生成的分段错误产生的核心转储文件（core）再次调试程序。接着上一步的(gdb) 提示符，输入以下命令：&lt;/p&gt;

&lt;p&gt;(gdb) core core       //输入core命令和分段错误产生的核心转储文件，这里为当前目录下的core文件
A program is being debugged already.  Kill it? (y or n) y   //按y，重新调试
[New Thread 24884]
warning: Can&amp;rsquo;t read pathname for load map: Input/output error.
Reading symbols from /lib/libc.so.6&amp;hellip;(no debugging symbols found)&amp;hellip;done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2&amp;hellip;(no debugging symbols found)&amp;hellip;done.
Loaded symbols for /lib/ld-linux.so.2&lt;/p&gt;

&lt;p&gt;Core was generated by `./myls -ld .&amp;lsquo;.              //core文件记录了发生错误的程序执行的命令行参数
Program terminated with signal 11, Segmentation fault.
#0  0x002bb78f in vfprintf () from /lib/libc.so.6  //core文件记录了发生错误时程序的退出状态
(gdb)&lt;/p&gt;

&lt;p&gt;从标号为0的行我们并不能看出程序到底在哪出错,所以下一步需要确定发生错误前程序中函数之间的调用关系
(gdb) backtrace    //显示程序的堆栈信息
#0  0x0014f78f in vfprintf () from /lib/libc.so.6
#1  0x0016f4dc in vsprintf () from /lib/libc.so.6
#2  0x00157b4b in sprintf () from /lib/libc.so.6
#3  0x08048c56 in finalprt (file=0x8a9b02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:261
#4  0x080487c3 in detailList (file=0xbfab684d &amp;ldquo;.&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:132
#5  0x08048712 in main (argc=3, argv=0xbfab4804) at myls-0.0.c:89
(gdb)&lt;/p&gt;

&lt;p&gt;可以看出myls程序的函数调用关系为：
main() &amp;mdash;&amp;gt; detailList() &amp;mdash;&amp;gt; finalprt
然后在标号为0-2的行进入了系统的C库函数，所以产生错误的可能在标号3、4、5指明的函数中。
我们先看一下最后调用finalprt()函数时可能发生错误的代码行：&lt;/p&gt;

&lt;p&gt;(gdb) frame 3    //上面以#开头的行称为帧(frame)，这里指定查看第3帧
#3  0x08048c56 in finalprt (file=0x8a9b02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:261
261                    sprintf(str, &amp;ldquo;%c%d    %d,%d  %d  %d  %s&amp;rdquo;, filetype, permission, uid, gid, size, mdate, file);&lt;/p&gt;

&lt;p&gt;可以看到在调用sprintf()函数时可能发生了分段错误(由非法引用内存引起)，而sprintf()的原型为： int sprintf(char *str, const char *format, &amp;hellip;);
最有可能引起错误的地方是其第一个参数：char *str,一个指向字符串数组的指针，我们先把疑点放在这，接下来看一下函数之间相互调用时传递的参数值和函数的内部变量值：
(gdb) backtrace  full  //full参数表示完全显示函数之间相互调用时传递的参数值和函数的内部变量值
#0  0x0014f78f in vfprintf () from /lib/libc.so.6
No symbol table info available.
#1  0x0016f4dc in vsprintf () from /lib/libc.so.6
No symbol table info available.
#2  0x00157b4b in sprintf () from /lib/libc.so.6
No symbol table info available.
#3  0x08048c56 in finalprt (file=0x8a9b02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:261
        str = 0x4d11faec &lt;Address 0x4d11faec out of bounds&gt;
        flag = 65
#4  0x080487c3 in detailList (file=0xbfab684d &amp;ldquo;.&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:132
        ptr = 0x8048e44 &amp;ldquo;longlist %d, typelist %d, dirlist %d, filename %s\n&amp;rdquo;
        dirp = 0x8a9b008
        direntp = 0x8a9b020
#5  0x08048712 in main (argc=3, argv=0xbfab4804) at myls-0.0.c:89
        file = 0xbfab684d &amp;ldquo;.&amp;rdquo;
        ptr = 0x8048d30 &amp;ldquo;U\211\345WVS\350O&amp;rdquo;
        i = 3
        j = 3
        longlist = 1
        dirlist = 1
        typelist = 0
请注意序号3中的内部变量str的值 &lt;Address 0x4d11faec out of bounds&gt;，这表示发生了数组越界，难怪发生了段错误！
现在我们找到原因了：finalprt()中的第261行调用函数sprintf()时向其传递的第一个参数str发生里越界存取，于是内核终止程序的运行。&lt;/p&gt;

&lt;p&gt;下面我们要验证这个判断：在261处设置一个断点，程序运行到断点后单步执行，观察是否会发生错误。&lt;/p&gt;

&lt;p&gt;(gdb) stop                    //停止当前调试
(gdb) break 261              //在第261行设置一个断点
Breakpoint 1 at 0x8048bf1: file myls-0.0.c, line 261.
(gdb) run  -ld ./           //带参数运行程序(myls)
The program being debugged has been started already.
Start it from the beginning? (y or n) y   //当然yes&lt;/p&gt;

&lt;p&gt;Starting program: /home/luck/codes/12.21/myls -ld ./
longlist 1, typelist 0, dirlist 1, filename ./&lt;/p&gt;

&lt;p&gt;Breakpoint 1, finalprt (file=0x804c02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0, longlist=1)   //可以看到程序在第261行停止
    at myls-0.0.c:261
261                    sprintf(str, &amp;ldquo;%c%d    %d,%d  %d  %d  %s&amp;rdquo;, filetype, permission, uid, gid, size, mdate, file);&lt;/p&gt;

&lt;p&gt;(gdb) where                                //显示目前函数之间的调用情况与breaktrace命令功能相似
#0  finalprt (file=0x804c02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0, longlist=1)
    at myls-0.0.c:261
#1  0x080487c3 in detailList (file=0xbffff830 &amp;ldquo;./&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:132
#2  0x08048712 in main (argc=3, argv=0xbffff6e4) at myls-0.0.c:89
(gdb) printf &amp;ldquo;%d\n&amp;rdquo;,filetype             //打印处函数中的变量filetype的值
100
(gdb) list                                //列出断点处前后的相关代码
256    //            if(filetype == &amp;rsquo;d&amp;rsquo;)
257                    sprintf(str, &amp;ldquo;%s\n&amp;rdquo;, file);
258                break;
259            case 0101:
260    //            if(filetype == &amp;rsquo;d&amp;rsquo;)
261                    sprintf(str, &amp;ldquo;%c%d    %d,%d  %d  %d  %s&amp;rdquo;, filetype, permission, uid, gid, size, mdate, file);
262                break;
263            case 0110:
264    //            if(filetype == &amp;rsquo;d&amp;rsquo;)
265                    sprintf(str, &amp;ldquo;%s%c&amp;rdquo;, file, filetype);
(gdb) n                      //然后单步执行代码,立即发生了错误&lt;/p&gt;

&lt;p&gt;Program received signal SIGSEGV, Segmentation fault.
0x0016e78f in vfprintf () from /lib/libc.so.6&lt;/p&gt;

&lt;p&gt;可见在线调试验证了我们的假设，的确时261行的sprintf语句有问题,下面我们看一下261所在的函数finalprt()中变量str的类型
(gdb) list finalprt    //列出函数finalprt()入口附近的源代码
225        *mdate_s = fstat.st_mtime;
226        return 0;
227    }
228&lt;br /&gt;
229    /&lt;em&gt;this function prints all the information&lt;/em&gt;/
230    static char *finalprt(char *file, int dirlist, int typelist, int longlist){
231&lt;br /&gt;
232        char *str;
233        int flag = 0000;
234&lt;br /&gt;
(gdb)
注意第232行的变量定义:str被错误的定义个指向char的指针，而sprintf()的第一个参数要求为一字符型数组的首地址,所以sprintf()调用时会发生内存越界的错误。&lt;/p&gt;

&lt;p&gt;接着考虑下去，以前用windows系统下的ie的时侯，有时打开某些网页，会出现“运行时错误”，这个时侯如果恰好你的机器上又装有windows的编译器的话，他会弹出来一个对话框，问你是否进行调试，如果你选择是，编译器将被打开，并进入调试状态，开始调试。
Linux下如何做到这些呢？
我们可以在要调试的程序中定义一个分段错误信号(SIGSEGV)的处理函数(handler),在该函数中中调用gdb，这样当段错误发生时程序就会自动启动gdb进行调试，一个简单的示例代码如下:&lt;/p&gt;

&lt;p&gt;/**
*段错误时启动调试
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;&lt;/p&gt;

&lt;p&gt;void
dump(int signo){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char buf[1024];
    char cmd[1024];
    FILE *fh;

    snprintf(buf, sizeof(buf), &amp;quot;/proc/%d/cmdline&amp;quot;, getpid());  //取得进程的命令行文件地址
    if(!(fh = fopen(buf, &amp;quot;r&amp;quot;)))    //打开该文件
            exit(0);
    if(!fgets(buf, sizeof(buf), fh)) //将其内容读到buf数组中
            exit(0);
    fclose(fh);
    if(buf[strlen(buf) - 1] == &#39;\n&#39;) //删除独到的字符串中最后的还行符并保证字符串以空字符结尾
            buf[strlen(buf) - 1] = &#39;\0&#39;;
    snprintf(cmd, sizeof(cmd), &amp;quot;gdb %s %d&amp;quot;, buf, getpid());  //合并命令行参数
    system(cmd);               //执行cmd字符窜 代表的命令

    exit(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;void
dummy_function (void){       //测试函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    unsigned char *ptr = 0x00;
    *ptr = 0x00;        //向内存中0x00地址写数据，产生段错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;int
main (void)
{
        signal(SIGSEGV, &amp;amp;dump);  //捕获信号SIGSEGV，当接收到内核发送的SIGSEGV信号时调用处理函数dump()
        dummy_function ();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
编译运行效果如下:
luck@geekard test $ gcc -g -rdynamic f.c
luck@geekard test $ ./a.out
GNU gdb 6.5
Copyright &amp;copy; 2006 Free Software Foundation, Inc.
。。。。省略。。。。
0xffffe410 in __kernel_vsyscall ()
(gdb) bt
#0  0xffffe410 in __kernel_vsyscall ()
#1  0xb7ee4b53 in waitpid () from /lib/libc.so.6
#2  0xb7e925c9 in strtold_l () from /lib/libc.so.6
#3  0x08048830 in dump (signo=11) at f.c:22&lt;br /&gt;
#4  &lt;signal handler called&gt;
#5  0x0804884c in dummy_function () at f.c:31
#6  0x08048886 in main () at f.c:38
第3个frame指示发生错误的行为f.c中的22行，即为*ptr = 0x00;行。&lt;/p&gt;

&lt;p&gt;好了，以上就是这篇笔记的主要内容，下面总结一下gdb的主要命令：&lt;/p&gt;

&lt;p&gt;ulimit -c unlimited                                                //打开内核的核心转储机制
gcc -g -o outPutName sourceCodeName.c  //编译时加-g选项，使生成的可执行文件中包含调试信息
gdb outPutName core                                       //启动gdb，可以咋命令行上指定要调试程序
or:  gdb  file  outPutName                                //也可以在gdb命令提示符中输入要调试的程序名&lt;br /&gt;
core  core                                                           //指定程序执行错误时内核生成的转储文件
list  [function]|[row-number]                            //查看源代码，可以跟函数名或行号
break [function]|[row-number]                        //设置断点，可以跟函数名或行号
clear [function]|[row-number]                         //清除断点，可以跟函数名或行号或断点号
r     [paramiters]                                                /&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://sun-friderick.github.io/about</link>
      <pubDate>Fri, 20 Nov 2015 15:33:51 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/about</guid>
      <description>

&lt;h2 id=&#34;关于我:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;关于我&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2007  JC@QUST&lt;/li&gt;
&lt;li&gt;2010  TE@Haier&lt;/li&gt;
&lt;li&gt;2010  BSc@SDIBT&lt;/li&gt;
&lt;li&gt;2012  PG, SE, PL@Hybroad, GD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;蜗居北京，85后，a Man。&lt;/p&gt;

&lt;p&gt;本科的时候开始写微博，只是记录一下自己的学习生活和关注爱好。慢慢发现，学习的内容有点太少，知识面也有点窄，就开始逛论坛、写博客。最近感觉还是折腾一个属于自己的地盘，记录一些学习笔记、自己的想法和生活感悟什么的，以便于督促自己。平时喜欢关注UI设计、流媒体、音视频编解码、搜索引擎，图像识别等，由于涉猎的技术较杂，会有“广而不精”之嫌，欢迎光顾我的技术博客（左下角的侧边栏）讨论技术性问题。&lt;/p&gt;

&lt;p&gt;E-mail: mrsun.echo@gmail.com;  echo_eric@yeah.net&lt;/p&gt;

&lt;p&gt;QQ: 707544953&lt;/p&gt;

&lt;h2 id=&#34;喜欢:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;喜欢：&lt;/h2&gt;

&lt;p&gt;运动（羽毛球、网球、骑行（虽然不专业，也算个爱好吧））；&lt;br /&gt;
吃喝（老灶火锅、麻辣烫（深受女友影响）、天降披萨、桂花糯米藕、各种面点），跟女友一起做饭，另外超喜欢女友做的排骨汤和汤饭；漫画（老夫子、敖幼祥的乌龙院、宫崎骏系列漫画、朱德庸和蔡志忠经典漫画等）；&lt;br /&gt;
小说（喜欢写实、游记、自传等等经典，像：《百年孤独》 、《老人与海》、《鲁滨逊漂流记》、《格列佛游记》、《了不起的盖茨比》、《麦田里的守望者》、《基督山伯爵》、《汤姆·索亚历险记》 等，再有能拓展人的思维的科幻、科普等，像：《海底两万里》、《从一到无穷大》、《数字化生存》、《万物简史》、还有最经典的《魔戒》三部曲）；&lt;br /&gt;
影视（在imdb、豆瓣排名靠前的都喜欢看，最喜欢的类型还是：科幻片、战争片、动作片、动画片（宫崎骏系列）、偶尔喜剧片）；&lt;br /&gt;
音乐（80-90年代的经典老歌，像写出陈奕迅《十年》的林夕、写出刘德华《一起走过的日子》和BEYOND《真的爱你》的梁小美、写出谭咏麟《朋友》的向雪怀，写出张学友《饿狼传说》的潘伟源、写出王菲《冷战》的黄伟文等等个人都比较喜欢，还有写出电影《笑傲江湖》主题曲《沧海一声笑》、电影《黄飞鸿》主题曲《男儿当自强》、电影《倩女幽魂》插曲《倩女幽魂》《人间道》、电影《英雄本色》主题曲《当年情》、电影《上海滩》主题曲《上海滩》、电影《射雕英雄传》的主题曲《一生有意义》、周星驰的喜剧片《苏乞儿》主题歌《长路漫漫伴我闯》、电视剧《狮子山下》主题歌《狮子山下》的一代香江性情大师————黄沾）；&lt;br /&gt;
四季里最喜欢冬天，没有什么特别的原因，秋太过于伤感，夏太过于热情，而春天却太过于温和，冬再好不过了，介于四者之间，可以使人冷静，使人回味；小有收藏癖（集邮，集硬币，收藏各种搜集到的、有意义的、有古典气息的、精致的小东西）；&lt;br /&gt;
闲来两人骑骑自行车、看看电影、逛逛街、偶尔到北京周边走走看看，再有就是陪练我们家小七&lt;/p&gt;

&lt;h2 id=&#34;不喜欢:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;不喜欢：&lt;/h2&gt;

&lt;p&gt;不喜欢过分张扬；喜欢孤独的感觉但不喜欢孤单；轻微素食主义者不喜过分依赖肉食；不喜过分敏感勾心斗角；&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>经过省察的人生The examined life</title>
      <link>http://sun-friderick.github.io/post/2015-03-03-1</link>
      <pubDate>Tue, 03 Mar 2015 00:00:00 UTC</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-03-03-1</guid>
      <description>

&lt;p&gt;译自&lt;a href=&#34;http://books.google.lt/books?id=WwpZVuylPgYC&amp;amp;pg=PA228&amp;amp;hl=zh-CN&amp;amp;source=gbs_toc_r&amp;amp;cad=3#v=onepage&amp;amp;q&amp;amp;f=false&#34;&gt;《A companion to Socrates》第14章&lt;/a&gt;，作者Richard Kraut&lt;/p&gt;

&lt;h1 id=&#34;经过省察的人生:f856045648ed1256c7d09f14d1393f16&#34;&gt;经过省察的人生&lt;/h1&gt;

&lt;p&gt;“未经省察过的人生是不值得过的人生”（《申辩》38a5-6）。这句苏格拉底耳熟能详的名言，也许是有史以来一个哲学家嘴中最肆无忌惮的话。苏格拉底的哲学思想和他的生活方式的本质也蕴含在这句话中。苏格拉底把自己的人生作为——或者更确切地说，柏拉图把他的人生作为——真正经过了省察的人生。要了解我们如何才能达到这种人生的要求，必须从柏拉图的作品出发，来好好学习苏格拉底给我们树立起来的好榜样。这种人生的要求或许能激励我们或许不能使我们信服，因为准确地说，这是苏格拉底对他同时代人产生的影响。苏格拉底的魅力和崇高的理想可能会被削弱。因为他说过，未经省察过的人生正是许多人的生活方式，是只有当我们有强烈倾向时才做出的选择。同时，如果遵循苏格拉底的坚持，所有人都按他的方式生活，这种人生的要求则会显得荒诞不经，甚至可以说是异乎寻常的苛刻。在任何社会中，最多只有几个人可以像苏格拉底那样，把所有的日子都用来讨论道德伦理。所有其他的人都过着毫无价值的生活吗？苏格拉底有什么好的理由来批评绝大多数人类的行为生活吗？如果只有少数人像苏格拉底那样奉献自己，他对同时代人的生活几乎没有影响，那么在更一般的情况下，经过省察的人生又有什么价值？对于这个问题，确切得说，应该是对于一个能选择这样生活的人来说，经过省察的人生到底有什么好的？即使我们都可以掌控这种生活，我们又为什么要做出尝试呢？&lt;/p&gt;

&lt;p&gt;如果还有道德哲学家的话，在当今的学术界恐怕也没谁赞同苏格拉底的名言。他们会说，我们被要求不用过分的方式（谋杀，袭击，盗窃）去伤害他人；我们要在一定程度上（这个程度多少也是一个争议的话题）至少造福一些其他人；我们要诚实，公正，善良，宽容；我们应该做的事，在道德意义上必须是正确的，因为道德本身就是正确的，而不是为达到某种非道德目的的方式。他们会说，那种苏格拉底与他的跟随者们从事的伦理讨论是值得追求的（毕竟这和这些哲学家的生活有点像）；但他们会补充说，没有必要甚至也不希望每个人都从事那种让苏格拉底着迷的抽象伦理探究。当然，他们还会说，这不是判断一个好人的人生是否经受住了审察的必要特点。在他们认为，成为一个好人明显到任何拥有常识的人都能看出来：在幼时拥有良好的教导，能分辨道德意义上的对错，并且坚持做对的事。人们需要变得善于使用这样的词语如“应该”，“正确”，“善”，“正义”，“诚实”。但要做到这一点，我们需要的不是像苏格拉底认为的那样，进入抽象和困难的道德哲学领域的，询问自己和他人诸如这样的问题：“什么是勇气？”，“ 什么是正义？”，“什么成为朋友？“相反，我们需要的是获得社会和情感技能，使我们认识到什么在道德意义上是对的，并且带着良心去做道德意义上对的事。苏格拉底根据这种思维方式，简单误以为成为一个好人，全部或部分地包括了成为一个好的道德哲学家。&lt;/p&gt;

&lt;p&gt;然而，并非所有人都同意，苏格拉底对经过省察的人生的呼吁可以这样容易就被否定掉。在现代很大一部分时期中，他对经过省察的人生的呼吁为他赢得了一个接近基督和其他宗教领袖的地位，被视为人类历史上一个伟大的道德模范。本杰明·乔伊特（ Benjamin Jowett），十九世纪后期一个柏拉图作品的重要译者，告诉他的学生：“在牛津大学，基督和苏格拉底的人物传记是我们最浓厚的兴趣所在（虽然程度不一）。”1这样的比较在二十世纪也有，苏格拉底被一位存在主义作家卡尔·雅斯贝尔斯（ Karl Jaspers，1962）视为一个“个人模范”（继佛陀，孔子，基督之后）。但在二十一世纪的最初几年，道德哲学的学术界并没有苦苦抓住苏格拉底不放，而更像是避开了他（因为还有亚里士多德，休谟，康德，尼采， 西奇威克）。&lt;/p&gt;

&lt;p&gt;苏格拉关于未经省察过的人生不值得过的人生的理论，我想既不能被接受也不能被拒绝。刚刚也描绘了若被拒绝的情况。&lt;strong&gt;在下文中，我将解释这样的人生有什么意义以及为什么苏格拉底认为我们必须这样做。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;柏拉图的-申辩:f856045648ed1256c7d09f14d1393f16&#34;&gt;柏拉图的《申辩》&lt;/h1&gt;

&lt;p&gt;展开这种探讨时苏格拉底本人在场——或者更确切地说，在柏拉图的《申辩》中，苏格拉底被描述成为我们在演讲，说出了这句“未经省察过的人生是不值得过的人生。”苏格拉底这句话时，陪审团已经判他有罪，而且将决​​定实施什么样的刑法。Meletus是其中一个控告者，提出将他判处死刑，在这时提出另一种惩罚是苏格拉底的权利。他问：他应当被请求流放到其他的城市，并且放弃他实践哲学的方式吗？他的回答是他不愿放弃哲学，因为这违背了他的神的意愿。然后他补充说：“如果我说，一个人最大的好处是每天都在讨论德性和其他你们听我同别人交谈和省察的东西，未经省察过的人生不值得过的人生，你会更容易被我的话说服的。“（38a1-6）。苏格拉底提出了把罚款作为处罚，但陪审团决定他应该被处死。&lt;/p&gt;

&lt;p&gt;但是，为什么要每个人都要过一种省察过的人生呢？&lt;strong&gt;苏格拉底没有试图在这里回答这个问题，在任何辩护的其他地方也没有。&lt;/strong&gt; 他把经过省察的人生与进一步讨论德性就是好的联系起来，但是，这在柏拉图的《申辩》中同样没有做出解释。对于苏格拉底对这些说法没有给出论据，我们不应该感到惊讶。毕竟，他没有在做一个关于哲学的演讲，而是在针对指控为自己辩护，表明他的生活方式存在好的动机且没有不良影响。他的听众并不关心否可以证明是最好的生活是经过省察的生活；而想知道怎样对待持这种想法的人。&lt;/p&gt;

&lt;p&gt;假设我们假定智慧是一个人可以拥有的最好的东西。并且假定我们接受苏格拉底比其他所有的人都更能通过伦理讨论来接近智慧。这些前提将会确保苏格拉底式的诘问法也有很大的价值的结论，但将其作为结论则会受到挑战。我们为什么要认为智慧是最好的东西呢？并且为什么要假设这种德性是凭借或部分凭借苏格拉底进行的那种抽象的道德探究组成的呢？似乎这样说也合情合理，尽管有许多不同形式的智慧，但通过诡辩习得复杂的道德哲学也许是其中之一，可以假定它比所有其他形式的智慧更加有价值。苏格拉底式的诘问法可以提高个人的哲学技能——但能说它使人变得更好了吗？它提高了人做好事的能力吗？柏拉图的《申辩》不 能回答这些问题，并没有打算回答。&lt;/p&gt;

&lt;h1 id=&#34;不值得过的人生:f856045648ed1256c7d09f14d1393f16&#34;&gt;不值得过的人生&lt;/h1&gt;

&lt;p&gt;因此，我们将不得不转向柏拉图的其他作品，来找到对苏格拉底所这句“未经省察过的人生是不值得过的人生的更好诠释”。但在我们抛开《申辩》之前，我们应该先停下来想一想，以确保我们真正懂得苏格拉底的这句话是什么意思。&lt;/p&gt;

&lt;p&gt;其中的这个词——anexetastos（“unexamined未经省察的”）——的构成没有什么问题。Exetazein的意思是 “ 检查，探究，审察，测试，证明”。它和它的同源词 ，exetasis，经常被苏格拉底用来描述当在他与他人的谈话时在做的事。用同源形容词anexetastos形容的人生， 是一个没有受到苏格拉底式伦理道德省察的人生。&lt;/p&gt;

&lt;p&gt;但其他苏格拉底这句话中的另一个词——biotos ——需要仔细理解。译成短语“值得过的，”从乔伊特（Jowett）起一直是一种标准翻译。当我们说某人的人生在某时是不值得过的，我们的意思应该是他没有比死更好的活法。在理想的情况下，人生不值得过的时候正好是死亡来临的时候。同样，如果一个人的人生从来没有在任何时候值得一过，那么任何时候在他的人生里，死都是好的。&lt;/p&gt;

&lt;p&gt;如果我们理解苏格拉底的意思是应把所有的未经省察的人生都归入这个类别，那么我们则默认他对城邦的公民采取了其恶劣的态度。如果苏格拉底把他们从危难之中拯救出来（他在战场上杀敌），他则会认为这对他们没有什么好处。人们便会存有疑惑：为什么他认为他要为救他们动一根手指头？&lt;/p&gt;

&lt;p&gt;是不值得过的人生不单单是坏人生：这种人生太缺少价值以至于对一个人来说去死反而是最好的选择。我们没有理由将未经省察的人生里深深的痛苦归于苏格拉底的观点。因为 biotos 并不一定意味着“值得过的”，也可译为“应该过的”。这样，苏格拉底的这句话应该理解为：“未经省察的人生不是应该过的人生。”这并不意味着人生应该被终止，相反，它可以被理解为人们不应该过那样的人生。如果一个人的人生是那样，那他必须做出改变——不是死亡会更好，而是可能有一个更好的人生。&lt;/p&gt;

&lt;p&gt;这是苏格拉底的使命，去说服城邦的其他公民未经省察过的人生错过了最好的东西，因此他们必须改变他们的人生。苏格拉底的使命里没有哪部分是在说服他们人生不值得过最好去死。（试图证明这一点的意义又是什么呢？）因此，我建议我们放弃这个标准翻译，采用柏拉图希腊文版《申辩》38a5-6 的意思：“人们不应该过未经省察的人生。”我们不用害怕，以这种方式解释苏格拉底，才能把他的哲学思想变成一条不温不火的建议。每个人应该进行苏格拉底式探寻的观点是哲学家做出的最大胆的宣称之一。一旦一个人对这种观点笃信不疑，讨论对于过着这样人生的人是否去死更好，既没有哲学意义也没有现实意义。&lt;/p&gt;

&lt;p&gt;另外，关于苏格拉底说这话的含义，还有一点要强调：他认为探究伦理道德是一个过程，一个人应该因此花掉一生的时间，而不仅仅只是暂时的。一个人要达到他的要求，则要花了大半年去询问他问过的问题，然后转向其他事情，并不再关切这类问题。对于经过省察的人生的呼吁，和一下观点也有联系：一个人最大的好处是“每天都讨论德行”等伦理问题（《申辩》38a3）。 我们应该认识到这是多么大胆的话。我们只有期待苏格拉底可以给我们足够的理由来接受它。&lt;/p&gt;

&lt;h1 id=&#34;苏格拉底对话:f856045648ed1256c7d09f14d1393f16&#34;&gt;苏格拉底对话&lt;/h1&gt;

&lt;p&gt;我们从哪里能找到他的论据呢？几乎所有的柏拉图对话集中都有一个对话者——通常他占有主导地位——他就是苏格拉底。但也有学者认为，这些对话的某些内容里，这些谈话给了我们一个名叫“苏格拉底”的历史人物大概的形象；而在另一些国家，“苏格拉底”却成为了柏拉图哲学的代言人，他的哲学虽然在历史上受苏格拉底极大影响，但也有显著不同.2 这正是在这篇文章中应遵循的方法。&amp;rdquo;人们不应该过未经省察的人生这种观点是很可能是苏格拉底哲学的核心，但它却不是柏拉图本人赞同的——或者可以说他在哲学生涯中只是之中都没有赞同过。为了说明这一点，我们只需要举出《理想国》中所描述的个等级的划分：哲学家，士兵和工人。只有哲学家可以说过上经过省察的人生：他们是那些专门被培训成提出和回答各种各样的苏格拉底式问题的人。与此相反，士兵和工人，过了不假思索的人生，只是接受法律和统治者的决定。统治者不同于任何其他人，他的工作是对实际问题有智慧。因此，《理想国》中的苏格拉底拒绝了这种观点，即每个人都可以过上经过考察的人生。&lt;/p&gt;

&lt;p&gt;关于《申辩》和《理想国》中的冲突应当作何解释呢？&lt;strong&gt;一个令人难以置信的假设是，这里的差异实际上反映了柏拉图自己思想的转变。&lt;/strong&gt; 其实我个人比较相信这个假设。根据这种解释，柏拉图让苏格拉底在《申辩》中说一个人应该过经过省察的人生这样的话，实际上他是将自己的哲学思想放进了苏格拉底的演讲中。但是，这样来看待苏格拉底和柏拉图的关系不是一种可信的方式。我们没有理由怀疑，历史上的苏格拉底的确与许多和他同时代的人一起讨论德性，而他这样做引起了很大的敌意，但他却还是坚持认为这种探寻有很大的价值。无论是历史上的苏格拉底是否逐字逐句地依照我们今天读到的希腊文本谈论了关于未经省察的人生，这都不重要。不能轻易否认，经过省察的巨大人生价值是对历史上的苏格拉底的生平和思想的中心的假定。正如我们看到的那样，这种主导观念被《理想国》的主要对话者修正了。我认为，这种差异最合理的解释是柏拉图表达了他老师的中心思想，于是得出的结论是苏格拉底没有意识到其中的局限性。柏拉图说，是啊，经过省察的人生的确是人类能过上的最好的人生；但大家都去尝试便不是什么好事了。让小部分人过上那样的人生，去引导其他的人。&lt;/p&gt;

&lt;p&gt;我们认识到，柏拉图受到了苏格拉底的启发，但却超越他。在研究柏拉图对话时，要把他俩区别开来：第一，围绕主题的对话内容使用的可能是历史上苏格拉底的真实想法；第二，那些有更占主导地位的更充分的思想，有可能是柏拉图做出修改甚至不同于苏格拉底的。毫无疑问柏拉图以某种方式在所有作品里注入了他自己的思想；不可能一个哲学家的才华和独创性不被放入对别人语录的被动记载中。即便如此，基于其他的互相不同类型和不同之处，把其中的组成进行分类，也是有帮助的。&lt;strong&gt;其中那些被称为“苏格拉底式”的内容比较少，几乎完全是以道德、探索为中心，结构上也比较简单。&lt;/strong&gt; 这些内容主要关于对坏想法的抨击或证明对话者的局限；其中也包含积极的想法，但不多，也从没有与形而上学和认识论的整合到一起。这样的描述发生在苏格拉底与Laches, Charmides, Euthyphro, Crito, Protagoras, Hippias Minor, Hippias Major, Lysis 以及 Gorgias的对话中。在这些对话中，柏拉图的思想或多或少都在他老师搭建的范围内展开。正如柏拉图在《申辩》中提到的那样，苏格拉底不关心任何除了提高人生以外的话题。至少在成年后，&lt;strong&gt;苏格拉底是一个道德哲学家，不是一个形而上学者、不是一个认识论者，更不是科学家。&lt;/strong&gt; 亚里士多德也证实了这一假定：他说，苏格拉底只关注道德，不研究自然世界。（《形而上学》 I.6 987b1-2）&lt;/p&gt;

&lt;p&gt;许多其他对话都有一个相当不同的角色。这些对话篇幅更长，他们提出或审查的观点会经过更充分地阐述，涉及到的道德内容是与形而上学和认识论交织在一起的。 斐多篇“，”克拉底鲁篇“，理想国，菲德洛斯，巴门尼德，泰阿泰德篇，智者，政治家，和蒂迈欧篇” 都是如此 。对柏拉图的作品划分类别，不是说每篇作品都只属于一个类别。诸如美诺、尤西弗伦这样的作品既包括了苏格拉底式的对话特点，也有第二类作品的特点。&lt;/p&gt;

&lt;p&gt;大多数的苏格拉底式对话是柏拉图早期作品，那时苏格拉底的影响力是最强的；但也有可能他在同一时期也在创作冗长的涉及形而上学、认识论和道德的作品。他意识到对于他复杂的作品来说，苏格拉底式对话是为读者准备的一个绝好的铺垫。这可以解释为什么像Lysis 和 Charmides中，含有更长和更复杂的对话里的暗示。&lt;/p&gt;

&lt;p&gt;现在回到我们的主题上来。&lt;strong&gt;这句“人们不应该过未经省察的人生”属于历史上的苏格拉底，但不属于柏拉图笔下的苏格拉底。&lt;/strong&gt; 我们想知道苏格拉底到底对这个观点给出了什么论据，当然《申辩》中论据没有给出。那从哪里看起呢？最好就是从我们现在看的苏格拉底式对话出发，因为在这些内容中，柏拉图的哲思更贴近苏格拉底的特征，即与其他的哲学话题相比，伦理问题占有主导地位。&lt;/p&gt;

&lt;p&gt;我们将看到，这样来做是值得的：通过这些对话，能更加深入理解苏格拉底对于最重要的道德伦理的讨论所给出的理由。这些苏格拉底式的作品能够读出来，若是没有用足够的耐心和智慧来省察人生，究竟会出什么错。&lt;/p&gt;

&lt;h1 id=&#34;关于未经省察的人生的调查:f856045648ed1256c7d09f14d1393f16&#34;&gt;关于未经省察的人生的调查&lt;/h1&gt;

&lt;p&gt;尤西弗罗认为 自己是对于宗教事务的专家。在以他的名字命名的对话中，他对自己的父亲提起诉讼，因为他需要为一个家里死去的奴隶负责。在那个时代，起诉自己的父亲被认为是一个非常极端的行为。但尤西弗罗 仍然认为宗教义务让他必须这样做。也许在这一点上他是对的——但他在做出这个决定是他处于什么位置呢？他是否有任何根据来回答这样一个问题：那种行为是有关宗教职责的？&lt;/p&gt;

&lt;p&gt;在苏格拉底和尤西弗伦对话的过程中，他发现尤西弗伦没有认真考虑这件事，也没有思考虔诚的本质这个问题。尤西弗罗 是过着未经省察的人生的一个明显的例子（即使他认为自己是对于虔诚这个问题的专家），一篇以他名字命名的对话揭示了忽视哲学问题会产生多么严重的后果。除非他花大力气对的宗教职责做出准确的推测，否则他的宗教人生会变得很糟糕。似乎可以这样说，在这个例子中，他指控自己的父亲谋杀他人似乎是不虔诚的，他犯下了一个可怕的错误，便是没有意识到自己在做什么。&lt;/p&gt;

&lt;p&gt;从这个对话中得出的一个简单的教训是缺乏对道德哲学问题的重视将对人生价值产生灾难性的后果。尤西弗罗 将会犯下一个最严重的错误，不是因为他是自私，贪图权力，贪婪，而是因为他是蒙昧，愚笨，肤浅。&lt;strong&gt;因为他没有求知欲，没有兴趣探寻哲学的伦理问题，他缺乏同时也永远不会理解他所称的道德的系统和一般性含义，甚至是其中的皮毛也不会理解。&lt;/strong&gt; 毫无疑问，他是从他的父母学习到如何使用这个词 hosiotEs （“虔诚”），也学到了其他的规范灌输的词。但一个人的童年接受的教育至今只有一次，自己不能想好，去决定应该学习哪些规范词语。&lt;/p&gt;

&lt;p&gt;苏格拉底式的对话里有另一个人的显示出道德模糊的例子：克里托，在以其名字命名的对话里，他建议苏格拉底通过贿赂他的狱吏来越狱。克里托帮助苏格拉底逃脱的其中一个原因是他害怕周围的人耻笑他：在这种情况下很多人认为苏格拉底的朋友应该使用他们能力帮助他逃脱，如果他们没有这样做，则看起来像懦夫的行为（45E-46A）。值得注意的是，虽然克里托跟随在苏格拉底身边多年，但苏格拉底却一直没能使他从别人看法的奴役中解放出来。苏格拉底向克里托提过多次，他始终坚持一点：在做任何决定前必须首先多次考虑的是自己做的是否正义，而不是别人会怎样看。这个对话给我们的一个教导是，政治决策——如是否该接受处罚，即使处罚是不公正的——必须基于一个公民应该如何对待他的城市的一般理论。直到一个人抛开民意的影响，为公民责任的理论努力，一个人才不会误入政治事务的歧途。幸运的是， 克里托碰巧受到了苏格拉底的影响；若只凭借他自己，他将会为了男子气概的外表，成为欲望的奴隶。相比之下，尤西弗罗虽不在乎他的公众形象，但除了对于宗教事务有莫名的无知并且不加思索的自信外，也没有可以指引苏格拉底的地方。&lt;strong&gt;他们各自拥有各自的未经省察的人生。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果参考民众的意见确实能提出关于对与错，好和坏，正义和非正义等深思的问题，那对于认真思考关于道德问题的普遍意见是没有异议的。（克里托 47B）但是，假设发现有人进行这样的研究——并有人声称他们已经苦苦思考很久关于艰难的道德问题，并已成为这方面的专家。这正是柏拉图的《普罗塔哥拉》开篇描述的情况：与这部作品同名的著名智者来到雅典，希波克拉底要苏格拉底陪他去拜访这个著名智者和并成为他的学生。苏格拉底警告他：不要轻易委托出像灵魂这样珍贵的东西，特别是一个人不是他所宣称的专家（313A-C）。希波克拉底感到迫切需要道德教育，这种教育要超越孩童时期父母对自己的教育，他认为这样做是正确的。他渴望道德知识，但为了获得它，他必须了解自称有知识的人是否真的能教导自己。苏格拉底与希波克拉底的对话意味着，一个人永远不能放弃自己最重要的智慧，不能把自己的教育完全放在别人的手中。每个人都应该检验那些自称有道德知识的人，但成功且可靠地做到这一点，必须先教育自己，先决定要接受那种道德观点。这也有可能，有些人真的是道德专家，他们与他人讨论道德问题，能为他人作出最好的解答。这种可能性没有排除我们所有人都要过上经过省察的人生的需求除；除非我们这样做，否则我们给了别人极大伤害我们的机会。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;即使是那些钦佩并与苏格拉底在结交的人也不能避免误入歧途。&lt;/strong&gt; Charmides 和 Critias在苏格拉底被审判时都在场，明显没有从与苏格拉底的对话中受益 (他们是404 到403BC期间统治雅典的三十僭主之一)。 阿尔西比亚得也没有受益，他在后来的伯罗奔尼撒战争中背叛了雅典。（在以阿尔西比亚得名字命名的对话中，虽然这篇对话的作者不是柏拉图，但也值得仔细研究，柏拉图《会饮》中他的形象也同样如此 212C-223D）。阿尔西比亚得正如在柏拉图《会饮》中被描绘的那样，当着苏格拉底的面承认他对他的方式生活感到羞处（216B-ĉ）。但即使是这样，他也没能使自己严肃对待哲学。Charmides, Critias和 Alcibiades为未经省察的人生的困难提供了进一步例子，当我们不进行道德探寻时，我们也能发现这些困难。如果 像克里托和尤西弗罗 这样的人没有像Critias, Charmides, 和 Alcibiades一样成为违法犯罪者，那可真是走运。&lt;/p&gt;

&lt;p&gt;柏拉图《Ion》中，与作品同名对话者提供了一个明显的例子：他屈服于理性思考的能力，容纳别人的思想和情感。Ion是一个rhapsode——专业的荷马史诗朗诵和解说者。但他承认，他并不懂得荷马史诗的主题；甚至，他说，荷马史诗的思想浸入了他的灵魂，并通过他再浸入听众的灵魂。苏格拉底认为，灵感的传递开始与激发了诗人创作的的缪斯女神：创作诗句的作家为了接受来自神的影响抛开自己的智慧，反过来rhapsode的灵感来自于他读的诗，和听众听到了来自rhapsode的吟诵，也放弃了他们本身的思想，被听到的溢美之词所掌控（533d-35A）。在一定程度上，诗歌爱好者生活在诗歌的影响下，没有仔细省察其中的含义，他们是把自己的生活交由别人来掌握（如希波克拉底）。如果他们走运，激发他们的诗句的观点是真实的，那么他们就把自己交给了一个好的指引者。但这并不是过自己人生的方式。&lt;/p&gt;

&lt;p&gt;柏拉图的《高尔吉亚篇》探讨另一种模式：任由一个人的灵魂不加批判地受到别人的影响。雅典政治生活的成功需要一个人做任何吸引民众的事（502E，513B-C）：一个必须获得公众赞同的人，一个能用演讲取悦大众的人。一个人必须像糕点师一样，根据味蕾单独选择配料，而不考虑食用者的健康。Callicles是最后一个也是最大胆的的一个苏格拉底的对话者，他批评前两次对话者高尔吉亚和波卢什回答苏格拉底的方式，总是表现出他们不愿意说的感到羞愧的一面：他们自己不相信自己所说，并且按照设计好的方式在回答（482C-E）。&lt;/p&gt;

&lt;p&gt;人们在公共场合表现出表面的忠诚，实际上是在日常社会生活交往中表现的虚假的自我——在理想国第二章也有提到，&lt;strong&gt;当格劳孔提到，绝大多数人在隐身的状态下（戴着盖斯的戒指），都会去尝试做坏事，即使他们自己在公众面前会谴责这种不正当行为。&lt;/strong&gt; 在与他人的日常交往中，他们躲在一个虚假的自我之后，为了达到目的他们戴着面具。他们不但不知道自己应该拥有什么，什么值得拥有，还给他人留下自己缺乏且渴望之物的虚假印象。他们没有真正的自我——一个自己设计的自我，经过剖析的自我——所以他们的社会面具后隐藏的除了对别人的被动模仿外，什么都不是。柏拉图介于苏格拉底式人生与未经省察的人生之间的思考，是对普通人的毫不偏颇的刻画的来源。&lt;/p&gt;

&lt;p&gt;然而，在苏格拉底式对话中有一段，属于对普通人决定如何行动的标准，完全符合普通人的欲望。在柏拉图的《普罗塔哥拉》中，苏格拉底认为大多数人只凭借未来的快乐和痛苦来做决定（352B-56C）。他们认为快乐和痛苦是人类生活中的两个最强大的力量，他们把快乐作为唯一好的东西，痛苦是唯一不好的东西。因此，当他们拒绝追求快乐，或愿意接受痛苦，那只是因为他们进行了理性的计算，以便在今后获得最大的快乐，或者最少的痛苦。苏格拉底没有攻击《普罗塔哥拉》中提到的决策标准；在这篇对话中，他只是努力在证明一个这样做决定的人，懂得未来的快乐和痛苦是人生的关键因素，并且我们不能够和我们可以做到最好的行为产生对立。但令人惊讶的是，这里苏格拉底把普通人赋予了他对话者本没有的特点：一个人做采纳的决定表现出了他们想要的事物。&lt;/p&gt;

&lt;p&gt;然而，不能作出这样疯狂的假设，即仅仅因为有了真正的决策标准，人生就会变好。标准必须是正确的，因此一个人必须找到原因，为什么这些快乐和痛苦在人生中这样重要。这不是一个大多数人都想知道的问题。苏格拉底描述的他们的视野是情绪化的：&lt;strong&gt;他们认为，与欲望，恐惧，爱，快乐，和痛苦比较起来，知识是对人生的影响不那么重要。&lt;/strong&gt; 这种态度使他们不能思考真正的人生目标。即使这种知识是能够获取的，他们认为这对自己的行为也不会有什么影响。因此，他们向他们追求快乐的欲望投降，尽力避免痛苦。他们认为唯一值得他们付诸行动的是如何得到这些好东西的最佳组合。然而他们却不会想知道，是否有更好的方法去作出决定，这些好的东西是否有坏处，不会对将来的快乐和痛苦产生影响。因此，像大多与苏格拉底对话的人一样，他们冒着巨大的风险：一个人经历的属于自己的快乐和痛苦不是正确的决策知道——如果有其他一类事物也是有好有坏——那么大多数人的处境会很糟糕。&lt;/p&gt;

&lt;h1 id=&#34;大多数人都是其他人:f856045648ed1256c7d09f14d1393f16&#34;&gt;“ 大多数人都是其他人”&lt;/h1&gt;

&lt;p&gt;奥斯卡·王尔德的《深渊书简》写道：“大多数人都是其他人，他们的想法是别人的意见，他们的生活是在模仿，他们的激情都是虚假的。”，这和经过省察的人生有了类似的表达情感，也是一种接受苏格拉底式人生要求的方法。有人可能会对王尔德提出反对：那为什么我的观点不会也是别人的观点呢？如果我的想法就是别人的想法会不会非常可怖呢？我相信这个命题成立，那还存在什么异议——仅仅是因为别人认同我，我就应该停止这样做？&lt;/p&gt;

&lt;p&gt;王尔德抓住了要点，但如果我们拿他说，永远不会形成和抛弃智慧的标准（即衡量看法的能力）是致命的缺点，不假思索地接受其他人的话语、行为和感受。想要变得像另外一个人是很严重的错误，如果这仅仅是一个模仿他人的不假思索的行为，而不思考这是否值得模仿。如果我爱一幅画，它应该是因为我感受到了我自己的眼睛看到到的感情，并且从内心出发认为这值得欣赏。别人喜欢一幅画，能够使我趋向认为这幅画有某些地方值得欣赏的；但是如果我并没发现这幅画好在哪里，并且没有如实得表达出来，那么我并没有得到他们的真实看法（当然假定别人的看法是真实的没有误导性的）。同样的观点不仅适用于画作，同时也适用于对好坏的评价。如果我们只是模仿他人的思想和行为，但却不加以评判思想的质量，那么我们则是不是用自己的心灵在面对世界。&lt;strong&gt;我们成为了其他人，失去了自我。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;阿尔西比亚得这样描述苏格拉底：再以没有人能像他一样。（会饮 221C）。但是，尽管苏格拉底未经省察的人生不存在未经思索的模仿，但这没有要求我们为了不寻常而变得不寻常。苏格拉底也没有这种动机，认为真实的自我只有通过评价决定这个单独标准来评判——虽然正如我们看见的那样，他没有批评那些有羞耻心的人或是害怕别人异样的眼神的人。&lt;strong&gt;经过省察的人生值得度过，因为对于正确行为的标准我们知之甚少；所以出于我们的无知，我们的人生没有那么好。必须通过自己的努力、凭借自己的看法去发现正确的标准。但一旦我们发现了那些标准，我们都会变得相似。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;告诫我们不要过未经省察的人生的意思是&lt;strong&gt;通过自身努力才能发现真理&lt;/strong&gt;。相反，它最好被看成是基于人类发展和人类本性：人类天生就被渴望快乐憎恨痛苦。他们追求权力和地位，因为财富，权力，地位能带来快乐。这是成为雅典重要的价值观并不是偶然。（申辩 29d-e）；这是全人类社会的共同的重要价值。虽然每一个孩子都会接受的道德教育，学会如何与他人沟通，学会如“好”，“正义”和“可耻”这些共同的道德规范。教育会留下在道德认识上留下巨大空白，这个空白能够被进一步的求索来填补；因为童年形成的对正义和善良的概念依然是初步的。他们接受的有限教育和强大的心理力量做着产生了冲突，心理想要快乐，权力和地位，并且引导这行为。那些感到理所当然需要进一步的教育的人常常不知道如何满足这种需要：他们通过美丽的诗句和名誉权利，把自己的想法表达给喜欢用华丽肤浅方式的人。或者，他们干脆放弃屈服于心理因素，不再思考，并把其对渴望快乐和憎恨厌恶痛苦的强烈欲望作为正确行为的唯一标准。&lt;/p&gt;

&lt;p&gt;经过省察的人生的巨大价值在于，有一种可信的方式来找出我们头脑中的错误和教育里的缺陷，来填补关于好、正义、善良的概念空白。苏格拉底把它作为一个永远不会结束的过程。无论一个人在的道德认识上取得了多大的进步，学习依然是无止尽的，永远需要对于德性和其他道德规范的讨论。科学的思考方式已经普及。正如我们现在认识到的，科学永远从一个问题跳到另一个问题，每个解决方案的都会产生新的研究领域。我们可以说，苏格拉底在寻求一个道德的科学。这不是通过一次性回答所有的问题来终结所有的道德规范的讨论。无论我们学习了多少，学习都是无休止的，甚至可以温故而知新。那些在这个不断后退的目标方面取得进展的人，扩展了知识深度避免了在生活中范严重的错误。&lt;/p&gt;

&lt;h1 id=&#34;德性-知识-和良好的意愿:f856045648ed1256c7d09f14d1393f16&#34;&gt;德性，知识，和良好的意愿&lt;/h1&gt;

&lt;p&gt;这就是为什么我们应该过经过省察的人生。但这不是苏格拉底唯一坚持的观点。他说，我们也应该努力成为优秀的人，成为公正，勇敢 sophron（“克制”，“自制”，“稳健”，“节制”）的人，拥有所有的德性。这些劝诫互相有关系吗，或他们相互独立？——甚至可能互相之间有干扰？在《普罗塔哥拉》中，苏格拉底认为，它们是一个统一体；它们都有各自单独的一面，在正确的理解下是不会产生冲突的。&lt;strong&gt;德性的统一性所揭示的事实是，在寻求知识和智慧的不同道路上，它们之间相关联系。&lt;/strong&gt; 为了获得某种德性，一个人在人生的某一面必须做到足够好：例如，要变得勇敢，就要面对恐惧，并以正确的方式来处理恐惧。但要做到这一点，必须问自己人生和境况的哪些方面会有恐惧。是死亡吗？我们真的害怕它的到来吗？这不是我们的童年本身的道德修养能够让我们有能力来回答的一个问题。可以这样回答，省察自己的人生，找到真正有害的事情，这才是值得害怕的。这种方式反过来是不能被成功应用的，除非你了解对人来说，什么是好的；知道什么是好的，和知道什么是坏的是两个独立的问题。所以真正的勇气（不是愿意承担风险的愚蠢行为）不能从苏格拉底那种从事哲学探究的人身上拿走。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同样的道理也适用于德性的品质：它是一个人拥有的好品格，并且它的好只能通过伦理探寻来发现。&lt;/strong&gt;在生命的初期，我们对真正的人生目标没有理解的时候，德性不要求被拥有；但很久之后，当我们知道了我们的人生目标是什么以及怎样去实现的时候，就不一样了。这就是苏格拉底在《普罗塔哥拉》中提出的，德性是智慧和知识的形式。&lt;strong&gt;这并不能得出这样的结论，即拥有德性的人没有感情。一个勇敢的人会害怕应该害怕的东西，有节制的人能通过恰当的方式体验快乐。&lt;/strong&gt; 但这些情绪反应将随着不同场合的改变流露。每个人都有幼稚情绪，这种情绪不只在童年才有，也终会被正义的情感所消灭和取代。&lt;/p&gt;

&lt;p&gt;在“美诺篇”中 ，苏格拉底认为，在以下几个方面，德性是知识的一种。考虑一个通常被认为是好的东西，德性除外：例如健康、美丽或强壮。这些优点从长远和总体的角度来看的确是好的，但肯定存在健康、美丽或强壮也有不利的方面的情况。例如，一个强大和健康的人会高估自己的力量和体能，承担可能致命的任务。男孩英俊的面孔会导致别人采用损害他智力发展的方式对待他。这些看起来好的东西是否真的好取决于它们怎样被运用，然后如何运用这些好的东西并没有与其相辅相成。要知道如何使用这些天资才能使一个人真正受益，是需要一定的检验和实践的问题。对于只能算作一般的资质的智力水平也是一样，在不同情况下都有利有弊。根据苏格拉底的说法，好坏的差异在于一个人对智慧的运用——对于如何利用好的食物的知识。（类似的论证请参见 Euthydemus 278d-82A）。&lt;/p&gt;

&lt;p&gt;他的理由和康德的《道德形而上学的基本原理》开篇十分类似。康德在开篇中写道：“除了善意，世界上在也没有一种能被称得上经过认证的好可以被构想出来，甚至在世界之外也没有”。他举出了很多例子：心灵品质如聪慧，和勇气，不同情形下的好“能够产生害处，“如果使用这些好的意愿不好的话”对于其他的幸运——权力，财富，名誉，健康，满足——也是如此。&lt;/p&gt;

&lt;p&gt;他们将变成“傲慢与自大，如果在心中没有一个良好的意愿的话。”康德的结论是，没有什么比但良好的意愿更具备“内在的无条件的价值”。3没有什么情况下良好的意愿会导致不好和损害。&lt;/p&gt;

&lt;p&gt;但康德在开篇提出的与苏格拉底的“美诺篇”中的观点类似， 但却没有得出一个好人应当进行道德探寻的结论——每天都像苏格拉底一样同别人探讨德性是什么。康德认为，普通的道德代理人不需要靠哲学帮忙来将规范概念应用到特定情况中，他们只需要防范规范刺激下动机的恶化。一个心智健全的成年人知道道义之路在哪。需要倍加努力的不是知道如何行事，而是有一个恰当的动机去行事，&lt;strong&gt;因为一个人的意愿可以强大到驱使一个人单纯的动机，并且克服所有强烈的动机。&lt;/strong&gt;对康德来说，完善一个人的灵魂是一个 净化心灵的过程，而不是哲学训练的过程。像苏格拉底一样，他得到了灵魂深处核心的价值的东西——但这些东西并不包含复杂抽象的哲学思考。只有在灵魂之外的堕落这一点上，两个哲学家的观点是一致的。&lt;/p&gt;

&lt;p&gt;跟随康德的引导，二十世纪最有影响力的道德哲学家之一WD罗斯认为任何受过教育有道德观念的人能够列出一个完整的职责表和一个完整的包括好坏事物的表。4 需要哲学技能和观察的是理解什么是一件事成为责任、成为好的。但是这样的职业与教导普通成年人应该如何度过人生没有关系。他认为，现实事物中的困难在于，当责任有冲突时知道该怎么做或者好坏发生冲突，没有哪方能胜过谁时。在这种情况下，做什么取决于每种情况下的细节，&lt;strong&gt;抽象的道德理论可以说不能引导普通民众的道德意识。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一个方面，功利主义——唯一的职责是利益最大化—— - 比康德哲学更接近苏格拉底哲学。因为功利主义采取了修正的态度来对待道德常识框架，即孩子们从他们的父母和社区来学习。 孩子们通常没有被教育要尽可能多做善事。他们 之前设定的目标 是更加温和，而且往往他们学习的道德由各种各样的规则组成：不打架，不撒谎，不拿别人的东西、爱护兄弟姐妹，尊重长老。功利主义的主要思想——个人应该关注全世界的幸福，个人不能作恶无论这是否导致了更大的善——是大多数功利主义只有在阅读哲学和与教师，学生，朋友谈话时才话能发现。为了成为一个功利主义的人，必须先经过一段时间的自我反省：我们必须要通过做一些伤害，来讯问一个人是否真的认为最大的好的政策是附着在更广泛接受的规则的复杂的网络的进步。一个人也必须问自己最重要的问题：什么是真的好？但在另一个方面，功利主义完全不赞同苏格拉底被省察的人生的要求。因为，正如我们所看到的，苏格拉底的禁令是基于“每天都在探讨德性”或者可以给人类带来最大利益的话题。苏格拉底认为，道德谈话的主要内容是永远不会枯竭的；道德生活的主要问题永远不能得到一次性解决，因为每一个新的理解会带来新的问题。这是 功利主义强烈反对 的想法 。他们认为功利主义者的程式永远不能加以改进。他们 认为， 一旦人们了解到什么是好的， 就没有必要继续思考了：一个人应该仅仅尽可能产生多的，并且这不是一个需要进行的哲学探究的做法。我们需要互相探讨我们的行为会产生什么影响；但是我们不需要谈论道德。古代伦理学的苏格拉底式角色&lt;/p&gt;

&lt;p&gt;古代主要道德哲学家​站在苏格拉底的立场的至少有：他们认为如果哲学观念基于系统和抽象的思考，并进一步超越了我们童年时期学习的共同道德观，就很在某种程度上，影响一个人的思想，过上糟糕的人生，给别人造成巨大损害。他们认为，最重要的是我们必须达成一个共同理解，超过小孩子所认为的好。这是 的希腊伦理学的主要概念，苏格拉底式的对话展示了没有理解什么是好快是不可能理解德性，并且奠定了其核心基础。(Laches and Charmides 在其中所扮演的角色十分重要.) 柏拉图在《理想国》中的观点是，最高的智慧是对好的形式的认识——需要多年的科学训练来获得。亚里士多德说，学习道德的学生要从努力成为一个更好的人开始，为了做到这一点，他一定要了解人生首要的好。就像一个射手瞄准目标，他将能够切中要害——以他应该的方式生活及做决定——通过哲学论证，来发现对他重要的是什么。伊壁鸠鲁认为好就是明显且是被普遍接受的快乐；但他们认为的快乐在种类和价值上有极大不同，&lt;strong&gt;唯有哲学思考能确定哪些是最适合我们去追求的。&lt;/strong&gt;斯多葛学派认为，&lt;strong&gt;只有接受目的论的宇宙结构可以帮助我们摆脱破坏我们的幸福的幼稚情绪。&lt;/strong&gt;Pyrrhonian怀疑是唯一苏格拉底式的：他们自豪自己是唯一的哲学学校，&lt;strong&gt;继续从事苏格拉底后对智慧的探寻，避开一切定论的意见。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于所有的这些古代的思想家和学者，只有系统和抽象的思考才能揭示我们的生活中恰当行为的核心。如果我们只根据现成的第一手资料来做决定，不假思索，我们则会会误入歧途，对所有的成年人都是这样。这些苏格拉底的跟随者认为，我们必须采纳这两种看法中的一种：（柏拉图说）我们必须把让少数专家来完善和系统化我们的规范用词，并按照他们的理论制定方法，把道德意识渗入普通人的心中；或（苏格拉底说）我们每个人必须竭尽所能靠自己经历这个过程。无论哪种方式，我们在日常行为决策中都会用错道德规范的概念，除非这些概念是通过恰当使用的过程——即通过哲学理论——中形成的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo静态网站生成器中文教程</title>
      <link>http://sun-friderick.github.io/post/2015-01-31</link>
      <pubDate>Sat, 31 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-01-31</guid>
      <description>

&lt;h1 id=&#34;前言:d605f9890f3528aea462ac7515ece633&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt;是什么？官方文档是这样介绍它的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hugo is a general-purpose website framework. Technically speaking, Hugo is a static site generator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hugo是一种通用的网站框架。严格来说，Hugo应该被称作静态网站生成器。&lt;/p&gt;

&lt;p&gt;静态网站生成器从字面上来理解，就是将你的内容生成静态网站。所谓“静态”的含义其实反映在网站页面的生成的时间。一般的web服务器（WordPress, Ghost, Drupal等等）在收到页面请求时，需要调用数据库生成页面（也就是HTML代码），再返回给用户请求。而静态网站则不需要在收到请求后生成页面，而是在整个网站建立起之前就将所有的页面全部生成完成，页面一经生成便称为静态文件，访问时直接返回现成的静态页面，不需要数据库的参与。&lt;/p&gt;

&lt;p&gt;采用静态网站的维护也相当简单，实际上你根本不需要什么维护，完全不用考虑复杂的运行时间，依赖和数据库的问题。再有也不用担心安全性的问题，没有数据库，网站注入什么的也无从下手。&lt;/p&gt;

&lt;p&gt;静态网站最大好处就是访问快速，不用每次重新生成页面。当然，一旦网站有任何更改，静态网站生成器需要重新生成所有的与更改相关的页面。然而对于小型的个人网站，项目主页等等，网站规模很小，重新生成整个网站也是非常快的。Hugo在速度方面做得非常好，Dan Hersam在他这个&lt;a href=&#34;https://www.udemy.com/build-static-sites-in-seconds-with-hugo/&#34;&gt;Hugo教程&lt;/a&gt;里提到，5000篇文章的博客，Hugo生成整个网站只花了6秒，而很多其他的静态网站生成器则需要几分钟的时间。我的博客目前文章只有几十篇，用Hugo生成整个网站只需要0.1秒。官方文档提供的数据是每篇页面的生成时间不到1ms。&lt;/p&gt;

&lt;p&gt;我认为对于个人博客来说，应该将时间花在内容上而不是各种折腾网站。Hugo会将Markdown格式的内容和设置好模版一起，生成漂亮干净的页面。挑选折腾好一个喜爱的模版，在Sublime Text里用Markdown写博客，再敲一行命令生成同步到服务器就OK了。整个体验是不是非常优雅简单还有点geek的味道呢？&lt;/p&gt;

&lt;p&gt;Hugo是用&lt;a href=&#34;http://golang.org/&#34;&gt;Go语言&lt;/a&gt;写的，为什么使用Go，作者&lt;a href=&#34;http://spf13.com&#34;&gt;Steve Francia&lt;/a&gt;的原话是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I looked at existing static site generators like Jekyll, Middleman and nanoc. All had complicated dependencies to install and took far longer to render my blog with hundreds of posts than I felt was acceptable. I wanted a framework to be able to get rapid feedback while making changes to the templates, and the 5+-minute render times was just too slow. In general, they were also very blog minded and didn’t have the ability to have different content types and flexible URLs.&lt;/p&gt;

&lt;p&gt;I wanted to develop a fast and full-featured website framework without dependencies. The Go language seemed to have all of the features I needed in a language. I began developing Hugo in Go and fell in love with the language. I hope you will enjoy using (and contributing to) Hugo as much as I have writing it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结他的一下大意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;吐槽脸：Jekyll以及那一堆静态网站生成器安装麻烦（依赖多），速度又慢，内容类型单一，url死板&lt;/li&gt;
&lt;li&gt;挽袖子状：Go挺萌的符合我对语言的一切幻想，就用它重写一个吧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我为啥用Hugo？除了以上提到的原因，很重要的一点是&lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo主页&lt;/a&gt;很漂亮，看了一圈静态网站生成器的主页，一眼就被Hugo的美到了，首页的照片里的那个格子小本子应该是&lt;a href=&#34;http://www.paperthinks.com&#34;&gt;Paperthinks&lt;/a&gt;，我正好也在用，有种刚好看到自己桌面的感觉。&lt;/p&gt;

&lt;h1 id=&#34;安装:d605f9890f3528aea462ac7515ece633&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;如果说速度快是Hugo的第一大优点，那么安装简单应该就是Hugo的第二大优点。对于Mac用户，没有brew的话先安装brew，在命令行里敲：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再敲一行安装Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew new Hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以在&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;这里&lt;/a&gt;直接下载对应系统的binary文件，解压就行了。&lt;/p&gt;

&lt;h1 id=&#34;了解hugo:d605f9890f3528aea462ac7515ece633&#34;&gt;了解Hugo&lt;/h1&gt;

&lt;p&gt;首先建立自己的网站，mysite是网站的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入该路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该目录下你可以看到以下几个目录和&lt;code&gt;config.toml&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ▸ archetypes/ 
 ▸ content/
 ▸ layouts/
 ▸ static/
   config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;是网站的配置文件，包括&lt;code&gt;baseurl&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;copyright&lt;/code&gt;等等网站参数。&lt;/p&gt;

&lt;p&gt;这几个文件夹的作用分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes：包括内容类型，在创建新内容时自动生成内容的配置&lt;/li&gt;
&lt;li&gt;content：包括网站内容，全部使用markdown格式&lt;/li&gt;
&lt;li&gt;layouts：包括了网站的模版，决定内容如何呈现&lt;/li&gt;
&lt;li&gt;static：包括了css, js, fonts, media等，决定网站的外观&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hugo提供了一些完整的主题可以使用，下载这些主题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时现成的主题存放在&lt;code&gt;themes/&lt;/code&gt;文件夹中。&lt;/p&gt;

&lt;p&gt;现在我们先熟悉一下Hugo，创建新页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;content/&lt;/code&gt;文件夹可以看到，此时多了一个markdown格式的文件&lt;code&gt;about.md&lt;/code&gt;，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
+++
date = &amp;quot;2015-02-01T18:19:54+08:00&amp;quot;
draft = true
title = &amp;quot;about&amp;quot;

+++

# 关于我
- 2010  HR@RUC
- 2014  CS@ICT, CAS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我在页面中加入了一些内容，然后运行Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -t hyde --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;参数的意思是使用hyde主题渲染我们的页面，注意到&lt;code&gt;about.md&lt;/code&gt;目前是作为草稿，即&lt;code&gt;draft&lt;/code&gt;参数设置为&lt;code&gt;true&lt;/code&gt;，运行Hugo时要加上&lt;code&gt;--buildDrafts&lt;/code&gt;参数才会生成被标记为草稿的页面。
在浏览器输入localhost:1313，就可以看到我们刚刚创建的页面。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/hugo-server-1.png&#34; alt=&#34;hugo-server-1&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;注意观察当前目录下多了一个文件夹&lt;code&gt;public/&lt;/code&gt;，这里面是Hugo生成的整个静态网站，如果使用Github pages来作为博客的Host，你只需要将&lt;code&gt;public/&lt;/code&gt;里的文件上传就可以，这相当于是Hugo的输出。&lt;/p&gt;

&lt;h1 id=&#34;主题选择:d605f9890f3528aea462ac7515ece633&#34;&gt;主题选择&lt;/h1&gt;

&lt;p&gt;进入&lt;code&gt;themes/hyde&lt;/code&gt;文件夹，可以看到熟悉的文件夹名，和主题相关的文件主要是在&lt;code&gt;layouts/&lt;/code&gt;和&lt;code&gt;static/&lt;/code&gt;这两个文件内，选择好一个主题后，可以将&lt;code&gt;themes/&lt;/code&gt;中的文件夹直接复制到&lt;code&gt;mysite/&lt;/code&gt;目录下，覆盖原来的&lt;code&gt;layouts/&lt;/code&gt;, &lt;code&gt;static/&lt;/code&gt;文件夹，此时直接使用\$Hugo server就可以看到主题效果，修改主题也可以直接修改其中的css, js, html等文件。&lt;/p&gt;

&lt;p&gt;我的博客模版是在Hugo作者spf13的&lt;a href=&#34;http://spf13.com&#34;&gt;博客&lt;/a&gt;基础上修改的。第一步，先去他的博客网站源码&lt;a href=&#34;https://github.com/spf13/spf13.com&#34;&gt;主页&lt;/a&gt;把整个项目clone下来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:spf13/spf13.com.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把项目中的&lt;code&gt;static/&lt;/code&gt;和&lt;code&gt;layouts/&lt;/code&gt;文件复制到自己网站的目录下替换原来的文件夹。再次运行Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --buildDrafts -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次没有选择主题，如果选择了主题会将当前的主题覆盖掉。参数&lt;code&gt;-w&lt;/code&gt;意味监视watch，此时如果修改了网站内的信息，会直接显示在浏览器的页面上，不需要重新运行\$hugo server，方便我们进行修改。这是采用了spf13主题的页面：&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/hugo-server-2.png&#34; alt=&#34;hugo-server-2&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;我们尝试在他的主题基础上修改，找到&lt;code&gt;/layouts/partials/subheader.html&lt;/code&gt;文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;header id=&amp;quot;header&amp;quot;&amp;gt;
    &amp;lt;figure&amp;gt;
      &amp;lt;a href=&amp;quot;/&amp;quot; border=0 id=&amp;quot;logolink&amp;quot;&amp;gt;&amp;lt;div class=&amp;quot;icon-spf13-3&amp;quot; id=&amp;quot;logo&amp;quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;/figure&amp;gt;
    &amp;lt;div id=&amp;quot;byline&amp;quot;&amp;gt;by Steve Francia&amp;lt;/div&amp;gt;
    &amp;lt;nav id=&amp;quot;nav&amp;quot;&amp;gt;
    {{ partial &amp;quot;nav.html&amp;quot; . }}
    {{ partial &amp;quot;social.html&amp;quot; . }}
    &amp;lt;/nav&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将by Steve Francia换成by myname，再次回到浏览器，可以看到左边侧栏已经发生变化了，你可以根据自己的需要修改对应的文件，当然得懂一点css, html。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/hugo-server-change.png&#34; alt=&#34;hugo-server-change&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;h1 id=&#34;评论功能:d605f9890f3528aea462ac7515ece633&#34;&gt;评论功能&lt;/h1&gt;

&lt;p&gt;个人博客当然不能没有评论，Hugo默认支持&lt;a href=&#34;https://disqus.com/&#34;&gt;Disqus&lt;/a&gt;的评论，需要在模版中添加以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ template &amp;quot;_internal/disqus.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spf13在&lt;code&gt;/layouts/partials/disqus.html&lt;/code&gt;中已经添加好了。&lt;/p&gt;

&lt;p&gt;只需要去Disqus注册一个账号，然后在&lt;code&gt;config.toml&lt;/code&gt;里加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disqusShortname = &amp;quot;yourdisqusShortname&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;-w&lt;/code&gt;参数是不能监测&lt;code&gt;config.toml&lt;/code&gt;里参数变化的，因此需要重新运行Hugo，进入localhost:1313/about，可以看到评论功能。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/comments.png&#34; alt=&#34;comments&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;h1 id=&#34;代码高亮:d605f9890f3528aea462ac7515ece633&#34;&gt;代码高亮&lt;/h1&gt;

&lt;p&gt;作为码农，代码高亮对于写博客来说当然必不可少。有两种方法：第一种是在生成页面时就生成好代码高亮过的页面；第二种是使用js，用户加载页面时浏览器再进行渲染。&lt;/p&gt;

&lt;p&gt;第一种方法需要使用&lt;a href=&#34;http://pygments.org/&#34;&gt;Pygments&lt;/a&gt;，一个python写的工具。&lt;/p&gt;

&lt;p&gt;安装Pygments：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip install Pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有pip的先下载 &lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py&#34;&gt;https://bootstrap.pypa.io/get-pip.py&lt;/a&gt; ，然后安装pip：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pygments的调用采用shortcodes实现，spf13里也写好了，在&lt;code&gt;/layouts/shortcode/highlight.html&lt;/code&gt;里&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ $lang := index .Params 0 }}
{{ highlight .Inner $lang }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要使代码高亮，在你的代码外面加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ % highlight python %}}
your code here.
{{ % /highlight %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里为了避免以上两行被识别为代码高亮的标识，在&lt;code&gt;{{&lt;/code&gt;和&lt;code&gt;%&lt;/code&gt;之间多加了一个空格，实际使用的时候需要把空格去掉。&lt;/p&gt;

&lt;p&gt;第二种方法比较简单，在&lt;code&gt;layouts/partials/header_includes.html&lt;/code&gt;中加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://yandex.st/highlightjs/8.0/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://yandex.st/highlightjs/8.0/styles/default.min.css&amp;quot;&amp;gt;
&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了&lt;a href=&#34;http://yandex.ru/&#34;&gt;Yandex&lt;/a&gt;的&lt;a href=&#34;http://highlightjs.org/&#34;&gt;Highlight.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其他的可以实现代码高亮的js库还有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://highlightjs.org/&#34;&gt;Highlight.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://craig.is/making/rainbows&#34;&gt;Rainbow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alexgorbatchev.com/SyntaxHighlighter/&#34;&gt;Syntax Highlighter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://code.google.com/p/google-code-prettify/&#34;&gt;Google Prettify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;插入图片:d605f9890f3528aea462ac7515ece633&#34;&gt;插入图片&lt;/h1&gt;

&lt;p&gt;图片文件放在&lt;code&gt;static/media&lt;/code&gt;文件中，插入图片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ % img src=&amp;quot;/media/example.jpg&amp;quot; alt=&amp;quot;example&amp;quot; %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的&lt;code&gt;{{&lt;/code&gt;和&lt;code&gt;%&lt;/code&gt;之间也加上了空格，避免这行代码起作用，实际使用也需要把空格去掉。&lt;/p&gt;

&lt;h1 id=&#34;使用mathjax:d605f9890f3528aea462ac7515ece633&#34;&gt;使用Mathjax&lt;/h1&gt;

&lt;p&gt;在需要渲染公式的页面加入以下代码，比如&lt;code&gt;layouts/_default/single.html&lt;/code&gt;文件，这个文件是对于所有post进行页面生成的模版，如果你希望所有页面都对公式渲染的话，可以加入&lt;code&gt;layouts/partials/footer.html&lt;/code&gt;文件里，保证所有生成的页面都有这几行代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;
  src=&amp;quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mathjax和Markdown会有冲突问题，&lt;a href=&#34;http://doswa.com/2011/07/20/mathjax-in-markdown.html&#34;&gt;这里&lt;/a&gt;提供了解决方案。&lt;/p&gt;

&lt;h1 id=&#34;用github-pages作为网站的host:d605f9890f3528aea462ac7515ece633&#34;&gt;用github pages作为网站的Host&lt;/h1&gt;

&lt;p&gt;Github pages分为两种：一种是项目主页，每个项目都可以有一个；另一种是用户主页，一个用户只能有一个。&lt;/p&gt;

&lt;p&gt;因为用户主页只能有一个，所以建议使用项目主页托管，不过我这里采用了用户主页，反正我也只用一个博客，使用个人主页作为Host也相对更简单一点。&lt;/p&gt;

&lt;p&gt;我们需要创建两个单独的repo，一个用于放Hugo的输入文件，即除了&lt;code&gt;public/&lt;/code&gt;文件夹之外的所有文件，另一个放我们生成的静态网站，也就是&lt;code&gt;public/&lt;/code&gt;的内容。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Github上创建repo &lt;code&gt;&amp;lt;your-project&amp;gt;-hugo&lt;/code&gt;，托管Hugo的输入文件。&lt;/li&gt;
&lt;li&gt;创建repo &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;，用于托管&lt;code&gt;public/&lt;/code&gt;文件夹，注意这里的repo名字一定要用自己的用户名，才会被当作是个人主页。&lt;/li&gt;
&lt;li&gt;clone your-project
&lt;code&gt;
$ git clone &amp;lt;&amp;lt;your-project&amp;gt;-hugo-url&amp;gt;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入your-project 目录
&lt;code&gt;
$ cd &amp;lt;your-project&amp;gt;-hugo
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删掉public目录（这个目录每次运行Hugo都会再次生成，不用担心）
&lt;code&gt;
$ rm -rf public
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把public/目录添加为submodule 与&lt;username&gt;.github.io同步
&lt;code&gt;
$ git submodule add git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加.gitignore文件，文件中写&lt;code&gt;public/&lt;/code&gt;，在同步&lt;code&gt;&amp;lt;your-project&amp;gt;-hugo&lt;/code&gt;时会忽略public文件夹&lt;/li&gt;
&lt;li&gt;下面是写好的一个script &lt;code&gt;deploy.sh&lt;/code&gt;，拷贝过去直接就能用，记得chmod +x deploy.sh加上运行权限。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi

# Push Hugo content 
git add -A
git commit -m &amp;quot;$msg&amp;quot;
git push origin master


# Build the project. 
hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add -A

# Commit changes.

git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back
cd ..

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等一小会儿（10分钟左右），你就能在&lt;a href=&#34;http://username.github.io/&#34;&gt;http://username.github.io/&lt;/a&gt; 这个页面看到你的网站了！每次更新网站或者写了新文章，只需要运行./deploy.sh 发布就搞定了，简单吧？&lt;/p&gt;

&lt;p&gt;Github pages还支持域名绑定，三个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; repo的跟目录下添加&lt;code&gt;CNAME&lt;/code&gt;文件，文件里写上你的域名，不用加http://的开头。&lt;/li&gt;
&lt;li&gt;记下&lt;a href=&#34;http://username.github.io/&#34;&gt;http://username.github.io/&lt;/a&gt; 的ip地址。
&lt;code&gt;
$ ping username.github.io
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在你的域名管理中加上两条A记录，分别是www和@，记录指向&lt;a href=&#34;http://username.github.io/&#34;&gt;http://username.github.io/&lt;/a&gt; 的ip地址，也需要等一小会儿生效。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;更改字体服务商:d605f9890f3528aea462ac7515ece633&#34;&gt;更改字体服务商&lt;/h1&gt;

&lt;p&gt;我的博客模版里用的字体是从googleapis里获取的，国内访问会下载失败，把字体库改成360的。
找到&lt;code&gt;layouts/partials/head_includes.html&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#39;http://fonts.googleapis.com/css?family=Fjalla+One|Open+Sans:300&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其中的googleapis替换为useso就行了。&lt;/p&gt;

&lt;p&gt;教程会根据我的博客遇到的问题继续更新。&lt;/p&gt;

&lt;h1 id=&#34;增加网站分析:d605f9890f3528aea462ac7515ece633&#34;&gt;增加网站分析&lt;/h1&gt;

&lt;p&gt;使用网站分析可以帮助我们更好地了解博客的读者和流量来源，我使用了&lt;a href=&#34;http://tongji.baidu.com&#34;&gt;百度统计&lt;/a&gt;和&lt;a href=&#34;http://www.google.cn/webmasters/&#34;&gt;谷歌统计&lt;/a&gt;，注册帐号后只需要按照提示在模板中加入相应的script代码就可以了。&lt;/p&gt;

&lt;h1 id=&#34;写在最后:d605f9890f3528aea462ac7515ece633&#34;&gt;写在最后&lt;/h1&gt;

&lt;p&gt;注意：
 1. 在每篇文章会有个头部：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
date: 2015-11-29T00:30:03+08:00
description: &amp;quot;&amp;quot;
tags: [&amp;quot;gdb&amp;quot;,&amp;quot;gdb调试&amp;quot;,&amp;quot;gdb调试方法&amp;quot;,&amp;quot;多线程调试&amp;quot;,&amp;quot;网站&amp;quot;]
title: &amp;quot;gdb调试方法精粹&amp;quot;
topics: []
draft: false
url: /post/2015-11-29-8
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在最后的url字段属于站内引用，因此每一篇文章的url的值是不能相同的&lt;/p&gt;

&lt;h1 id=&#34;参考:d605f9890f3528aea462ac7515ece633&#34;&gt;参考&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://gohugo.io/overview/introduction/&#34;&gt;Hugo docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ipn.li/kernelpanic/3/&#34;&gt;《内核恐慌》静态网站生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.udemy.com/build-static-sites-in-seconds-with-hugo/&#34;&gt;Build Static Sites in Seconds with Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/&#34;&gt;Setting up a custom domain with GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文转自&lt;a href=&#34;http://nanshu.wang/&#34;&gt;nanshu.wang&lt;/a&gt;的&lt;a href=&#34;http://nanshu.wang/post/2015-01-31/&#34;&gt;gitpage&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>gdb多线程调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-5</link>
      <pubDate>Thu, 29 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-5</guid>
      <description>&lt;p&gt;gdb对于多线程程序的调试有如下的支持：
　　
　　线程产生通知：在产生新的线程时, gdb会给出提示信息
　　(gdb) r
　　Starting program: /root/thread
　　[New Thread 1073951360 (LWP 12900)]
　　[New Thread 1082342592 (LWP 12907)]&amp;mdash;以下三个为新产生的线程
　　[New Thread 1090731072 (LWP 12908)]
　　[New Thread 1099119552 (LWP 12909)]
　　
　　查看线程：使用info threads可以查看运行的线程。
　　(gdb) info threads
　　 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　* 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb)
　　
　　
　　注意，行首的蓝色文字为gdb分配的线程号，对线程进行切换时，使用该该号码，而不是上文标出的绿色数字。
　　
　　另外，行首的红色星号标识了当前活动的线程
　　
　　切换线程：使用 thread THREADNUMBER 进行切换，THREADNUMBER 为上文提到的线程号。下例显示将活动线程从 1 切换至 4。
　　(gdb) info threads
　　 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　* 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb) thread 4
　　[Switching to thread 4 (Thread 1099119552 (LWP 12940))]#0 0xffffe002 in ?? ()
　　(gdb) info threads
　　* 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb)
　　
　　
　　 以上即为使用gdb提供的对多线程进行调试的一些基本命令。另外，gdb也提供对线程的断点设置以及对指定或所有线程发布命令的命令。
　　
　　 初次接触gdb下多线程的调试，往往会忽视gdb中活动线程的概念。一般来讲，在使用gdb调试的时候，只有一个线程为活动线程，如果希望得到其他的线程的输出结果，必须使用thread命令切换至指定的线程，才能对该线程进行调试或观察输出结果。&lt;/p&gt;

&lt;p&gt;一直对GDB多线程调试接触不多，最近因为工作有了一些接触，简单作点记录吧。&lt;/p&gt;

&lt;p&gt;先介绍一下GDB多线程调试的基本命令。&lt;/p&gt;

&lt;p&gt;info threads
显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。
前面有*的是当前调试的线程。&lt;/p&gt;

&lt;p&gt;thread ID
切换当前调试的线程为指定ID的线程。&lt;/p&gt;

&lt;p&gt;break thread_test.c:123 thread all
在所有线程中相应的行上设置断点&lt;/p&gt;

&lt;p&gt;thread apply ID1 ID2 command
让一个或者多个线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;thread apply all command
让所有被调试线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;set scheduler-locking off|on|step
估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。
off 不锁定任何线程，也就是所有线程都执行，这是默认值。
on 只有当前被调试程序会执行。
step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;

&lt;p&gt;在介绍完基本的多线程调试命令后，大概介绍一下GDB多线程调试的实现思路。&lt;/p&gt;

&lt;p&gt;比较主要的代码是thread.c，前面介绍的几个命令等都是在其中实现。
thread_list这个表存储了当前可调试的所有线程的信息。
函数add_thread_silent或者add_thread(不同版本GDB不同)用来向thread_list列表增加一个线程的信息。
函数delete_thread用来向thread_list列表删除一个线程的信息。
上面提到的这2个函数会被有线程支持的target调用，用来增加和删除线程，不同的OS对线程的实现差异很大，这么实现比较好的保证了GDB多线程调试支持的扩展性。
函数info_threads_command是被命令info threads调用的，就是显示thread_list列表的信息。
函数thread_command是被命令thread调用，切换当前线程最终调用的函数是switch_to_thread，这个函数会先将当前调试线程变量inferior_ptid，然后对寄存器和frame缓冲进行刷新。
函数thread_apply_command被命令thread apply调用，这个函数的实际实现其实很简单，就是先切换当前线为指定线程，然后调用函数execute_command调用指定函数。&lt;/p&gt;

&lt;p&gt;比较特别的是set scheduler-locking没有实现在thread.c中，而是实现在控制被调试程序执行的文件infrun.c中。
对其的设置会保存到变量scheduler_mode中，而实际使用这个变量的函数只有用来令被调试程序执行的函数resume。在默认情况下， 传递给target_resume的变量是resume_ptid，默认情况下其的值为RESUME_ALL，也就是告诉target程序执行的时候所有 被调试线程都要被执行。而当scheduler_mode设置为只让当前线程执行的时候，resume_ptid将被设置为inferior_ptid， 这就告诉target只有inferior_ptid的线程会被执行。&lt;/p&gt;

&lt;p&gt;最后特别介绍一下Linux下多线程的支持，基本的调试功能在linux-nat.c中，这里有对Linux轻量级别进程本地调试的支持。但是其 在调试多线程程序的时候，还需要对pthread调试的支持，这个功能实现在linux-thread-db.c中。对pthread的调试要通过调用 libthread_db库来支持。
这里有一个单独的target&amp;rdquo;multi-thread&amp;rdquo;，这个target有2点很特别:
第一，一般target的装载是在调用相关to_open函数的时候调用push_target进行装载。而这个target则不同，在其初始化 的时候，就注册了函数thread_db_new_objfile到库文件attach事件中。这样当GDB为调试程序的动态加载库时候attach库文 件的时候，就会调用这个函数thread_db_new_objfile。这样当GDB装载libpthread库的时候，最终会装载 target&amp;rdquo;multi-thread&amp;rdquo;。
第二，这个target并没有像大部分target那样自己实现了全部调试功能，其配合linux-nat.c的代码的功能，这里有一个target多层结构的设计，要介绍的比较多，就不详细介绍了。&lt;/p&gt;

&lt;p&gt;最后介绍一下我最近遇见的一个多线程调试和解决。&lt;/p&gt;

&lt;p&gt;基本问题是在一个Linux环境中，调试多线程程序不正常，info threads看不到多线程的信息。
我先用命令maintenance print target-stack看了一下target的装载情况，发现target&amp;rdquo;multi-thread&amp;rdquo;没有被装载，用GDB对GDB进行调试，发现在 函数check_for_thread_db在调用libthread_db中的函数td_ta_new的时候，返回了TD_NOLIBTHREAD，所 以没有装载target&amp;rdquo;multi-thread&amp;rdquo;。
在时候我就怀疑是不是libpthread有问题，于是检查了一下发现了问题，这个环境中的libpthread是被strip过的，我想可能 就是以为这个影响了td_ta_new对libpthread符号信息的获取。当我换了一个没有strip过的libpthread的时候，问题果然解决 了。
最终我的解决办法是拷贝了一个.debug版本的libpthread到lib目录中，问题解决了。
多线程如果dump，多为段错误，一般都涉及内存非法读写。可以这样处理，使用下面的命令打开系统开关，让其可以在死掉的时候生成core文件。&lt;br /&gt;
ulimit -c unlimited
这样的话死掉的时候就可以在当前目录看到core.pid(pid为进程号)的文件。接着使用gdb:
gdb ./bin ./core.pid
进去后，使用bt查看死掉时栈的情况，在使用frame命令。&lt;/p&gt;

&lt;p&gt;还有就是里面某个线程停住，也没死，这种情况一般就是死锁或者涉及消息接受的超时问题(听人说的，没有遇到过)。遇到这种情况，可以使用：
gcore pid （调试进程的pid号）
手动生成core文件，在使用pstack(linux下好像不好使)查看堆栈的情况。如果都看不出来，就仔细查看代码，看看是不是在if，return，break，continue这种语句操作是忘记解锁，还有嵌套锁的问题，都需要分析清楚了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>孤独的反思——读《孤独六讲》</title>
      <link>http://sun-friderick.github.io/post/2014-09-15</link>
      <pubDate>Mon, 15 Sep 2014 00:00:00 UTC</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2014-09-15</guid>
      <description>&lt;p&gt;第一次知道蒋勋，是默存同学送给我的一本《蒋勋的卢浮宫》。我对西方美术完全没有了解，这本书一开始我也很不以为然。蒋勋用他自己的美学视角，写的一本卢浮宫导游书。读一遍下来我一直以为蒋勋是一位年轻的艺术家，因为他的文字就像是一个人在你身旁慢慢说话，没有任何艰深难懂的地方，把我所以为很难懂的美术讲成了一个个平常的故事，不夸张也不造作，有一种原来美术是这样来理解的恍然大悟。&lt;/p&gt;

&lt;p&gt;后来，开始慢慢听《蒋勋说红楼梦》，才知道他原来主要是研究文学。也多亏他，我才意识到《红楼梦》是多么精彩而伟大的小说，以前走马观花的阅读失去了多少趣味。他讲话，总是觉察不出他的年龄，常常诧异怎么年轻人的心态他这么懂。我几乎和上一辈的人没有过深入的交谈和对话，但读蒋勋的文字就常常很高兴，觉得上一辈的也有有趣的，懂我们的人。&lt;/p&gt;

&lt;p&gt;毕业旅行去了台北，在诚品书店找到了《孤独六讲》，便买回来读。陌生的竖排繁体的排版，读起来却没有什么障碍。我记得一个大学同学，常常在地铁上读竖排的漫画书，他说竖排最适合在地铁里看，因为可以一只手拿书左右滚着看，另一只手可以去扶扶手。&lt;/p&gt;

&lt;p&gt;书的开头一段是坐在诚品书店里读的，里面写到他常常看到报上的新闻，会想到当事人的心里的孤独，全世界都在谈论你，却没有人愿意去你的心底看一看的感受，是多么巨大的孤独。当时我特别惊讶，因为我也有过同样的感觉，会想要去理解别人内心的孤独感，我从来没对人说过，却在这本书里读到了。这本从头读到尾，这样的感觉都一直伴随着我。&lt;/p&gt;

&lt;p&gt;蒋勋是赞颂孤独的，他一开头就说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“孤独没有什么不好。使孤独变得不好，是因为你害怕孤独。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在情欲孤独里，他认为青少年时期必须经过一个孤独的阶段，必须在这个阶段里感受到完整的自我，才能发展出完整的感情。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“当你在暗恋一个人时，你的生命正在转换，从中发现出完美的自我。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;他提到，儒家文化一直以来是阻挡孤独和完整自我形成的最大障碍，这种集体主义的思想抹杀了独立个体的感情，不允许孤独存在。我接受我的情欲孤独，是因为我的感情要代表我的自我，而不要去代表社会所认同的我。&lt;/p&gt;

&lt;p&gt;语言孤独让我感到害怕，你看见一千张嘴在那里说话，却没有一只耳朵在听。你发出了声音，却永远地消失在无尽的黑暗里。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“看一本小说，不要看它写了什么，要看他没有写什么。如同你听朋友说话，不要听他讲了什么，要听他没有讲什么。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我每次放假回家，都不愿意和父母去饭后散步，不是因为我懒也不是因为不愿意陪伴父母，而是我不愿意每次遇到父母的朋友我都必须毕恭毕敬地打声毫无意义的招呼。语言的孤独在于我们嘴里的话都没有了意义，只有马斯洛需求层次最低一层的寒暄。最近班级聚餐时，邻座坐着一个和我气味相投的男生，和他很有话聊的时候，语言仿佛才有了意义，不是室友碎碎念周末进城见了谁吃了什么的话，而是平时的孤独感仿佛有人可以理解。&lt;/p&gt;

&lt;p&gt;革命孤独对于我是全新的话题。大概是被应试教育荼毒的原因，一提起革命我就老是想起高中的历史课本，里面一本正经告诉你革命伟大在哪里，我们该如何感恩，却从没有提起过革命者的思想，他们为何会在年轻时为革命献身，他们理解的革命是什么？读了秋瑾的故事，理解她的内心，才会体会其中的感人，才会觉得会掉下泪来。他们从时代走出，将生命置之度外的超脱，是他们背负的巨大的孤独。蒋勋提到了托尔斯泰临终前留下的一封信，信上说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“我决定放弃我的爵位，我决定放弃我的土地，我决定要土地上所有的农奴恢复自由人身份。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;他写到：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“我觉得这是托尔斯泰最了不起的作品，他让我们看到革命是对自己的革命，他所要颠覆的不是外在的体制和阶级，而是颠覆内在的道德不安感。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时我才反应过来，这些作品之所以令我着迷，是因为它在颠覆一些我不认同的东西，说出了我想说出的话。&lt;/p&gt;

&lt;p&gt;暴力孤独说的不仅仅是字面上的暴力，因为暴力的形式有很多，语言可以是暴力，感情可以是暴力，爱也可能是暴力。暴力是一种美学，因为暴力的源自于我们生存的本能，在弱肉强食，优胜劣汰中保存在了我们基因里。蒋勋用他的一篇小说《妇人明月的手指》的创作来说明文明社会中的暴力，这本小说读来让人不寒而栗，手指被砍断的暴力反而并没有大学生，出租车司机，警察的表现更让人害怕。而这是法律所不能管辖的暴力，也是我们所有人无时无刻无意识会施加的暴力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“当你强势到某一个程度时，你不会意识到强势到了某个程度，不管是阶级，国家或是族群，本身就会构成暴力。但要产生这些自觉，并不是那么容易。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;蒋勋认为思维孤独是最大的一个孤独，因为思维孤独是最难以坚持和保留的。我们的儒家文化里没有哲学的思辨，只有已经规定好的是非伦理。我常常会质疑很多周围朋友的观点：比如女生不用太努力，比如什么年龄一定要结婚要有小孩，还有些是我还不敢说出来的观点。而这样的讨论往往会归总到一句大家耳熟能详的熟语，放佛几千年传来下的话一定没错似的，我竟然找不到反驳的理由。我佩服那些敢作那0.01%的人，害怕永远只做99.99%的人，就像书里说到在某个特殊时期，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“有人讲说要怎么样怎么样的时候，你先不要动，先观察，然后发现有一半以上的人都这样讲的话，你就开始这样子讲，然后你千万不要变成那样最后的几个和最前面的几个，因为可能倒霉，靠错边就不好了。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不知道这一段在大陆出版的书里有没有被删去呢？还有一段很喜欢的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“孤独一定要慢，当你急迫地从A点到B点时，所有的思考都停止。生命很简单，也是从A点到B点，由生到死。如果你一生都很忙碌，就表示你一生什么都没有看到，快速地从A点到了B点。难道生命的开始就是为了死亡吗？还是为了活着的每一分每一秒。与孤独相处的时候，可以多一点思维的空间，生命的过程会不会更细腻一点？”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伦理孤独是很多时候让我感到痛苦的部分，因为我对这个社会的伦理划分的方式并不满意，或者我认为我们应该可以有自己的伦理选择，才能谈得上个人的完整。蒋勋是这样说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“我一直期盼我们的社会能建立一个新的伦理，是以独立的个人为单位，先成为一个可以充分思考，完整的个人，再进而谈其他的相对伦理的关系。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我明白了我为什么会对《霍乱时期的爱情》里费尔明娜和《归来》里冯婉瑜抛开子女的爱情感到伟大，是因为我认为的爱情，是纯粹的，抛开伦理的，甚至是最重要的亲子观的。我向往的是不带有伦理的感情，那种自由，透明，没有束缚的表达，而不是伦理关系下迎合社会的结合。&lt;/p&gt;

&lt;p&gt;这本书谈论的是个人，个人的思想，个人的孤独。同样是谈论人，却比上课学的那些心理学，组织行为学更有用，更打动人。作为社会人，我们通常关注的和在社会关系网中和别人的连系的那些表示关系的边，却忽略了人首先是作为独立的点的存在，才会发展出边。我们忽略了自己的和别人的独立性，忽略了在社会中我们的孤独，让孤独变成不可以谈论，不可以表现，不可以赞颂的东西。但我们需要孤独，需要它来使自己更完美。整本书讲到的是我们作为社会人的悲哀，作为社会人的孤独。情欲，革命，暴力等的本质都是孤独。必须承认孤独，才能成为社会人。蒋勋在伦理孤独的最后说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;期盼每个人都能在破碎重整的过程中找回自己的伦理孤独。&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;希望我能在破碎重整的过程中找回自我。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《恋爱的犀牛》</title>
      <link>http://sun-friderick.github.io/post/2014-01-09</link>
      <pubDate>Thu, 09 Jan 2014 00:00:00 UTC</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2014-01-09</guid>
      <description>&lt;p&gt;看现场的话剧比书本上的对话明朗了许多，说到最后这也不过是一个“我爱你，你不爱我”的故事。用最近从《程序员的数学》上学来的分组方法，爱情的分组不外乎是一下三种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我爱你，你也爱我&lt;/li&gt;
&lt;li&gt;我爱你，你不爱我&lt;/li&gt;
&lt;li&gt;你爱我，我也爱你&lt;/li&gt;
&lt;li&gt;你爱我，我不爱你&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，1,3都是Happy ending（如果没有婆媳矛盾，身世之谜种种阻挠），然而大部分陷入爱情的迷阵里的青年，都在2,4里苦苦挣扎：有的有幸在2,4的循环里进入了1,3的接口，终止了自己的不幸；有的却在这个循环里咒骂爱情的无情，不得逃脱。&lt;/p&gt;

&lt;p&gt;以前我总觉得，聪明的人一定会冲着2,4move on：要么从2到1，积极努力不行再换个人；要么从4到3，自己的信再铁石心肠也会有被打动的一天吧。然而《恋爱的犀牛》却不是讲着完全相反的故事，爱着明明的马路不停得重复这句告白：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一切白的东西和你相比都成了黑墨水而自惭形秽，一切无知的鸟兽因为不能说出你的名字而绝望万分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;爱着成飞的明明在受伤时说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我还要对他顺从到哪一天，我真不知道我还有什么事不能为他做！这个可恨的人！我要是不爱他了，该多好。我眼睛里带着爱情就像是脑门上带着奴隶的印记，他走到哪儿我就要跟到哪儿！你能想象吗？只要跟着他我就满足了。真是发疯，怎么样才能不再爱他呢？嗯？这样下去我会受不了的！可我要是不爱他了，活着还有什么意思呢？我从来没见过像他这样的男人，我下了多少次决心，可一看见他，完蛋了…….&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;他们两人固执得不肯从2,4里跳出死循环，死死抓住那句“我爱你”或“我不爱你”，其余什么都不要。大概大部分人都是自私而愚蠢的，才会造成怎么多爱情悲剧的存在：“我”是自私的，“爱”或“不爱”是愚蠢的，“你”和“我”都是悲剧的。没有一个好下场的故事，为什么又要死死把自己扣进那个循环呢。&lt;/p&gt;

&lt;p&gt;大概“爱的伟大”可以解释这个现象。“爱”是人类最纯洁，最无私，最高尚的一种情感，在柏拉图的《会饮》里，Agathon对爱神进行了最美妙的赞美：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Therefore, Phaedrus, I say of Love that he is the fairest and best in himself, and the cause of what is fairest and best in all other things. And there comes into my mind a line of poetry in which he is said to be the god who&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Gives peace on earth and calms the stormy deep,&lt;/p&gt;

&lt;p&gt;Who stills the winds and bids the sufferer sleep.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is he who empties men of disaffection and fills them with affection, who makes them to meet together at banquets such as these: in sacrifices, feasts, dances, he is our lord-who sends courtesy and sends away discourtesy, who gives kindness ever and never gives unkindness; the friend of the good, the wonder of the wise, the amazement of the gods; desired by those who have no part in him, and precious to those who have the better part in him; parent of delicacy, luxury, desire, fondness, softness, grace; regardful of the good, regardless of the evil: in every word, work, wish, fear-saviour, pilot, comrade, helper; glory of gods and men, leader best and brightest: in whose footsteps let every man follow, sweetly singing in his honour and joining in that sweet strain with which love charms the souls of gods and men. Such is the speech, Phaedrus, half-playful, yet having a certain measure of seriousness, which, according to my ability, I dedicate to the god.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;既然古希腊的这位伟大的喜剧家都对爱进行了这样的最高赞誉，那爱一定是没错的，是会带来美德和幸福的。爱既然没错，我的“爱”也一定没错，我的“爱”驱使我做的事也一定没错。爱是多么正确和美妙啊，大部分人一定是这样想的，因为我们老能听见电视里不肯放手的男二悲催的台词：&lt;em&gt;我爱你难道有错吗？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;奇怪的是，《恋爱的犀牛》里，明明出场时却是这样一段质疑爱的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我是说“爱”！那感觉是从哪来的？从心脏、肝脾、血管，哪一处内脏里来的？也许那一天月亮靠近了地球，太阳直射北回归线，季风送来海洋的湿气使你皮肤润滑，蒙古形成的低气压让你心跳加快。或者只是你来自你心里的渴望，月经周期带来的骚动，他房间里刚换的灯泡，他刚吃过的橙子留在手指上的清香，他忘了刮的胡子刺痛了你的脸……这一切作用下神经末梢麻酥酥的感觉，就是所说的爱情……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;倘若爱情的产生仅仅是周围环境而引起的内啡肽的化学变化，爱的本质似乎就没有Agathon说的那样高尚。一瞬间而且大部分紧靠外貌被吸引的异性，慢慢作用催生出的那个东西，被称之为爱。既然爱可以慢慢滋长，它也必然可以慢慢消退。由此永远陷入爱情2,4的死循环的判断是不靠谱的。世上一定要这样的人，《霍乱时期的爱情》里阿里萨就是这样，等待了几十年的爱情，而且非得等到心爱人老公死掉了才有机会，这样的浪漫主义其实是可悲的。&lt;/p&gt;

&lt;p&gt;《恋爱的犀牛》里大仙说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;爱情跟喜剧、体育、流行音乐没什么不同，是为了让人活得轻松愉快的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这话听上去又轻浮又没责任心，然而比起那些陷入循环要死要活的爱情来说，我宁愿轻松一点，也不愿把原本应该被歌颂的爱变成我的苦难。&lt;/p&gt;

&lt;p&gt;《会饮》里还说了，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Love is simply the name for the desire and pursuit of the whole.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Whole是需要两人在一起的，别固执也别强求。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>经过检验的应用软件The examined software</title>
      <link>http://sun-friderick.github.io/post/2013-01-04</link>
      <pubDate>Fri, 04 Jan 2013 00:00:00 UTC</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2013-01-04</guid>
      <description>&lt;p&gt;在图书馆看关于苏格拉底的一篇文章《The examined life》，越看越觉得人生不值得过。不过对于应用软件来说，好像道理也是一样，套用苏格拉底的话来说就是 The unexaminedsoftware is not worth applicating.未经检验的软件是不值得应用的软件。按下win键发现还是有好些软件在电脑里的存活时间挺长了，也可以算是经过检验了，心血来潮数了数。（排名不分先后）&lt;/p&gt;

&lt;p&gt;1.Ginger
英文写作纠错工具，语法检查还行，比较好的是能够根据上下文给出用词的建议。&lt;/p&gt;

&lt;p&gt;2.ManicTime
可以统计电脑使用的时间及应用分类，比如这个月花了多少时间写paper，花了多少时间上网，花了多少时间打游戏。除了对application的统计，还会根据不同的file统计，也就是说不同文件以及不同域名的网站也会区别，可以看到多少时间刷豆瓣，多少时间逛淘宝，某篇论文写了多少时间。&lt;/p&gt;

&lt;p&gt;3.Bing词典
简单好用，单词本、例句搜索和近义词的功能都做得很好，缺点是例句不能直接链接到原文。（update：最新版2.1已经有这个功能了）&lt;/p&gt;

&lt;p&gt;4.OneNote
Office的笔记软件，分类十分方便，习惯office操作的话很容易上手，我觉着这个比evernote好用。OneNote有个强大的功能是可以用ORC技术直接把图片里的文字复制出来，支持中英文，对于有些复制不了的网站很是有用。缺点是同步不好使基本只能在一个电脑上用。&lt;/p&gt;

&lt;p&gt;5.MovieMaker
视频制作软件，看着其实这个软件我能用到的功能基本都有，而且速度很快不耗内存，导出的质量也蛮高，配合着PowerPoint生成的动画其实可以出很好的效果，做个小视频送人做生日礼物什么的效率很高。&lt;/p&gt;

&lt;p&gt;6.曦力音视频转换专家
听名字就知道是干嘛使的了，干净且好用，拿来扒视频的音频超快。&lt;/p&gt;

&lt;p&gt;7.腾讯TM2009
无广告无花里胡哨的功能，内存占用小，蓝色的图标很萌，这个软件是支撑我用QQ的动力。&lt;/p&gt;

&lt;p&gt;8.Everything
搜索文件的工具，Windows搜索巨巨巨巨巨慢，这个会快一点。&lt;/p&gt;

&lt;p&gt;9.SublimeText2
写代码的，其实我只用这个来写过HTML，弱爆了。&lt;/p&gt;

&lt;p&gt;差不多就这些，数完了好用的软件，又想起了些不得不吐槽的unexamined软件：
人人桌面（垃圾）、人人极速相册（一插U盘就怂恿传图是什么劲啊）、360安全卫士（不是360杀毒）、所有IE内核浏览器（IE6开什么网页的样式都一团糟）、SPSS（太慢了不好看）、绘声绘影（……）、暴风影音（……）、阿里旺旺（……）&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
