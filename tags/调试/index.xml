<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>调试 on Frederick&#39;s blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://sun-friderick.github.io/tags/%E8%B0%83%E8%AF%95/</link>
    <language>en-us</language>
    <author>Frederick Sun</author>
    <copyright>Copyright (c) 2015, Frederick Sun; all rights reserved.</copyright>
    <updated>Sun, 29 Nov 2015 00:30:03 CST</updated>
    
    <item>
      <title>gdb调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-7</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-7</guid>
      <description>

&lt;p&gt;#gdb 跟踪调试命令整理&lt;/p&gt;

&lt;h1 id=&#34;gdb常用命令:27ab83445e035e5774461847bd2aa236&#34;&gt;gdb常用命令：&lt;/h1&gt;

&lt;p&gt;|                命令        | 描述           | Cool  |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:|&lt;br /&gt;
| backtrace（或bt）    |    查看各级函数调用及参数，运行时的堆栈   |&lt;br /&gt;
| finish                              |    连续运行到当前函数返回为止，然后停下来等待命令    |&lt;br /&gt;
| frame（或f）帧编号  |   选择栈帧       |&lt;br /&gt;
| info（或i） locals       |   查看当前栈帧局部变量的值   |&lt;br /&gt;
| list（或l）                     |    列出源代码，接着上次的位置往下列，每次列10行       |&lt;br /&gt;
| list 行号                          |   列出从第几行开始的源代码        |&lt;br /&gt;
| list 函数名                     |    列出某个函数的源代码   |&lt;br /&gt;
| next（或n）                 |    单步调试，执行下一行语句        |&lt;br /&gt;
| print（或p）                |    打印表达式的值，通过表达式可以修改变量的值或者调用函数     |&lt;br /&gt;
| quit（或q）                 |     退出gdb调试环境  |&lt;br /&gt;
| set var                           |     修改变量的值       |&lt;br /&gt;
| start                               |     开始执行程序，停在main函数第一行语句前面等待命令       |&lt;br /&gt;
| step（或s）                 |     执行下一行语句，如果有函数调用则进入到函数中  |&lt;/p&gt;

&lt;p&gt;#GDB 调试&lt;/p&gt;

&lt;p&gt;要进行调试程序首先要生成一个含有调试信息的执行程序命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc(g++) -g -o 文件名 源文件.c(源文件.cpp)
gcc(g++) -ggdb3 -o 文件名 源文件.c(源文件.cpp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时便会生成一个含有调试信息的可执行文件,然后便可以用 gdb 去调试这个程序了,进入调试程序命令,但是如果用 gdb 去调试一个未包含调试信息的可执行文件则会发生错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb 执行文件名(含调试信息)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#运行 GDB&lt;/p&gt;

&lt;p&gt;##运行 gdb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb &amp;lt;program&amp;gt; -- program也就是你的执行文件,一般在当然目录下.
gdb &amp;lt;program&amp;gt; core -- 用 gdb 同时调试一个运行程序和 core 文件,core 是程序非法执行后 core dump 后产生的文件.
gdb &amp;lt;program&amp;gt; &amp;lt;PID&amp;gt; -- 调试正在运行的程序. program 为需要调试的程序文件, PID 为当前正在运行的程序.或是先用 gdb &amp;lt;program&amp;gt; 关联上源代码进入 gdb,后用 attach 命令来挂接进程的 PID.并用 detach 来取消挂接的进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 启动常用的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从指定文件中读取符号表
    -symbols &amp;lt;file&amp;gt;
    -s &amp;lt;file&amp;gt;
从指定文件中读取符号表信息,并把他用在可执行文件中
    -se file
调试时 core dump 的 core 文件
    -core &amp;lt;file&amp;gt;
    -c &amp;lt;file&amp;gt;
加入一个源文件的搜索路径.默认搜索路径是环境变量中 PATH 所定义的路径
    -directory &amp;lt;directory&amp;gt;
    -d &amp;lt;directory&amp;gt;
设置启动时候参数
    --args arglist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 帮助文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help -- 查看 gdb 的命令种类
help &amp;lt;CmdType&amp;gt; -- 查看 CmdType 种类的 gdb 命令
apropos &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 的相关命令
info &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 调试信息
show &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord gdb 本身设置信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 中运行 unix 的 shell 程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shell &amp;lt;command string&amp;gt; -- 调用 unix 的 shell 来执行 &amp;lt;command string&amp;gt;,环境变量 shell 中定义的 unix 的 shell 将会被用来执行 &amp;lt;command string&amp;gt;,如果 shell 没有定义,那就使用 unix 的标准 shell：/bin/sh.(在 windows 中使用 command.com 或 cmd.exe)
make &amp;lt;make-args&amp;gt; -- 等价于 “shell make &amp;lt;make-args&amp;gt;”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##历史记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当你用 gdb 的 print 查看程序运行时的数据时,你每一个 print 都会被 gdb 记录下来.gdb 会以 $1, $2, $3 ...这样的方式为你每一个 print 命令编上号.于是,你可以使用这个编号访问以前的表达式,如 $1.这个功能所带来的好处是,如果你先前输入了一个比较长的表达式,如果你还想查看这个表达式的值,你可以使用历史记录来访问,省去了重复输入.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##启动程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run &amp;lt;arg ...&amp;gt; -- 启动程序,&amp;lt;arg ...&amp;gt; 为程序运行时候需要输入的参数.也可用 set args 命令去设置运行参数.简写为 r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 环境设置&lt;/p&gt;

&lt;p&gt;##gdb 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置显示选项
    地址
        set print address &amp;lt;on/off&amp;gt; -- 打开地址输出,当程序显示函数信息时,gdb会显出函数的参数地址.系统默认为打开.
        show print address -- 查看 print address 选项信息
    数组元素单独行显示
        set print array &amp;lt;on/off&amp;gt; -- 打开时数组显示时,每个元素占一行,如果不打开的话,每个元素则以逗号分隔.这个选项默认是关闭的.
        show print array -- 查看 print array 选项信息
    显示数组元素显示
        set print elements &amp;lt;number-of-elements&amp;gt; -- 设置数组的显示的最大长度,设置为 0,则表示不限制.
        show print elements -- 查看 print elements 选项信息.
    设置字符串显示
        set print null-stop &amp;lt;on/off&amp;gt; -- 如果打开那么当显示字符串时,遇到结束符则停止显示.这个选项默认为 off.
        show print null-stop -- 查看 print null-stop 选项信息
    设置结构体变量显示
        set print pretty &amp;lt;on/off&amp;gt; -- 结构体优雅显示
        show print pretty -- 查看 gdb 是如何显示结构体的.
    设置字符显示
        set print sevenbit-strings &amp;lt;on/off&amp;gt; -- 符显示,是否按“/nnn”的格式显示,如果打开,则字符串或字符数据按/nnn显示,如“/065”.
        show print sevenbit-strings -- 查看字符显示开关是否打开.
    设置联合体显示
        set print union &amp;lt;on/off&amp;gt; -- 设置显示结构体时,是否显式其内的联合体数据.
        show print union -- 查看联合体数据的显示方式
    设置对象显示
        set print object &amp;lt;on/off&amp;gt; -- 在 C++ 中,如果一个对象指针指向其派生类,如果打开这个选项,gdb 会自动按照虚方法调用的规则显示输出,如果关闭这个选项的话,gdb 就不管虚函数表了.这个选项默认是 off.
        show print object -- 查看对象选项的设置.
    设置静态成员显示
        set print static-members &amp;lt;on/off&amp;gt; -- 这个选项表示,当显示一个 C++ 对象中的内容是,是否显示其中的静态数据成员.默认是 on.
        show print static-members -- 查看静态数据成员选项设置.
    设置虚函数表显示
        set print vtbl &amp;lt;on/off&amp;gt; -- 当此选项打开时,gdb 将用比较规整的格式来显示虚函数表时.其默认是关闭的.
        show print vtbl -- 查看虚函数显示格式的选项.
设置运行程序的相关环境及其参数
    指定源文件的路径
        directory &amp;lt;dirname ... &amp;gt; -- 加一个源文件路径到当前路径的前面.如果你要指定多个路径,UNIX 下你可以使用“:”,Windows 下你可以使用“;”.缩写 dir
        directory -- 清除所有的自定义的源文件搜索路径信息.
        show directories -- 显示定义了的源文件搜索路径.
    运行参数
        set args -- 可指定运行时参数
        show args -- 命令可以查看设置好的运行参数
    运行环境
        path &amp;lt;dir&amp;gt; -- 可设定程序的运行路径
        show paths -- 查看程序的运行路径
        set environment varname=value -- 设置环境变量
        show environment [varname] -- 查看环境变量
    工作目录
        cd &amp;lt;dir&amp;gt; -- 相当于shell的cd命令
        pwd -- 显示当前的所在目录
    程序的输入输出
        info terminal -- 显示你程序用到的终端的模式
        tty -- 命令可以指写输入输出的终端设备
        重定向控制程序输出
    堆栈帧设置
        set backtrace &amp;lt;limit&amp;gt; -- 设置堆栈帧的最大显示数量,默认是没有限制
    调试模式
        set step-mode [on | off] -- step-mode 模式,于是,在进行单步跟踪时,程序不会因为没有debug信息而不停住.这个参数有很利于查看机器码. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 源码查看&lt;/p&gt;

&lt;p&gt;##显示源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list &amp;lt;linenum&amp;gt; -- 显示程序第 linenum 行的周围的源程序.
list &amp;lt;function&amp;gt; -- 显示函数名为 function 的函数的源程序.
list &amp;lt;filename:linenum&amp;gt; -- 哪个文件的哪一行.
list &amp;lt;filename:function&amp;gt; -- 哪个文件中的哪个函数.
list &amp;lt;offset&amp;gt; -- 当前行号的正/负 offset 偏移量那那行.
list -- 显示当前行后面的源程序.
list - -- 显示当前行前面的源程序.
list &amp;lt;first&amp;gt;, &amp;lt;last&amp;gt; -- 显示从 first 行到 last 行之间的源代码.若无 first 则显示从当前行到 last 之间的源代码.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##设置和获得显示源码的行数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set listsize &amp;lt;count&amp;gt; -- 设置一次显示源代码的行数.
show listsize -- 查看当前listsize的设置.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##搜索源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forward-search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
reverse-search &amp;lt;regexp&amp;gt; -- 向前面搜索.正则表达式为 regexp 的关键字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##源代码的内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info line &amp;lt;linenum&amp;gt; -- 查看行号为 linenum 源代码在内存中的地址.
info line &amp;lt;function&amp;gt; -- 查看函数在源代码在内存中的地址.
info line &amp;lt;filename:linenum&amp;gt; -- 查看 filename 文件的第 linenum 行源代码在内存中的地址.
info line &amp;lt;filename:function&amp;gt; -- 查看 filename 文件的 function 函数在源代码在内存中的地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看汇编代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disassemble -- 查看源程序的当前执行时的机器码,这个命令会把目前内存中的指令 dump 出来.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 停止点设置及维护&lt;/p&gt;

&lt;p&gt;##断点(BreakPoint)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置断点:(threadno 指定了线程的 ID,注意,这个 ID 是 gdb 分配的,可以通过 &amp;quot;info threads&amp;quot; 命令来查看正在运行程序中的线程信息)
    break thread &amp;lt;threadno&amp;gt; -- break命令没有参数时,表示在下一条指令处停住.
    break +offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的后面的 offset 行停住.(offiset 为自然数)
    break -offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的前面的 offset 行停住.(offiset 为自然数)
    break &amp;lt;linenum&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在指定行号停住.
    break filename:linenum thread &amp;lt;threadno&amp;gt; -- 在源文件filename的linenum行处停住.
    break &amp;lt;function&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在进入指定函数时停住.
    break filename:function thread &amp;lt;threadno&amp;gt; --在源文件filename的function函数的入口处停住.
    break *address -- 在程序运行的内存地址处停住.
    break ... thread &amp;lt;threadno&amp;gt; if &amp;lt;condition&amp;gt; -- ...可以是上述的参数,condition表示条件,在条件成立时停住.比如在循环境体中,可以设置break if i=100,表示当i为100时停住程序.
    tbreak -- 设置只停止一次的断点.用法和 break 类似
查看断点
    info breakpoints [n]
    info break [n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##观察点(WatchPoint) &amp;ndash; 观察点一般来观察某个表达式(变量也是一种表达式)的值是否有变化了,如果有变化,马上停住程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设在观察点
    watch &amp;lt;expr&amp;gt; -- 为表达式(变量)expr设置一个观察点.一量表达式值有变化时,马上停住程序.
    rwatch &amp;lt;expr&amp;gt; -- 当表达式(变量)expr被读时,停住程序.
    awatch &amp;lt;expr&amp;gt; -- 当表达式(变量)的值被读或被写时,停住程序.
查看观察点
    info watchpoints -- 列出当前所设置了的所有观察点.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##捕捉点(CatchPoint) &amp;ndash; 设置捕捉点来补捉程序运行时的一些事件.如:载入共享库(动态链接库)或是 C++ 的异常《/p&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置捕捉点
    catch &amp;lt;event&amp;gt; -- 当event发生时,停住程序.event可以是下面的内容：
        throw 一个 C++ 抛出的异常.(throw 为关键字)
        catch 一个 C++ 捕捉到的异常.(catch 为关键字)
        exec 调用系统调用 exec 时.(exec 为关键字,目前此功能只在 HP-UX 下有用)
        fork 调用系统调用 fork 时.(fork 为关键字,目前此功能只在 HP-UX 下有用)
        vfork 调用系统调用 vfork 时.(vfork 为关键字,目前此功能只在 HP-UX 下有用)
        load 或 load &amp;lt;libname&amp;gt; 载入共享库(动态链接库)时.(load 为关键字,目前此功能只在 HP-UX 下有用)
        unload 或 unload &amp;lt;libname&amp;gt; 卸载共享库(动态链接库)时.(unload 为关键字,目前此功能只在 HP-UX 下有用)
    tcatch &amp;lt;event&amp;gt; -- 只设置一次捕捉点,当程序停住以后,应点被自动删除.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##维护停止点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;清除停止点
    clear -- 所有的已定义的停止点.
    clear &amp;lt;function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;filename:function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
    clear &amp;lt;filename:linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
删除停止点
    delete [range] -- 删除停止点.其简写命令为 d.
禁用停止点
    disable [range] -- 禁用停止点
启用停止点
    enable [range] -- 启用停止点.
    enable once [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable count [rang] -- 启用停止点 count 次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable delete [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动删除.
停止条件维护 -- 以用 condition 命令来修改断点的条件.(只有break和watch命令支持if,catch目前暂不支持if)
    condition &amp;lt;bnum&amp;gt; &amp;lt;expression&amp;gt; -- 修改断点号为bnum的停止条件为expression.
    condition &amp;lt;bnum&amp;gt; -- 清除断点号为bnum的停止条件.
忽略停止点 N 次
    ignore &amp;lt;bnum&amp;gt; &amp;lt;count&amp;gt; -- 表示忽略断点号为 bnum 的停止条件 count 次.
为停止点设定运行命令
    格式:
    commands [bnum]
           ... command-list ...
           // 为断点号 bnumi写一个命令列表.当程序被该断点停住时,gdb 依次运行命令列表中的命令.
    end
    例如：
    break foo if x&amp;gt;0
    　　commands
           printf &amp;quot;x is %d/n&amp;quot;,x
           continue
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#信号(Signals)&lt;/p&gt;

&lt;p&gt;##添加信号处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle &amp;lt;signal&amp;gt; &amp;lt;keywords...&amp;gt;
在 gdb 中定义一个信号处理.信号 &amp;lt;signal&amp;gt; 可以以 SIG 开头或不以 SIG 开头,可以用定义一个要处理信号的范围(如：SIGIO-SIGKILL,表示处理从 SIGIO 信号到 SIGKILL 的信号,其中包括 SIGIO, SIGIOT, SIGKILL 三个信号),也可以使用关键字 all 来标明要处理所有的信号.一旦被调试的程序接收到信号,运行程序马上会被 gdb 停住,以供调试.其 &amp;lt;keywords&amp;gt; 可以是以下几种关键字的一个或多个.若没有 keywords 则查看奇信号的处理状态
    nostop -- 当被调试的程序收到信号时,gdb 不会停住程序的运行,但会打出消息告诉你收到这种信号.
    stop -- 当被调试的程序收到信号时,gdb 会停住你的程序.
    print -- 当被调试的程序收到信号时,gdb 会显示出一条信息.
    noprint -- 当被调试的程序收到信号时,gdb 不会告诉你收到信号的信息.
    pass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    noignore -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    nopass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    1gnore -- 当被调试的程序收到信号时,gdb 不会让被调试程序来处理这个信号.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看处理信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info signals -- 查看有哪些信号在被 gdb 检测中.
info handle -- 查看有哪些信号在被 gdb 检测中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 程序调试&lt;/p&gt;

&lt;p&gt;##恢复执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;continue [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
fg [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##单步调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step &amp;lt;count&amp;gt; -- 单步跟踪,如果有函数调用,它会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
next &amp;lt;count&amp;gt; -- 同样单步跟踪,如果有函数调用,他不会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跟踪机器指令
       与之一样有相同功能的命令是 “display/i $pc” ,当运行完这个命令后,单步跟踪会在打出程序代码的同时打出机器指令(也就是汇编代码)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stepi 或 si -- 单步跟踪一条机器指令,简写 si
nexti 或 ni -- 单步跟踪一条机器指令,简写 ni
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##函数调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;finish -- 运行程序,直到当前函数完成返回.并打印函数返回时的堆栈地址和返回值及参数值等信息.
return &amp;lt;expression&amp;gt; -- 使函数以 expression 表达式返回出去,忽略还没有执行的语句.若无返回 void 出去
call &amp;lt;expr&amp;gt; -- 表达式中可以一是函数,以此达到强制调用函数的目的.并显示函数的返回值,如果函数返回值是void,那么就不显示.
print 与 printf 也可以做到类似的功能和 call 的不同是,如果函数返回 void,call 则不显示,print 则显示函数返回值,并把该值存入历史数据中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##循环体调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until -- 可以运行程序直到退出循环体.简写 u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##修改变量值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print varname=var -- 修改被调试程序运行时的变量值
set var varname=value -- 修改被调试程序运行时的变变量
whatis varname -- 查看变量的类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跳转执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jump &amp;lt;linespec&amp;gt; -- 指定下一条语句的运行点.&amp;lt;linespce&amp;gt; 可以是文件的行号,可以是 file:line 格式,可以是 +num 这种偏移量格式.表式着下一条运行语句从哪里开始.
jump &amp;lt;address&amp;gt; -- 跳转到指定的程序内存地址运行.&amp;lt;address&amp;gt; 是代码行的内存地址.
注意
    jump 指令不会改变当前的程序栈中的内容,所以,当你从一个函数跳到另一个函数时,当函数运行完返回时进行弹栈操作时必然会发生错误.
    jump 命令只是改变了指令寄存器中的值.于是可以使用 “set $pc” 来更改跳转执行的地址.如： set $pc = 0x485
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##产生信号量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signal &amp;lt;signal&amp;gt; -- 产生一个 signal 信号.UNIX 的系统信号量通常从 1 到 15.所以 &amp;lt;signal&amp;gt; 取值也在这个范围.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 运行是数据&lt;/p&gt;

&lt;p&gt;##查看运行时数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print /&amp;lt;f&amp;gt; &amp;lt;expr&amp;gt; -- 查看当前程序的运行数据.简写 p.
    &amp;lt;expr&amp;gt; 是表达式
        @ -- 是一个和数组有关的操作符,在后面会有更详细的说明.在 @ 左边是数组的地址,右边是数组的长度,eg: array@len
        :: -- 指定一个在文件或是一个函数中的变量.
        {&amp;lt;type&amp;gt;} &amp;lt;addr&amp;gt; --表示一个指向内存地址&amp;lt;addr&amp;gt;的类型为type的一个对象.
    &amp;lt;f&amp;gt;是输出的格式
        d -- 按十进制格式显示变量.
        u -- 按十六进制格式显示无符号整型.
        o -- 按八进制格式显示变量.
        t -- 按二进制格式显示变量.
        a -- 按十六进制格式显示变量.
        c -- 按字符格式显示变量.
        f -- 按浮点数格式显示变量.
    注意:
        1.若出现变量重名,局部变量会隐藏全局变量.若想查看全局变量的值时,可以使用“::”操作符.
        2.可以通过这种形式指定你所想查看的变量 eg:
            *&#39;filename&#39;::variable
            *function::variable
printf &amp;quot;fmt&amp;quot;,arg,... -- 打印格式化字符灿 fmt.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;examine/&amp;lt;n/f/u&amp;gt; &amp;lt;addr&amp;gt; -- 来查看内存地址中的值.简写 x
    &amp;lt;n/f/u&amp;gt;
        n 是一个正整数,表示显示内存的长度,也就是说从当前地址向后显示几个地址的内容.
        f 表示显示的格式
            s -- 按字符串格式显示内存地址内容.
            i -- 查看内存地址的机器指令内容
            x -- 按十六进制格式显示地址内容.
            d -- 按十进制格式显示地址内容.
            u -- 按十六进制格式显示无符号整型.
            o -- 按八进制格式显示地址内容.
            t -- 按二进制格式显示地址内容.
            a -- 按十六进制格式显示地址内容.
            c -- 按字符格式显示地址内容.
            f -- 按浮点数格式显示地址内容.
        u 表示从当前地址往后请求的字节数,如果不指定的话,gdb默认是 4 个 bytes.
            b -- 表示单字节
            h -- 表示双字节
            w -- 表示四字节
            g -- 表示八字节
    &amp;lt;addr&amp;gt; 表示一个内存地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##自动显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置自动显示
    display/&amp;lt;fmt&amp;gt; &amp;lt;expr&amp;gt; -- 自动显示 expr 表达式
    display/&amp;lt;fmt&amp;gt; &amp;lt;addr&amp;gt; -- 自动显示 addr 地址
        fmt 表示显示的格式
        i -- 输出格式为机器指令码,也就是汇编.
        s -- 输出格式为字符串
删除自动显示
    undisplay &amp;lt;range&amp;gt; -- 删除自动显示
    delete display &amp;lt;range&amp;gt; -- 删除自动显示
启用和禁自动显示
    sable display &amp;lt;range&amp;gt; -- 禁用自动显示
    enable display &amp;lt;range&amp;gt; -- 启动自动显示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看栈信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backtrace &amp;lt;n&amp;gt; -- 擦看函数栈信息,简写 bt
    n 若是正数,只打印栈顶上 n 层的栈信息,
    若是负数,只打印栈顶下 n 层的栈信息,
    若无则打印当前的函数调用栈的所有信息
frame -- 会打印出这些信息:栈的层编号,当前的函数名,函数参数值,函数所在文件及行号,函数执行到的语句.
info frame -- 这个命令会打印出更为详细的当前栈层的信息,只不过,大多数都是运行时的内内地址.
info args -- 打印出当前函数的参数名及其值.
info locals -- 打印出当前函数中所有局部变量及其值.
info catch -- 打印出当前的函数中的异常处理信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##切换函数栈位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frame &amp;lt;n&amp;gt; -- 切换到第 n 层函数栈位置,简写 f.
p &amp;lt;n&amp;gt; -- 表示上面移动 n 层,可以不打 n,表示向上移动一层.
down &amp;lt;n&amp;gt; -- 表示向栈的下面移动 n 层,可以不打 n,表示向下移动一层.
select-frame &amp;lt;n&amp;gt; -- 类似 frame 命令.不打印出栈层信息.
up-silently &amp;lt;n&amp;gt; -- 类似 up 命令.不打印出栈层信息.
down-silently &amp;lt;n&amp;gt; -- 类似 down 命令.不打印出栈层信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看寄存器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info registers -- 查看寄存器的情况.(除了浮点寄存器)
info all-registers -- 查看所有寄存器的情况.(包括浮点寄存器)
info registers &amp;lt;regname&amp;gt; -- 查看所指定的寄存器的情况.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##线程查看与切换线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info threads -- 查看当前线程
thread &amp;lt;threadno&amp;gt; -- 切换到 threadno 的线程,简写 t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自定义命令&lt;/p&gt;

&lt;p&gt;##定义一个命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;格式
define comdName
      ...
end
条件语句
if cond_expr
      ...
else
      ...
end
循环语句
while cond_expr
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##定义一个命令的文档信息（在 help cmdName 的时候显示）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document cmdName
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看自定命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help user-define -- 查看所有用户自定义的命令
show user cmdName -- 查看用户定义的 cmdName 的命令.
help cmdName -- 查看用户自定义的 cmdName 的帮助文档
show max-user-call-depth -- 查看用户自定义命令的递归最大深度,缺省是 1024
set-user-call-depth &amp;lt;limit&amp;gt;-- 设置用户自定义命令的递归最大深度.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>内存泄露</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-4</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-4</guid>
      <description>&lt;p&gt;PCIe应用程序调试时，发现程序出现内存泄露，经过自己的摸索，以及向软件同学请教，最终解决了此问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;现象描述&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;应用程序开发环境为VC++,运用其debug功能进行单步调试时，程序总是报出内存泄露的错误，报告内容如下所示：&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;Detected memory leaks!
Dumping objects -&amp;gt;
strcore.cpp(118) : {143} normal block at 0x009A3E60, 53 bytes long.
 Data: &amp;lt;    (   (   F:\p&amp;gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70
Object dump complete.
The thread 0x9BC has exited with code 0 (0x0).
The program &#39;F:\program\SP5301\SP5301GUI\Debug\SP5301GUI.exe&#39; has exited with code 0 (0x0).
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;经过网上查阅相关资料，得知报告中相关参数含义如下：&lt;/p&gt;

&lt;p&gt;118：内存泄露的位置在strcore.cpp中第118行&lt;/p&gt;

&lt;p&gt;143：内存分配编号。 内存可能是在多次分配之后才出现泄露。
    normal block：块类型为普通型。
    0x009A3E60：内存位置。
    53 bytes long：块大小为53字节。
    第四行显示前 16 字节的内容为“&amp;lt; ( (F:\p&amp;gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70”。&lt;/p&gt;

&lt;p&gt;第五行显示内存泄露的线程，以及返回值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调试过程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然报告中显示内存泄露的位置在strcore.cpp中第118行。但是，此文件不在我的工程文件中。那么它应该是在程序运行时被调用过。而且它可能被多次调用。到底是哪次调用时出现的内存泄露，我们不得而知。为了解决内存泄露问题，准确定位内存泄露的位置是关键。&lt;/p&gt;

&lt;p&gt;首先进入单步调试，然后打开VC++菜单中view-&amp;gt;debug windows-&amp;gt;Memory。通过报告中给出的内存地址0x009A3E60，查看该地址存储的内容为&amp;rdquo;F:\program\SP5301\s6_tfg484_pcie\testdata.txt&amp;rdquo;。结合程序内容，我猜测此字符串应该为我定义的字符串指针filepath。打开watch窗口，查看filepath的值，发现果然与上面看到的一致。于是定位了内存泄露的位置为filepath变量。&lt;/p&gt;

&lt;p&gt;此字符串指针最初是在一个类里面定义的。最后赋给它的值是一个文件的路径。怀疑是该指针最后没有成功释放才导致的内存泄露。于是，我将filepath从类里面移出来，放在函数里面作为局部变量来定义。最终解决了内存泄露问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;归纳总结&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。&lt;/p&gt;

&lt;p&gt;常见的内存错误及其对策如下：&lt;/p&gt;

&lt;p&gt;(1)      内存分配未成功，却使用了它。&lt;/p&gt;

&lt;p&gt;编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。&lt;/p&gt;

&lt;p&gt;(2)      内存分配虽然成功，但是尚未初始化就引用它。&lt;/p&gt;

&lt;p&gt;犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。&lt;/p&gt;

&lt;p&gt;(3)      内存分配成功并且已经初始化，但操作越过了内存的边界。&lt;/p&gt;

&lt;p&gt;例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。&lt;/p&gt;

&lt;p&gt;(4)      忘记了释放内存，造成内存泄露。&lt;/p&gt;

&lt;p&gt;含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。&lt;/p&gt;

&lt;p&gt;动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。&lt;/p&gt;

&lt;p&gt;(5)      释放了内存却继续使用它。&lt;/p&gt;

&lt;p&gt;有三种情况：&lt;/p&gt;

&lt;p&gt;A.        程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。&lt;/p&gt;

&lt;p&gt;B.        函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。&lt;/p&gt;

&lt;p&gt;C.        使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。&lt;/p&gt;

&lt;p&gt;在产品的开发中，通过对当前系统消耗内存总量的统计，可以对产品所需内存总量进行精确的评估，从而选择合适的内存芯片与大小，降低产品的成本。在遇到内存泄露类问题时，经常会对此束手无策，本文通过对proc下进程相关的文件进行分析，精确评估系统消耗内存的大小，还可以对内存泄露类问题的解决提供一种定位手段。
       Linux在内存使用上的原则是：如果内存充足，不用白不用，尽量使用内存来缓存一些文件，从而加快进程的运行速度，而当内存不足时，会通过相应的内存回收策略收回cache内存，供进程使用。&lt;/p&gt;

&lt;p&gt;一、系统总内存的分析。
可以从proc目录下的meminfo文件了解到当前系统内存的使用情况汇总，其中可用的物理内存=memfree+buffers+cached，当memfree不够时，内核会通过回写机制(pdflush线程)把cached和buffered内存回写到后备存储器，从而释放相关内存供进程使用，或者通过手动方式显式释放cache内存
       echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/p&gt;

&lt;p&gt;下图是海思平台下当前系统内存的总体使用情况，其中可以看到，系统消耗掉了29M的内存，下面继续分析这些内存都是被谁消耗掉了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/meminfo
MemTotal:        68956 kB
MemFree:         18632 kB
Buffers:          4096 kB
Cached:          17260 kB
SwapCached:          0 kB
Active:          21304 kB
Inactive:        19248 kB
SwapTotal:           0 kB
SwapFree:            0 kB
Dirty:               0 kB
Writeback:           0 kB
AnonPages:       19216 kB
Mapped:           2472 kB
Slab:             6900 kB
SReclaimable:      924 kB
SUnreclaim:       5976 kB
PageTables:        460 kB
NFS_Unstable:        0 kB
Bounce:              0 kB
CommitLimit:     62060 kB
Committed_AS:    28864 kB
VmallocTotal:   442368 kB
VmallocUsed:     46984 kB
VmallocChunk:   393212 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、进程使用内存的统计
在32位操作系统中，每个进程拥有4G的虚拟内存空间，其中0~3GB是每个进程的私有用户空间，这个空间对系统中其他进程是不可见的。3~4GB是linux内核空间，由系统所有的进程以及内核所共享的。通过访问/proc/{pid}/下相关文件，可以了解每个线程虚拟内存空间的使用情况，从而了解每个线程所消耗内存的多少。
由于我们的产品都是使用多线程方式实现的，多个线程共享一个进程的用户态虚拟地址空间，虚拟地址空间包含若干区域，主要有如下几个区域：
1、当前执行文件的代码段，该代码段称为text段。
2、执行文件的数据段，主要存储执行文件用到的全局变量，静态变量。
3、存储全局变量和动态产生的数据的堆。
4、用于保存局部变量和实现函数调用的栈。
5、采用mmap方式映射到虚拟地址空间中的内存段&lt;/p&gt;

&lt;p&gt;所以只需要查看任意一个线程的用户态虚拟地址空间分配即可知道属于同一进程的所有线程占用总内存的大小。可以通过查看/proc/{pid}/maps文件来获取相关的虚拟地址空间内容，下文摘列部分典型的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/568/maps
00008000-0036a000 r-xp 00000000 00:0e 236        /home/hik/hicore
00372000-003a5000 rw-p 00362000 00:0e 236        /home/hik/hicore
003a5000-00e28000 rwxp 003a5000 00:00 0          [heap]
40000000-40005000 r-xp 00000000 01:00 94         /lib/ld-uClibc.so.0
416db000-41770000 rw-s c2005000 00:0f 68         /dev/mem

b51fc000-b5200000 rwxp b51fc000 00:00 0
…….
be1fc000-be200000 rwxp be1fc000 00:00 0
be93b000-be950000 rwxp befeb000 00:00 0          [stack]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行：从r-xp可知其权限为只读、可执行，该段内存地址对应于执行文件的
代码段，程序的代码段需加载到内存中才可以执行。由于其只读，不会
被修改，所以在整个系统内共享。
第二行：从rw-p可知其权限为可读写，不可执行，该段内存地址对应于执行文件的数据段，存放执行文件所用到的全局变量、静态变量。
第三行：从rwxp可知其权限是可读写，可执行，地址空间向上增长，而且不对应文件，是堆段，进程使用malloc申请的内存放在堆段。每个进程只有一个堆段，不论是主进程，还是不同的线程申请的内存，都反映到到进程的堆段。堆段向上增长，最大可以增长到1GB的位置，即0x40000000，如果大于1GB，glibc将采用mmap的方式，为堆申请一块内存。
第四行：是程序连接的共享库的内存地址。
第五行：是以mmap方式映射的虚拟地址空间。
第六、七行：是线程的栈区地址段，每个线程的栈大小都是16K。
第八行：是进程的栈区。关于栈段，每个线程都有一个，如果进程中有多个线程，则包含多个栈段。&lt;/p&gt;

&lt;p&gt;三、当前系统总内存的统计
    1、进程占用的总内存可以通过上述maps表计算出来。
    2、当系统运行起来以后，会把应用层相关的文件挂载到tmpfs文件系统下，海思系统下这部分大概有13M左右，这部分内存是以cache方式统计出来的，但是这部分内存cache无法通过回收策略或者显式的调用释放掉。
    3、根文件系统ramdisk占用的内存。
    4、当前系统保留内存的大小，可以通过查看/proc/sys/vm/min_free_kbytes来获取或者修改此内存的大小。
    5、当然，当系统运行起来后，还应该留有一定的内存用于在硬盘读写时做cache或者网络负荷比较高时分配skb等，一般需要30M以上。&lt;/p&gt;

&lt;p&gt;四、对调试内存泄露类问题的一些启示
   当进程申请内存时，实际上是glibc中内置的内存管理器接收了该请求，随着进程申请内存的增加，内存管理器会通过系统调用陷入内核，从而为进程分配更多的内存。
针对堆段的管理，内核提供了两个系统调用brk和mmap，brk用于更改堆顶地址，而mmap则为进程分配一块虚拟地址空间。
当进程向glibc申请内存时，如果申请内存的数量大于一个阀值的时候，glibc会采用mmap为进程分配一块虚拟地址空间，而不是采用brk来扩展堆顶的指针。缺省情况下，此阀值是128K，可以通过函数来修改此值。
             #include
             Int mallopt(int param, int value)
Param的取值分别为M_MMAP_THRESHOLD、M_MMAP_MAX。
Value的取值是以字节为单位的。
M_MMAP_THRESHOLD是glibc中申请大块内存阀值，大于该阀值的内存申请，内存管理器将使用mmap系统调用申请内存，如果小于该阀值的内存申请，内存管理器使用brk系统调用扩展堆顶指针。
M_MMAP_MAX是该进程中最多使用mmap分配地址段的数量。&lt;/p&gt;

&lt;p&gt;如果在实际的调试过程中，怀疑某处发生了内存泄露，可以查看该进程的maps表，看进程的堆段或者mmap段的虚拟地址空间是否持续增加，如果是，说明很可能发生了内存泄露，如果mmap段虚拟地址空间持续增加，还可以看到各个段的虚拟地址空间的大小，从而可以确定是申请了多大的内存，对调试内存泄露类问题可以起到很好的定位作用。&lt;/p&gt;

&lt;p&gt;如何检测内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏的问题，在百度是遇到最多的，阿里相对少点。与内存泄漏斗争了很久，我总结下常用的一些有效测试方法吧。
　　1、valgrind，这是非常好用的工具，虽然参数很多，输出结果较多，但是只要认真看下，就很容易发现问题，报告是很详细的，不要被吓倒。valgrind检测的内存泄漏是非常准的，可以精确定位到代码行甚至是变量。valgrind基于valginrd core框架，这是个非常有强大的框架，他的作用不仅仅在于检测内存泄漏的，强烈建议测试新手通读下全部的文档。valgind自己也会有误报和漏报，所有具体场景需要具体分析。报告中一旦出现definitely lost的标记，就表示一定会有内存泄漏，泄漏的字节数也会报告出来，可以根据泄漏的内存大小和请求次数计算出到底是那个变量没有释放。
　　2、利用pmap+gdb，pmap可以列出特定进程的所有内存分配的地址和大小，通过gdb就可以直接看这些地址属于什么变量，通过统计这些内存地址的大小，就可以很容易的发现问题。利用自动化的gdb调试工具也可以很方便的定位。
　　3、其他的还包括memprof、商业工具Purify IBM出品，官方宣传说的不错，但是这种不开放的技术，在业界得不到认可，国内大公司一般那都不用，只有人傻钱多的公司在用。
　　4、利用一些trace工具，比如ptrace，strace之类的工具，这些trace工具会追踪特定的api，只需要统计malloc和free的调用次数就可以简单的发现是否有泄漏，但是无法定位代码行。另外还有一个更高深的工具，SystemTap，这个在国内应用还不多，但是非常厉害，可以方便hook程序的关键逻辑并插入探针。从而可以方便的检测内存泄漏。Systemtap目前还不通用，而且安装复杂，暂时不推荐使用，可以关注下，过几年可能会大规模应用。
　　valgrind是首选，因为他的设计就是为了解决所有的c++的内存问题。一些valgrind不能简单发现的，我一般会review代码，然后通过gdb自动调试技术来发现问题。通过valgrind+gdb，可以解决所有的内存泄漏。
　　另外，内存的泄漏也并不完全是没有及时的free，还有可能是其他的原因，比如设计问题等。需要靠一定的开发经验判断。
　　要尽量把静态测试和动态测试尽早的加入到持续集成中，以尽早的发现问题，不然一旦代码复杂，追查的成本就会增大。&lt;/p&gt;

&lt;p&gt;目的：
本文是《一种定位内存泄露的方法（Solaris）》对应的Linux版本，调试器使用gdb。主要介绍实例部分。其他请见《一种定位内存泄露的方法（Solaris）》。&lt;/p&gt;

&lt;p&gt;实例：
模拟new失败的程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdexcept&amp;gt;
class ABC
{
public:
        virtual ~ABC(){}
        int i;
        int j;
};

void f()
{
        for (int i = 0; i &amp;lt; 1000; ++i)
        {
                ABC* p = new ABC;
        }
        throw std::bad_alloc();
}

int main()
{
        f();
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1） 编译运行此段代码。产生一个core文件
2） 用gdb打开这个core文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb a.out core
(gdb) run
Starting program: /test/new_fail/a.out
terminate called after throwing an instance of &#39;std::bad_alloc&#39;
  what():  std::bad_alloc

Program received signal SIGABRT, Aborted.
0x00007ffff733f645 in raise () from /lib64/libc.so.6
(gdb) info proc
process 10683
cmdline = &#39;/test/new_fail/a.out&#39;
cwd = &#39;/test/new_fail&#39;
exe = &#39;/test/new_fail/a.out&#39;
(gdb) shell pmap 10683
10683: a.out
START               SIZE     RSS     PSS   DIRTY    SWAP PERM MAPPING
0000000000400000      4K      4K      4K      0K      0K r-xp /test/new_fail/a.out
0000000000600000      4K      4K      4K      4K      0K r--p /test/new_fail/a.out
0000000000601000      4K      4K      4K      4K      0K rw-p /test/new_fail/a.out
0000000000602000    132K     32K     32K     32K      0K rw-p [heap]
…（略）
Total:            11468K   1048K    684K    180K      0K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;360K writable-private, 11108K readonly-private, 0K shared, and 1048K referenced&lt;/p&gt;

&lt;p&gt;可以看到heap空间的起始地址是0x0000000000602000，共132K字节，即132*1024=135168字节。
3） 因为是64位应用程序，所以指针占8字节。所以需要遍历的指针个数为135168/8=16896。
4） 将结果输出到日志文件gdb.txt中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set height 0
(gdb) set logging on
Copying output to gdb.txt.
(gdb) x/16896a 0x0000000000602000
gdb.txt的内容：
0x602000:       0x0     0x21
0x602010:       0x400b30 &amp;lt;_ZTV3ABC+16&amp;gt;  0x0
0x602020:       0x0     0x21
0x602030:       0x400b30 &amp;lt;_ZTV3ABC+16&amp;gt;  0x0
….
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5） 过滤gdb.txt：
awk &amp;lsquo;{print $2&amp;rdquo;/n&amp;rdquo;$3}&amp;rsquo; gdb.txt|c++filt|grep vtable&amp;gt;gdb_vtable.txt
gdb_vtable.txt的内容为：
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
….
6） 将gdb_vtable.txt的内容导入到SQLServer中（如果记录不多，可以用Excel代替）。表名为gdb_vtable，第一列Col001为符号。对其分组求和：
select Col001, count(1) quantity from gdb_vtable
group by Col001
order by quantity desc
结果为：
Col001                                                                                    quantity
&lt;vtable for ABC+16&gt;                                                              1000
&lt;vtable for std::bad_alloc@@GLIBCXX_3.4+16&gt;                1
可知core里有1000个ABC，遍历使用ABC的代码，可知存在泄漏。&lt;/p&gt;

&lt;p&gt;linux下调试内存泄露的利器Valgrind&lt;/p&gt;

&lt;p&gt;Valgrind的主要作者Julian Seward刚获得了今年的Google-O&amp;rsquo;Reilly开源大奖之一──Best Tool Maker。让我们一起来看一下他的作品。Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，它包含一个内核──一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务──调试，分析，或测试等。Valgrind可以检测内存泄漏和内存违例，还可以分析cache的使用等，灵活轻巧而又强大，能直穿程序错误的心脏，真可谓是程序员的瑞士军刀。&lt;/p&gt;

&lt;p&gt;更详细的文档可以参考：Valgrind Documentation&lt;/p&gt;

&lt;p&gt;一. Valgrind概观&lt;/p&gt;

&lt;p&gt;Valgrind的最新版是3.2.0，它一般包含下列工具：
1.Memcheck&lt;/p&gt;

&lt;p&gt;最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到， 一切对malloc()/free()/new/delete的调用都会被捕获。所以，它能检测以下问题：&lt;/p&gt;

&lt;p&gt;1.对未初始化内存的使用；&lt;/p&gt;

&lt;p&gt;2.读/写释放后的内存块；&lt;/p&gt;

&lt;p&gt;3.读/写超出malloc分配的内存块；&lt;/p&gt;

&lt;p&gt;4.读/写不适当的栈中内存块；&lt;/p&gt;

&lt;p&gt;5.内存泄漏，指向一块内存的指针永远丢失；&lt;/p&gt;

&lt;p&gt;6.不正确的malloc/free或new/delete匹配；&lt;/p&gt;

&lt;p&gt;7,memcpy()相关函数中的dst和src指针重叠。&lt;/p&gt;

&lt;p&gt;这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。
2.Callgrind&lt;/p&gt;

&lt;p&gt;和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。
3.Cachegrind&lt;/p&gt;

&lt;p&gt;Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。
4.Helgrind&lt;/p&gt;

&lt;p&gt;它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。
5. Massif&lt;/p&gt;

&lt;p&gt;堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。&lt;/p&gt;

&lt;p&gt;此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。我们就不做介绍了。
二. 使用Valgrind&lt;/p&gt;

&lt;p&gt;Valgrind的使用非常简单，valgrind命令的格式如下：&lt;/p&gt;

&lt;p&gt;valgrind [valgrind-options] your-prog [your-prog options]&lt;/p&gt;

&lt;p&gt;一些常用的选项如下：&lt;/p&gt;

&lt;p&gt;选项&lt;/p&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;-h &amp;ndash;help&lt;/p&gt;

&lt;p&gt;显示帮助信息。&lt;/p&gt;

&lt;p&gt;&amp;ndash;version&lt;/p&gt;

&lt;p&gt;显示valgrind内核的版本，每个工具都有各自的版本。&lt;/p&gt;

&lt;p&gt;-q &amp;ndash;quiet&lt;/p&gt;

&lt;p&gt;安静地运行，只打印错误信息。&lt;/p&gt;

&lt;p&gt;-v &amp;ndash;verbose&lt;/p&gt;

&lt;p&gt;打印更详细的信息。&lt;/p&gt;

&lt;p&gt;&amp;ndash;tool=&lt;toolname&gt; [default: memcheck]&lt;/p&gt;

&lt;p&gt;最常用的选项。运行valgrind中名为toolname的工具。如果省略工具名，默认运行memcheck。&lt;/p&gt;

&lt;p&gt;&amp;ndash;db-attach=&lt;yes|no&gt; [default: no]&lt;/p&gt;

&lt;p&gt;绑定到调试器上，便于调试错误。&lt;/p&gt;

&lt;p&gt;我们通过例子看一下它的具体使用。我们构造一个存在内存泄漏的C程序，如下：&lt;/p&gt;

&lt;p&gt;[cpp] view plaincopyprint?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
void f(void)  
{  
    int* x = malloc(10 * sizeof(int));  
    x[10] = 0; // problem 1: heap block overrun  
    } // problem 2: memory leak -- x not freed  
    int main(void)  
    {  
    int i;  
    f();  
    printf(&amp;quot;i=%d\n&amp;quot;,i); //problem 3: use uninitialised value.  
    return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存为memleak.c并编译，然后用valgrind检测。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -Wall -o memleak memleak.c
$ valgrind --tool=memcheck ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到如下错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== Invalid write of size 4
==3649== at 0x80483CF: f (in /home/wangcong/memleak)
==3649== by 0x80483EC: main (in /home/wangcong/memleak)
==3649== Address 0x4024050 is 0 bytes after a block of size 40 alloc&#39;d
==3649== at 0x40051F9: malloc (vg_replace_malloc.c:149)
==3649== by 0x80483C5: f (in /home/wangcong/memleak)
==3649== by 0x80483EC: main (in /home/wangcong/memleak)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的3649是程序运行时的进程号。第一行是告诉我们错误类型，这里是非法写入。下面的是告诉我们错误发生的位置，在main()调用的f()函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== Use of uninitialised value of size 4
==3649== at 0xC3A264: _itoa_word (in /lib/libc-2.4.so)
==3649== by 0xC3E25C: vfprintf (in /lib/libc-2.4.so)
==3649== by 0xC442B6: printf (in /lib/libc-2.4.so)
==3649== by 0x80483FF: main (in /home/wangcong/memleak)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个错误是使用未初始化的值，在main()调用的printf()函数中。这里的函数调用关系是通过堆栈跟踪的，所以有时会非常多，尤其是当你使用C++的STL时。其它一些错误都是由于把未初始化的值传递给libc函数而被检测到。在程序运行结束后，valgrind还给出了一个小的总结：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== ERROR SUMMARY: 20 errors from 6 contexts (suppressed: 12 from 1)
==3649== malloc/free: in use at exit: 40 bytes in 1 blocks.
==3649== malloc/free: 1 allocs, 0 frees, 40 bytes allocated.
==3649== For counts of detected errors, rerun with: -v
==3649== searching for pointers to 1 not-freed blocks.
==3649== checked 47,256 bytes.
==3649==
==3649== LEAK SUMMARY:
==3649== definitely lost: 40 bytes in 1 blocks.
==3649== possibly lost: 0 bytes in 0 blocks.
==3649== still reachable: 0 bytes in 0 blocks.
==3649== suppressed: 0 bytes in 0 blocks.
==3649== Use --leak-check=full to see details of leaked memory.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以很清楚地看出，分配和释放了多少内存，有多少内存泄漏。这对我们查找内存泄漏十分方便。然后我们重新编译程序并绑定调试器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -Wall -ggdb -o memleak memleak.c
$ valgrind --db-attach=yes --tool=memcheck ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一出现错误，valgrind会自动启动调试器（一般是gdb）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3893== ---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ---- y
starting debugger
==3893== starting debugger with cmd: /usr/bin/gdb -nw /proc/3895/fd/1014 3895
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出gdb后我们又能回到valgrind继续执行程序。&lt;/p&gt;

&lt;p&gt;还是用上面的程序，我们使用callgrind来分析一下它的效率：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ valgrind --tool=callgrind ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Callgrind会输出很多，而且最后在当前目录下生成一个文件： callgrind.out.pid。用callgrind_annotate来查看它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ callgrind_annotate callgrind.out.3949
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的信息就列出来了。而且，当callgrind运行你的程序时，你还可以使用callgrind_control来观察程序的执行，而且不会干扰它的运行。&lt;/p&gt;

&lt;p&gt;再来看一下cachegrind的表现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ valgrind --tool=cachegrind ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==4073== I refs: 147,500
==4073== I1 misses: 1,189
==4073== L2i misses: 679
==4073== I1 miss rate: 0.80%
==4073== L2i miss rate: 0.46%
==4073==
==4073== D refs: 61,920 (46,126 rd + 15,794 wr)
==4073== D1 misses: 1,759 ( 1,545 rd + 214 wr)
==4073== L2d misses: 1,241 ( 1,062 rd + 179 wr)
==4073== D1 miss rate: 2.8% ( 3.3% + 1.3% )
==4073== L2d miss rate: 2.0% ( 2.3% + 1.1% )
==4073==
==4073== L2 refs: 2,948 ( 2,734 rd + 214 wr)
==4073== L2 misses: 1,920 ( 1,741 rd + 179 wr)
==4073== L2 miss rate: 0.9% ( 0.8% + 1.1% )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的是指令缓存，I1和L2i缓存，的访问信息，包括总的访问次数，丢失次数，丢失率。&lt;/p&gt;

&lt;p&gt;中间的是数据缓存，D1和L2d缓存，的访问的相关信息，下面的L2缓存单独的信息。Cachegrind也生成一个文件，名为cachegrind.out.pid，可以通过cg_annotate来读取。输出是一个更详细的列表。Massif的使用和cachegrind类似，不过它也会生成一个名为massif.pid.ps的PostScript文件，里面只有一幅描述堆栈使用状况的彩图。&lt;/p&gt;

&lt;p&gt;以上只是简单的演示了valgrind的使用，更多的信息可以在它附带的文档中得到，也可以访问valgrind的主页：&lt;a href=&#34;http://www.valgrind.org。学会正确合理地使用valgrind对于调试程序会有很大的帮助。&#34;&gt;http://www.valgrind.org。学会正确合理地使用valgrind对于调试程序会有很大的帮助。&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gdb多线程调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-5</link>
      <pubDate>Thu, 29 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-5</guid>
      <description>&lt;p&gt;gdb对于多线程程序的调试有如下的支持：
　　
　　线程产生通知：在产生新的线程时, gdb会给出提示信息
　　(gdb) r
　　Starting program: /root/thread
　　[New Thread 1073951360 (LWP 12900)]
　　[New Thread 1082342592 (LWP 12907)]&amp;mdash;以下三个为新产生的线程
　　[New Thread 1090731072 (LWP 12908)]
　　[New Thread 1099119552 (LWP 12909)]
　　
　　查看线程：使用info threads可以查看运行的线程。
　　(gdb) info threads
　　 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　* 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb)
　　
　　
　　注意，行首的蓝色文字为gdb分配的线程号，对线程进行切换时，使用该该号码，而不是上文标出的绿色数字。
　　
　　另外，行首的红色星号标识了当前活动的线程
　　
　　切换线程：使用 thread THREADNUMBER 进行切换，THREADNUMBER 为上文提到的线程号。下例显示将活动线程从 1 切换至 4。
　　(gdb) info threads
　　 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　* 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb) thread 4
　　[Switching to thread 4 (Thread 1099119552 (LWP 12940))]#0 0xffffe002 in ?? ()
　　(gdb) info threads
　　* 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb)
　　
　　
　　 以上即为使用gdb提供的对多线程进行调试的一些基本命令。另外，gdb也提供对线程的断点设置以及对指定或所有线程发布命令的命令。
　　
　　 初次接触gdb下多线程的调试，往往会忽视gdb中活动线程的概念。一般来讲，在使用gdb调试的时候，只有一个线程为活动线程，如果希望得到其他的线程的输出结果，必须使用thread命令切换至指定的线程，才能对该线程进行调试或观察输出结果。&lt;/p&gt;

&lt;p&gt;一直对GDB多线程调试接触不多，最近因为工作有了一些接触，简单作点记录吧。&lt;/p&gt;

&lt;p&gt;先介绍一下GDB多线程调试的基本命令。&lt;/p&gt;

&lt;p&gt;info threads
显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。
前面有*的是当前调试的线程。&lt;/p&gt;

&lt;p&gt;thread ID
切换当前调试的线程为指定ID的线程。&lt;/p&gt;

&lt;p&gt;break thread_test.c:123 thread all
在所有线程中相应的行上设置断点&lt;/p&gt;

&lt;p&gt;thread apply ID1 ID2 command
让一个或者多个线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;thread apply all command
让所有被调试线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;set scheduler-locking off|on|step
估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。
off 不锁定任何线程，也就是所有线程都执行，这是默认值。
on 只有当前被调试程序会执行。
step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;

&lt;p&gt;在介绍完基本的多线程调试命令后，大概介绍一下GDB多线程调试的实现思路。&lt;/p&gt;

&lt;p&gt;比较主要的代码是thread.c，前面介绍的几个命令等都是在其中实现。
thread_list这个表存储了当前可调试的所有线程的信息。
函数add_thread_silent或者add_thread(不同版本GDB不同)用来向thread_list列表增加一个线程的信息。
函数delete_thread用来向thread_list列表删除一个线程的信息。
上面提到的这2个函数会被有线程支持的target调用，用来增加和删除线程，不同的OS对线程的实现差异很大，这么实现比较好的保证了GDB多线程调试支持的扩展性。
函数info_threads_command是被命令info threads调用的，就是显示thread_list列表的信息。
函数thread_command是被命令thread调用，切换当前线程最终调用的函数是switch_to_thread，这个函数会先将当前调试线程变量inferior_ptid，然后对寄存器和frame缓冲进行刷新。
函数thread_apply_command被命令thread apply调用，这个函数的实际实现其实很简单，就是先切换当前线为指定线程，然后调用函数execute_command调用指定函数。&lt;/p&gt;

&lt;p&gt;比较特别的是set scheduler-locking没有实现在thread.c中，而是实现在控制被调试程序执行的文件infrun.c中。
对其的设置会保存到变量scheduler_mode中，而实际使用这个变量的函数只有用来令被调试程序执行的函数resume。在默认情况下， 传递给target_resume的变量是resume_ptid，默认情况下其的值为RESUME_ALL，也就是告诉target程序执行的时候所有 被调试线程都要被执行。而当scheduler_mode设置为只让当前线程执行的时候，resume_ptid将被设置为inferior_ptid， 这就告诉target只有inferior_ptid的线程会被执行。&lt;/p&gt;

&lt;p&gt;最后特别介绍一下Linux下多线程的支持，基本的调试功能在linux-nat.c中，这里有对Linux轻量级别进程本地调试的支持。但是其 在调试多线程程序的时候，还需要对pthread调试的支持，这个功能实现在linux-thread-db.c中。对pthread的调试要通过调用 libthread_db库来支持。
这里有一个单独的target&amp;rdquo;multi-thread&amp;rdquo;，这个target有2点很特别:
第一，一般target的装载是在调用相关to_open函数的时候调用push_target进行装载。而这个target则不同，在其初始化 的时候，就注册了函数thread_db_new_objfile到库文件attach事件中。这样当GDB为调试程序的动态加载库时候attach库文 件的时候，就会调用这个函数thread_db_new_objfile。这样当GDB装载libpthread库的时候，最终会装载 target&amp;rdquo;multi-thread&amp;rdquo;。
第二，这个target并没有像大部分target那样自己实现了全部调试功能，其配合linux-nat.c的代码的功能，这里有一个target多层结构的设计，要介绍的比较多，就不详细介绍了。&lt;/p&gt;

&lt;p&gt;最后介绍一下我最近遇见的一个多线程调试和解决。&lt;/p&gt;

&lt;p&gt;基本问题是在一个Linux环境中，调试多线程程序不正常，info threads看不到多线程的信息。
我先用命令maintenance print target-stack看了一下target的装载情况，发现target&amp;rdquo;multi-thread&amp;rdquo;没有被装载，用GDB对GDB进行调试，发现在 函数check_for_thread_db在调用libthread_db中的函数td_ta_new的时候，返回了TD_NOLIBTHREAD，所 以没有装载target&amp;rdquo;multi-thread&amp;rdquo;。
在时候我就怀疑是不是libpthread有问题，于是检查了一下发现了问题，这个环境中的libpthread是被strip过的，我想可能 就是以为这个影响了td_ta_new对libpthread符号信息的获取。当我换了一个没有strip过的libpthread的时候，问题果然解决 了。
最终我的解决办法是拷贝了一个.debug版本的libpthread到lib目录中，问题解决了。
多线程如果dump，多为段错误，一般都涉及内存非法读写。可以这样处理，使用下面的命令打开系统开关，让其可以在死掉的时候生成core文件。&lt;br /&gt;
ulimit -c unlimited
这样的话死掉的时候就可以在当前目录看到core.pid(pid为进程号)的文件。接着使用gdb:
gdb ./bin ./core.pid
进去后，使用bt查看死掉时栈的情况，在使用frame命令。&lt;/p&gt;

&lt;p&gt;还有就是里面某个线程停住，也没死，这种情况一般就是死锁或者涉及消息接受的超时问题(听人说的，没有遇到过)。遇到这种情况，可以使用：
gcore pid （调试进程的pid号）
手动生成core文件，在使用pstack(linux下好像不好使)查看堆栈的情况。如果都看不出来，就仔细查看代码，看看是不是在if，return，break，continue这种语句操作是忘记解锁，还有嵌套锁的问题，都需要分析清楚了。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
