<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>教程 on Frederick&#39;s blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://sun-friderick.github.io/tags/%E6%95%99%E7%A8%8B/</link>
    <language>en-us</language>
    <author>Frederick Sun</author>
    <copyright>Copyright (c) 2015, Frederick Sun; all rights reserved.</copyright>
    <updated>Sun, 29 Nov 2015 00:30:03 CST</updated>
    
    <item>
      <title>Markdown语法</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-1</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-1</guid>
      <description>

&lt;p&gt;Markdown语法&lt;/p&gt;

&lt;p&gt;#1、标题：
两种标题的语法，Setext 和 atx 形式（共有六级）：
第一种：Setext 形式是用底线的形式，通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。&lt;/p&gt;

&lt;h1 id=&#34;一级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;二级标题&lt;/h2&gt;

&lt;p&gt;第二种：Atx 形式，在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）&lt;/p&gt;

&lt;h1 id=&#34;一级标题-1:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;一级标题&lt;/h1&gt;

&lt;h2 id=&#34;二级标题-1:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;二级标题&lt;/h2&gt;

&lt;h3 id=&#34;三级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;三级标题&lt;/h3&gt;

&lt;h4 id=&#34;四级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;四级标题&lt;/h4&gt;

&lt;h5 id=&#34;五级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;五级标题&lt;/h5&gt;

&lt;h6 id=&#34;六级标题:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;六级标题&lt;/h6&gt;

&lt;p&gt;#2、列表：&lt;br /&gt;
有序列表：使用数字后面跟上句号。（还要有空格）&lt;br /&gt;
   1. 有序一&lt;br /&gt;
   2. 有序二&lt;br /&gt;
   3. 有序三&lt;/p&gt;

&lt;p&gt;注意：在“1.”与文本之间有空格；&lt;/p&gt;

&lt;p&gt;无序列表：在文字开头添加(&lt;em&gt;, +, and -)实现无序列表。但是要注意在(&lt;/em&gt;, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）&lt;br /&gt;
   - 无序一&lt;br /&gt;
   - 无序二&lt;br /&gt;
   - 无序三&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无序一&lt;/li&gt;
&lt;li&gt;无序二&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无序三&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Red&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Green&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blue&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在“-”或“*”与文本之间有空格；&lt;/p&gt;

&lt;p&gt;#3、引用：&lt;br /&gt;
区块引言可以有级别（例如：引言内的引言），只要根据级别加上不同数量的 &amp;gt;&lt;br /&gt;
&amp;gt; 引用&lt;br /&gt;
&amp;gt;&amp;gt; 引用&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt; 引用&lt;/p&gt;

&lt;p&gt;注意： 符号“&amp;gt;”与文本之间需要有空格；&lt;/p&gt;

&lt;p&gt;#4、字体强调：&lt;br /&gt;
星号（*）和底线（_）作为标记强调字词的符号&lt;br /&gt;
斜体：将需要设置为斜体的文字两端使用1个“ * ”或者“ _ ”夹起来&lt;br /&gt;
   &lt;em&gt;这是斜体字&lt;/em&gt;&lt;br /&gt;
   &lt;em&gt;这也是斜体字&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;粗体：将需要设置为斜体的文字两端使用2个“ * ”或者“ _ ”夹起来&lt;br /&gt;
   &lt;strong&gt;这是粗体字&lt;/strong&gt;&lt;br /&gt;
   &lt;strong&gt;这也是粗体字&lt;/strong&gt;&lt;br /&gt;
注意： 在“*”或“**”与文本之间是没有空格的；&lt;/p&gt;

&lt;p&gt;#5、代码：两种方式：
第一种：简单文字出现一个代码框，使用“&lt;code&gt;”字符。（&lt;/code&gt;不是单引号而是左上角的ESC下面~中的&lt;code&gt;）  
行内代码：  
   这里是行内代码&lt;/code&gt;int a = 123456;`;&lt;br /&gt;
独立代码段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;   #include &amp;lt;stdio.h&amp;gt;
   
   int main(int argc, char** argv)
   {
       int a = 12345;
       int i = 0；
       for(i = 10; i &amp;gt;= 0; i--)
           a = a + i;
           
       if(a &amp;gt;= 20)
           printf(&amp;quot;a= [%d]\n&amp;quot;, a);
           
        return 0;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种：大片文字需要实现代码框。使用Tab或四个空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv)
{
   int a = 12345;
   int i = 0；
   for(i = 10; i &amp;gt;= 0; i--)
       a = a + i;

   if(a &amp;gt;= 20)
       printf(&amp;quot;a= [%d]\n&amp;quot;, a);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#6、链接（Links）：
有两种方式，实现链接，分别为内联方式和引用参考方式，链接的文字都是用 [方括号] 来标记。&lt;br /&gt;
内联方式：&lt;br /&gt;
   This is an &lt;a href=&#34;http://example.com/&#34;&gt;inline link&lt;/a&gt;.&lt;br /&gt;
   &lt;a href=&#34;http://example.net/&#34;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt;

&lt;p&gt;I get 10 times more traffic from &lt;a href=&#34;http://google.com/&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt; than from &lt;a href=&#34;http://search.yahoo.com/&#34; title=&#34;Yahoo Search&#34;&gt;Yahoo&lt;/a&gt; or &lt;a href=&#34;http://search.msn.com/&#34; title=&#34;MSN Search&#34;&gt;MSN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;引用参考方式：&lt;br /&gt;
   I get 10 times more traffic from &lt;a href=&#34;http://google.com/&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt; than from &lt;a href=&#34;http://search.yahoo.com/&#34; title=&#34;Yahoo Search&#34;&gt;Yahoo&lt;/a&gt; or &lt;a href=&#34;http://search.msn.com/&#34; title=&#34;MSN Search&#34;&gt;MSN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#7、图片（Images）：
图片的处理方式和链接的处理方式，非常的类似，允许两种样式： 行内和引用参考。&lt;br /&gt;
内联方式：&lt;br /&gt;
&lt;img src=&#34;http://mouapp.com/Mou_128.png&#34; alt=&#34;Alt text&#34; /&gt;&lt;br /&gt;
或者&lt;br /&gt;
&lt;img src=&#34;http://mouapp.com/Mou_128.png&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;引用参考方式：&lt;br /&gt;
&lt;img src=&#34;http://mouapp.com/Mou_128.png&#34; alt=&#34;alt text&#34; title=&#34;Title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;#8、脚注（footnote）：&lt;br /&gt;
hello&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;#9、表格：&lt;br /&gt;
| Tables        | Are           | Cool  |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:| &amp;mdash;&amp;ndash;:|&lt;br /&gt;
| col 3 is      | right-aligned | $1600 |&lt;br /&gt;
| col 2 is      | centered      |   $12 |&lt;br /&gt;
| zebra stripes | are neat      |    $1 |&lt;/p&gt;

&lt;p&gt;#10、分割线：&lt;br /&gt;
可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号中间插入空白。也在空白行下方添加三条“-”横线时。（前面讲过在文字下方添加“-”，实现的2级标题）；&lt;br /&gt;
使用“*”号：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;使用“-”号：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;使用下划线“_”：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;p&gt;#11、LaTex公式：&lt;br /&gt;
行内公式：&lt;br /&gt;
   这里是行内公式 $ y = x + 1 $ ;&lt;br /&gt;
独立公式段：
  $$ a^2 + b^2 = c^2 $$&lt;/p&gt;

&lt;p&gt;#12、转义字符&lt;br /&gt;
支持在下面这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;

&lt;p&gt;\   反斜杠&lt;br /&gt;
`   反引号&lt;br /&gt;
*   星号&lt;br /&gt;
_   底线&lt;br /&gt;
{}  大括号&lt;br /&gt;
[]  方括号&lt;br /&gt;
()  括号&lt;/p&gt;

&lt;h1 id=&#34;井字号:a49d799e3251d126dc2b508cdc41aa88&#34;&gt;井字号&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;加号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;减号&lt;br /&gt;
.   英文句点&lt;br /&gt;
!   惊叹号&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
        A--&amp;gt;B;
        A--&amp;gt;C;
        B--&amp;gt;D;
        C--&amp;gt;E;
        D--&amp;gt;E;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;hi的意思；
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:a49d799e3251d126dc2b508cdc41aa88:hello&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-7</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-7</guid>
      <description>

&lt;p&gt;#gdb 跟踪调试命令整理&lt;/p&gt;

&lt;h1 id=&#34;gdb常用命令:27ab83445e035e5774461847bd2aa236&#34;&gt;gdb常用命令：&lt;/h1&gt;

&lt;p&gt;|                命令        | 描述           | Cool  |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:|&lt;br /&gt;
| backtrace（或bt）    |    查看各级函数调用及参数，运行时的堆栈   |&lt;br /&gt;
| finish                              |    连续运行到当前函数返回为止，然后停下来等待命令    |&lt;br /&gt;
| frame（或f）帧编号  |   选择栈帧       |&lt;br /&gt;
| info（或i） locals       |   查看当前栈帧局部变量的值   |&lt;br /&gt;
| list（或l）                     |    列出源代码，接着上次的位置往下列，每次列10行       |&lt;br /&gt;
| list 行号                          |   列出从第几行开始的源代码        |&lt;br /&gt;
| list 函数名                     |    列出某个函数的源代码   |&lt;br /&gt;
| next（或n）                 |    单步调试，执行下一行语句        |&lt;br /&gt;
| print（或p）                |    打印表达式的值，通过表达式可以修改变量的值或者调用函数     |&lt;br /&gt;
| quit（或q）                 |     退出gdb调试环境  |&lt;br /&gt;
| set var                           |     修改变量的值       |&lt;br /&gt;
| start                               |     开始执行程序，停在main函数第一行语句前面等待命令       |&lt;br /&gt;
| step（或s）                 |     执行下一行语句，如果有函数调用则进入到函数中  |&lt;/p&gt;

&lt;p&gt;#GDB 调试&lt;/p&gt;

&lt;p&gt;要进行调试程序首先要生成一个含有调试信息的执行程序命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc(g++) -g -o 文件名 源文件.c(源文件.cpp)
gcc(g++) -ggdb3 -o 文件名 源文件.c(源文件.cpp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时便会生成一个含有调试信息的可执行文件,然后便可以用 gdb 去调试这个程序了,进入调试程序命令,但是如果用 gdb 去调试一个未包含调试信息的可执行文件则会发生错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb 执行文件名(含调试信息)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#运行 GDB&lt;/p&gt;

&lt;p&gt;##运行 gdb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb &amp;lt;program&amp;gt; -- program也就是你的执行文件,一般在当然目录下.
gdb &amp;lt;program&amp;gt; core -- 用 gdb 同时调试一个运行程序和 core 文件,core 是程序非法执行后 core dump 后产生的文件.
gdb &amp;lt;program&amp;gt; &amp;lt;PID&amp;gt; -- 调试正在运行的程序. program 为需要调试的程序文件, PID 为当前正在运行的程序.或是先用 gdb &amp;lt;program&amp;gt; 关联上源代码进入 gdb,后用 attach 命令来挂接进程的 PID.并用 detach 来取消挂接的进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 启动常用的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从指定文件中读取符号表
    -symbols &amp;lt;file&amp;gt;
    -s &amp;lt;file&amp;gt;
从指定文件中读取符号表信息,并把他用在可执行文件中
    -se file
调试时 core dump 的 core 文件
    -core &amp;lt;file&amp;gt;
    -c &amp;lt;file&amp;gt;
加入一个源文件的搜索路径.默认搜索路径是环境变量中 PATH 所定义的路径
    -directory &amp;lt;directory&amp;gt;
    -d &amp;lt;directory&amp;gt;
设置启动时候参数
    --args arglist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 帮助文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help -- 查看 gdb 的命令种类
help &amp;lt;CmdType&amp;gt; -- 查看 CmdType 种类的 gdb 命令
apropos &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 的相关命令
info &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 调试信息
show &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord gdb 本身设置信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 中运行 unix 的 shell 程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shell &amp;lt;command string&amp;gt; -- 调用 unix 的 shell 来执行 &amp;lt;command string&amp;gt;,环境变量 shell 中定义的 unix 的 shell 将会被用来执行 &amp;lt;command string&amp;gt;,如果 shell 没有定义,那就使用 unix 的标准 shell：/bin/sh.(在 windows 中使用 command.com 或 cmd.exe)
make &amp;lt;make-args&amp;gt; -- 等价于 “shell make &amp;lt;make-args&amp;gt;”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##历史记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当你用 gdb 的 print 查看程序运行时的数据时,你每一个 print 都会被 gdb 记录下来.gdb 会以 $1, $2, $3 ...这样的方式为你每一个 print 命令编上号.于是,你可以使用这个编号访问以前的表达式,如 $1.这个功能所带来的好处是,如果你先前输入了一个比较长的表达式,如果你还想查看这个表达式的值,你可以使用历史记录来访问,省去了重复输入.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##启动程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run &amp;lt;arg ...&amp;gt; -- 启动程序,&amp;lt;arg ...&amp;gt; 为程序运行时候需要输入的参数.也可用 set args 命令去设置运行参数.简写为 r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 环境设置&lt;/p&gt;

&lt;p&gt;##gdb 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置显示选项
    地址
        set print address &amp;lt;on/off&amp;gt; -- 打开地址输出,当程序显示函数信息时,gdb会显出函数的参数地址.系统默认为打开.
        show print address -- 查看 print address 选项信息
    数组元素单独行显示
        set print array &amp;lt;on/off&amp;gt; -- 打开时数组显示时,每个元素占一行,如果不打开的话,每个元素则以逗号分隔.这个选项默认是关闭的.
        show print array -- 查看 print array 选项信息
    显示数组元素显示
        set print elements &amp;lt;number-of-elements&amp;gt; -- 设置数组的显示的最大长度,设置为 0,则表示不限制.
        show print elements -- 查看 print elements 选项信息.
    设置字符串显示
        set print null-stop &amp;lt;on/off&amp;gt; -- 如果打开那么当显示字符串时,遇到结束符则停止显示.这个选项默认为 off.
        show print null-stop -- 查看 print null-stop 选项信息
    设置结构体变量显示
        set print pretty &amp;lt;on/off&amp;gt; -- 结构体优雅显示
        show print pretty -- 查看 gdb 是如何显示结构体的.
    设置字符显示
        set print sevenbit-strings &amp;lt;on/off&amp;gt; -- 符显示,是否按“/nnn”的格式显示,如果打开,则字符串或字符数据按/nnn显示,如“/065”.
        show print sevenbit-strings -- 查看字符显示开关是否打开.
    设置联合体显示
        set print union &amp;lt;on/off&amp;gt; -- 设置显示结构体时,是否显式其内的联合体数据.
        show print union -- 查看联合体数据的显示方式
    设置对象显示
        set print object &amp;lt;on/off&amp;gt; -- 在 C++ 中,如果一个对象指针指向其派生类,如果打开这个选项,gdb 会自动按照虚方法调用的规则显示输出,如果关闭这个选项的话,gdb 就不管虚函数表了.这个选项默认是 off.
        show print object -- 查看对象选项的设置.
    设置静态成员显示
        set print static-members &amp;lt;on/off&amp;gt; -- 这个选项表示,当显示一个 C++ 对象中的内容是,是否显示其中的静态数据成员.默认是 on.
        show print static-members -- 查看静态数据成员选项设置.
    设置虚函数表显示
        set print vtbl &amp;lt;on/off&amp;gt; -- 当此选项打开时,gdb 将用比较规整的格式来显示虚函数表时.其默认是关闭的.
        show print vtbl -- 查看虚函数显示格式的选项.
设置运行程序的相关环境及其参数
    指定源文件的路径
        directory &amp;lt;dirname ... &amp;gt; -- 加一个源文件路径到当前路径的前面.如果你要指定多个路径,UNIX 下你可以使用“:”,Windows 下你可以使用“;”.缩写 dir
        directory -- 清除所有的自定义的源文件搜索路径信息.
        show directories -- 显示定义了的源文件搜索路径.
    运行参数
        set args -- 可指定运行时参数
        show args -- 命令可以查看设置好的运行参数
    运行环境
        path &amp;lt;dir&amp;gt; -- 可设定程序的运行路径
        show paths -- 查看程序的运行路径
        set environment varname=value -- 设置环境变量
        show environment [varname] -- 查看环境变量
    工作目录
        cd &amp;lt;dir&amp;gt; -- 相当于shell的cd命令
        pwd -- 显示当前的所在目录
    程序的输入输出
        info terminal -- 显示你程序用到的终端的模式
        tty -- 命令可以指写输入输出的终端设备
        重定向控制程序输出
    堆栈帧设置
        set backtrace &amp;lt;limit&amp;gt; -- 设置堆栈帧的最大显示数量,默认是没有限制
    调试模式
        set step-mode [on | off] -- step-mode 模式,于是,在进行单步跟踪时,程序不会因为没有debug信息而不停住.这个参数有很利于查看机器码. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 源码查看&lt;/p&gt;

&lt;p&gt;##显示源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list &amp;lt;linenum&amp;gt; -- 显示程序第 linenum 行的周围的源程序.
list &amp;lt;function&amp;gt; -- 显示函数名为 function 的函数的源程序.
list &amp;lt;filename:linenum&amp;gt; -- 哪个文件的哪一行.
list &amp;lt;filename:function&amp;gt; -- 哪个文件中的哪个函数.
list &amp;lt;offset&amp;gt; -- 当前行号的正/负 offset 偏移量那那行.
list -- 显示当前行后面的源程序.
list - -- 显示当前行前面的源程序.
list &amp;lt;first&amp;gt;, &amp;lt;last&amp;gt; -- 显示从 first 行到 last 行之间的源代码.若无 first 则显示从当前行到 last 之间的源代码.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##设置和获得显示源码的行数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set listsize &amp;lt;count&amp;gt; -- 设置一次显示源代码的行数.
show listsize -- 查看当前listsize的设置.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##搜索源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forward-search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
reverse-search &amp;lt;regexp&amp;gt; -- 向前面搜索.正则表达式为 regexp 的关键字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##源代码的内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info line &amp;lt;linenum&amp;gt; -- 查看行号为 linenum 源代码在内存中的地址.
info line &amp;lt;function&amp;gt; -- 查看函数在源代码在内存中的地址.
info line &amp;lt;filename:linenum&amp;gt; -- 查看 filename 文件的第 linenum 行源代码在内存中的地址.
info line &amp;lt;filename:function&amp;gt; -- 查看 filename 文件的 function 函数在源代码在内存中的地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看汇编代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disassemble -- 查看源程序的当前执行时的机器码,这个命令会把目前内存中的指令 dump 出来.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 停止点设置及维护&lt;/p&gt;

&lt;p&gt;##断点(BreakPoint)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置断点:(threadno 指定了线程的 ID,注意,这个 ID 是 gdb 分配的,可以通过 &amp;quot;info threads&amp;quot; 命令来查看正在运行程序中的线程信息)
    break thread &amp;lt;threadno&amp;gt; -- break命令没有参数时,表示在下一条指令处停住.
    break +offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的后面的 offset 行停住.(offiset 为自然数)
    break -offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的前面的 offset 行停住.(offiset 为自然数)
    break &amp;lt;linenum&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在指定行号停住.
    break filename:linenum thread &amp;lt;threadno&amp;gt; -- 在源文件filename的linenum行处停住.
    break &amp;lt;function&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在进入指定函数时停住.
    break filename:function thread &amp;lt;threadno&amp;gt; --在源文件filename的function函数的入口处停住.
    break *address -- 在程序运行的内存地址处停住.
    break ... thread &amp;lt;threadno&amp;gt; if &amp;lt;condition&amp;gt; -- ...可以是上述的参数,condition表示条件,在条件成立时停住.比如在循环境体中,可以设置break if i=100,表示当i为100时停住程序.
    tbreak -- 设置只停止一次的断点.用法和 break 类似
查看断点
    info breakpoints [n]
    info break [n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##观察点(WatchPoint) &amp;ndash; 观察点一般来观察某个表达式(变量也是一种表达式)的值是否有变化了,如果有变化,马上停住程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设在观察点
    watch &amp;lt;expr&amp;gt; -- 为表达式(变量)expr设置一个观察点.一量表达式值有变化时,马上停住程序.
    rwatch &amp;lt;expr&amp;gt; -- 当表达式(变量)expr被读时,停住程序.
    awatch &amp;lt;expr&amp;gt; -- 当表达式(变量)的值被读或被写时,停住程序.
查看观察点
    info watchpoints -- 列出当前所设置了的所有观察点.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##捕捉点(CatchPoint) &amp;ndash; 设置捕捉点来补捉程序运行时的一些事件.如:载入共享库(动态链接库)或是 C++ 的异常《/p&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置捕捉点
    catch &amp;lt;event&amp;gt; -- 当event发生时,停住程序.event可以是下面的内容：
        throw 一个 C++ 抛出的异常.(throw 为关键字)
        catch 一个 C++ 捕捉到的异常.(catch 为关键字)
        exec 调用系统调用 exec 时.(exec 为关键字,目前此功能只在 HP-UX 下有用)
        fork 调用系统调用 fork 时.(fork 为关键字,目前此功能只在 HP-UX 下有用)
        vfork 调用系统调用 vfork 时.(vfork 为关键字,目前此功能只在 HP-UX 下有用)
        load 或 load &amp;lt;libname&amp;gt; 载入共享库(动态链接库)时.(load 为关键字,目前此功能只在 HP-UX 下有用)
        unload 或 unload &amp;lt;libname&amp;gt; 卸载共享库(动态链接库)时.(unload 为关键字,目前此功能只在 HP-UX 下有用)
    tcatch &amp;lt;event&amp;gt; -- 只设置一次捕捉点,当程序停住以后,应点被自动删除.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##维护停止点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;清除停止点
    clear -- 所有的已定义的停止点.
    clear &amp;lt;function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;filename:function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
    clear &amp;lt;filename:linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
删除停止点
    delete [range] -- 删除停止点.其简写命令为 d.
禁用停止点
    disable [range] -- 禁用停止点
启用停止点
    enable [range] -- 启用停止点.
    enable once [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable count [rang] -- 启用停止点 count 次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable delete [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动删除.
停止条件维护 -- 以用 condition 命令来修改断点的条件.(只有break和watch命令支持if,catch目前暂不支持if)
    condition &amp;lt;bnum&amp;gt; &amp;lt;expression&amp;gt; -- 修改断点号为bnum的停止条件为expression.
    condition &amp;lt;bnum&amp;gt; -- 清除断点号为bnum的停止条件.
忽略停止点 N 次
    ignore &amp;lt;bnum&amp;gt; &amp;lt;count&amp;gt; -- 表示忽略断点号为 bnum 的停止条件 count 次.
为停止点设定运行命令
    格式:
    commands [bnum]
           ... command-list ...
           // 为断点号 bnumi写一个命令列表.当程序被该断点停住时,gdb 依次运行命令列表中的命令.
    end
    例如：
    break foo if x&amp;gt;0
    　　commands
           printf &amp;quot;x is %d/n&amp;quot;,x
           continue
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#信号(Signals)&lt;/p&gt;

&lt;p&gt;##添加信号处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle &amp;lt;signal&amp;gt; &amp;lt;keywords...&amp;gt;
在 gdb 中定义一个信号处理.信号 &amp;lt;signal&amp;gt; 可以以 SIG 开头或不以 SIG 开头,可以用定义一个要处理信号的范围(如：SIGIO-SIGKILL,表示处理从 SIGIO 信号到 SIGKILL 的信号,其中包括 SIGIO, SIGIOT, SIGKILL 三个信号),也可以使用关键字 all 来标明要处理所有的信号.一旦被调试的程序接收到信号,运行程序马上会被 gdb 停住,以供调试.其 &amp;lt;keywords&amp;gt; 可以是以下几种关键字的一个或多个.若没有 keywords 则查看奇信号的处理状态
    nostop -- 当被调试的程序收到信号时,gdb 不会停住程序的运行,但会打出消息告诉你收到这种信号.
    stop -- 当被调试的程序收到信号时,gdb 会停住你的程序.
    print -- 当被调试的程序收到信号时,gdb 会显示出一条信息.
    noprint -- 当被调试的程序收到信号时,gdb 不会告诉你收到信号的信息.
    pass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    noignore -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    nopass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    1gnore -- 当被调试的程序收到信号时,gdb 不会让被调试程序来处理这个信号.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看处理信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info signals -- 查看有哪些信号在被 gdb 检测中.
info handle -- 查看有哪些信号在被 gdb 检测中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 程序调试&lt;/p&gt;

&lt;p&gt;##恢复执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;continue [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
fg [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##单步调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step &amp;lt;count&amp;gt; -- 单步跟踪,如果有函数调用,它会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
next &amp;lt;count&amp;gt; -- 同样单步跟踪,如果有函数调用,他不会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跟踪机器指令
       与之一样有相同功能的命令是 “display/i $pc” ,当运行完这个命令后,单步跟踪会在打出程序代码的同时打出机器指令(也就是汇编代码)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stepi 或 si -- 单步跟踪一条机器指令,简写 si
nexti 或 ni -- 单步跟踪一条机器指令,简写 ni
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##函数调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;finish -- 运行程序,直到当前函数完成返回.并打印函数返回时的堆栈地址和返回值及参数值等信息.
return &amp;lt;expression&amp;gt; -- 使函数以 expression 表达式返回出去,忽略还没有执行的语句.若无返回 void 出去
call &amp;lt;expr&amp;gt; -- 表达式中可以一是函数,以此达到强制调用函数的目的.并显示函数的返回值,如果函数返回值是void,那么就不显示.
print 与 printf 也可以做到类似的功能和 call 的不同是,如果函数返回 void,call 则不显示,print 则显示函数返回值,并把该值存入历史数据中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##循环体调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until -- 可以运行程序直到退出循环体.简写 u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##修改变量值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print varname=var -- 修改被调试程序运行时的变量值
set var varname=value -- 修改被调试程序运行时的变变量
whatis varname -- 查看变量的类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跳转执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jump &amp;lt;linespec&amp;gt; -- 指定下一条语句的运行点.&amp;lt;linespce&amp;gt; 可以是文件的行号,可以是 file:line 格式,可以是 +num 这种偏移量格式.表式着下一条运行语句从哪里开始.
jump &amp;lt;address&amp;gt; -- 跳转到指定的程序内存地址运行.&amp;lt;address&amp;gt; 是代码行的内存地址.
注意
    jump 指令不会改变当前的程序栈中的内容,所以,当你从一个函数跳到另一个函数时,当函数运行完返回时进行弹栈操作时必然会发生错误.
    jump 命令只是改变了指令寄存器中的值.于是可以使用 “set $pc” 来更改跳转执行的地址.如： set $pc = 0x485
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##产生信号量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signal &amp;lt;signal&amp;gt; -- 产生一个 signal 信号.UNIX 的系统信号量通常从 1 到 15.所以 &amp;lt;signal&amp;gt; 取值也在这个范围.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 运行是数据&lt;/p&gt;

&lt;p&gt;##查看运行时数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print /&amp;lt;f&amp;gt; &amp;lt;expr&amp;gt; -- 查看当前程序的运行数据.简写 p.
    &amp;lt;expr&amp;gt; 是表达式
        @ -- 是一个和数组有关的操作符,在后面会有更详细的说明.在 @ 左边是数组的地址,右边是数组的长度,eg: array@len
        :: -- 指定一个在文件或是一个函数中的变量.
        {&amp;lt;type&amp;gt;} &amp;lt;addr&amp;gt; --表示一个指向内存地址&amp;lt;addr&amp;gt;的类型为type的一个对象.
    &amp;lt;f&amp;gt;是输出的格式
        d -- 按十进制格式显示变量.
        u -- 按十六进制格式显示无符号整型.
        o -- 按八进制格式显示变量.
        t -- 按二进制格式显示变量.
        a -- 按十六进制格式显示变量.
        c -- 按字符格式显示变量.
        f -- 按浮点数格式显示变量.
    注意:
        1.若出现变量重名,局部变量会隐藏全局变量.若想查看全局变量的值时,可以使用“::”操作符.
        2.可以通过这种形式指定你所想查看的变量 eg:
            *&#39;filename&#39;::variable
            *function::variable
printf &amp;quot;fmt&amp;quot;,arg,... -- 打印格式化字符灿 fmt.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;examine/&amp;lt;n/f/u&amp;gt; &amp;lt;addr&amp;gt; -- 来查看内存地址中的值.简写 x
    &amp;lt;n/f/u&amp;gt;
        n 是一个正整数,表示显示内存的长度,也就是说从当前地址向后显示几个地址的内容.
        f 表示显示的格式
            s -- 按字符串格式显示内存地址内容.
            i -- 查看内存地址的机器指令内容
            x -- 按十六进制格式显示地址内容.
            d -- 按十进制格式显示地址内容.
            u -- 按十六进制格式显示无符号整型.
            o -- 按八进制格式显示地址内容.
            t -- 按二进制格式显示地址内容.
            a -- 按十六进制格式显示地址内容.
            c -- 按字符格式显示地址内容.
            f -- 按浮点数格式显示地址内容.
        u 表示从当前地址往后请求的字节数,如果不指定的话,gdb默认是 4 个 bytes.
            b -- 表示单字节
            h -- 表示双字节
            w -- 表示四字节
            g -- 表示八字节
    &amp;lt;addr&amp;gt; 表示一个内存地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##自动显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置自动显示
    display/&amp;lt;fmt&amp;gt; &amp;lt;expr&amp;gt; -- 自动显示 expr 表达式
    display/&amp;lt;fmt&amp;gt; &amp;lt;addr&amp;gt; -- 自动显示 addr 地址
        fmt 表示显示的格式
        i -- 输出格式为机器指令码,也就是汇编.
        s -- 输出格式为字符串
删除自动显示
    undisplay &amp;lt;range&amp;gt; -- 删除自动显示
    delete display &amp;lt;range&amp;gt; -- 删除自动显示
启用和禁自动显示
    sable display &amp;lt;range&amp;gt; -- 禁用自动显示
    enable display &amp;lt;range&amp;gt; -- 启动自动显示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看栈信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backtrace &amp;lt;n&amp;gt; -- 擦看函数栈信息,简写 bt
    n 若是正数,只打印栈顶上 n 层的栈信息,
    若是负数,只打印栈顶下 n 层的栈信息,
    若无则打印当前的函数调用栈的所有信息
frame -- 会打印出这些信息:栈的层编号,当前的函数名,函数参数值,函数所在文件及行号,函数执行到的语句.
info frame -- 这个命令会打印出更为详细的当前栈层的信息,只不过,大多数都是运行时的内内地址.
info args -- 打印出当前函数的参数名及其值.
info locals -- 打印出当前函数中所有局部变量及其值.
info catch -- 打印出当前的函数中的异常处理信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##切换函数栈位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frame &amp;lt;n&amp;gt; -- 切换到第 n 层函数栈位置,简写 f.
p &amp;lt;n&amp;gt; -- 表示上面移动 n 层,可以不打 n,表示向上移动一层.
down &amp;lt;n&amp;gt; -- 表示向栈的下面移动 n 层,可以不打 n,表示向下移动一层.
select-frame &amp;lt;n&amp;gt; -- 类似 frame 命令.不打印出栈层信息.
up-silently &amp;lt;n&amp;gt; -- 类似 up 命令.不打印出栈层信息.
down-silently &amp;lt;n&amp;gt; -- 类似 down 命令.不打印出栈层信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看寄存器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info registers -- 查看寄存器的情况.(除了浮点寄存器)
info all-registers -- 查看所有寄存器的情况.(包括浮点寄存器)
info registers &amp;lt;regname&amp;gt; -- 查看所指定的寄存器的情况.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##线程查看与切换线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info threads -- 查看当前线程
thread &amp;lt;threadno&amp;gt; -- 切换到 threadno 的线程,简写 t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自定义命令&lt;/p&gt;

&lt;p&gt;##定义一个命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;格式
define comdName
      ...
end
条件语句
if cond_expr
      ...
else
      ...
end
循环语句
while cond_expr
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##定义一个命令的文档信息（在 help cmdName 的时候显示）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document cmdName
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看自定命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help user-define -- 查看所有用户自定义的命令
show user cmdName -- 查看用户定义的 cmdName 的命令.
help cmdName -- 查看用户自定义的 cmdName 的帮助文档
show max-user-call-depth -- 查看用户自定义命令的递归最大深度,缺省是 1024
set-user-call-depth &amp;lt;limit&amp;gt;-- 设置用户自定义命令的递归最大深度.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试命令的使用及总结</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-6</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-6</guid>
      <description>

&lt;p&gt;#gdb调试命令的使用及总结
1.基本命令&lt;/p&gt;

&lt;p&gt;1）进入GDB　　#gdb test&lt;/p&gt;

&lt;p&gt;　　test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb) 。&lt;/p&gt;

&lt;p&gt;2）查看源码　　(gdb) l&lt;/p&gt;

&lt;p&gt;　　源码会进行行号提示。&lt;/p&gt;

&lt;p&gt;　　如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。&lt;/p&gt;

&lt;p&gt;3）设置断点　　(gdb) b 6&lt;/p&gt;

&lt;p&gt;　　这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。&lt;/p&gt;

&lt;p&gt;4）查看断点处情况　　(gdb) info b&lt;/p&gt;

&lt;p&gt;　　可以键入&amp;rdquo;info b&amp;rdquo;来查看断点处情况，可以设置多个断点；&lt;/p&gt;

&lt;p&gt;5）运行代码　　(gdb) r&lt;/p&gt;

&lt;p&gt;6）显示变量值　　(gdb) p n&lt;/p&gt;

&lt;p&gt;　　在程序暂停时，键入&amp;rdquo;p 变量名&amp;rdquo;(print)即可；&lt;/p&gt;

&lt;p&gt;　　GDB在显示变量值时都会在对应值之前加上&amp;rdquo;$N&amp;rdquo;标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写作&amp;rdquo;$N&amp;rdquo;，而无需写冗长的变量名；&lt;/p&gt;

&lt;p&gt;7）观察变量　　(gdb) watch n&lt;/p&gt;

&lt;p&gt;在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令&amp;rdquo;watch&amp;rdquo;来观察变量的变化情况，GDB在&amp;rdquo;n&amp;rdquo;设置了观察点；&lt;/p&gt;

&lt;p&gt;8）单步运行　　(gdb) n&lt;/p&gt;

&lt;p&gt;9）程序继续运行　　(gdb) c&lt;/p&gt;

&lt;p&gt;　　使程序继续往下运行，直到再次遇到断点或程序结束；&lt;/p&gt;

&lt;p&gt;10）退出GDB　　(gdb) q&lt;/p&gt;

&lt;p&gt;2.断点调试&lt;/p&gt;

&lt;p&gt;命令格式　　                      例子             　　　　　　作用&lt;/p&gt;

&lt;p&gt;break + 设置断点的行号　　break n　　　　　　在n行处设置断点&lt;/p&gt;

&lt;p&gt;tbreak + 行号或函数名　　tbreak n/func　　　　设置临时断点，到达后被自动删除&lt;/p&gt;

&lt;p&gt;break + filename + 行号　　break main.c:10　　用于在指定文件对应行设置断点&lt;/p&gt;

&lt;p&gt;break + &lt;0x...&gt;　　break 0x3400a　　　　　　用于在内存某一位置处暂停&lt;/p&gt;

&lt;p&gt;break + 行号 + if + 条件　　break 10 if i==3　　　用于设置条件断点，在循环中使用非常方便&lt;/p&gt;

&lt;p&gt;info breakpoints/watchpoints [n]　　info break　　n表示断点号，查看断点/观察点的情况&lt;/p&gt;

&lt;p&gt;clear + 要清除的断点行号　　clear 10　　　　用于清除对应行的断点，要给出断点的行号，清除时GDB会给出提示&lt;/p&gt;

&lt;p&gt;delete + 要清除的断点编号　　delete 3　　　　用于清除断点和自动显示的表达式的命令，要给出断点的编号，清除时GDB不会给出任何提示&lt;/p&gt;

&lt;p&gt;disable/enable + 断点编号　　disable 3　　　　让所设断点暂时失效/使能，如果要让多个编号处的断点失效/使能，可将编号之间用空格隔开&lt;/p&gt;

&lt;p&gt;awatch/watch + 变量　　awatch/watch i　　　　设置一个观察点，当变量被读出或写入时程序被暂停&lt;/p&gt;

&lt;p&gt;rwatch + 变量　　　　　　rwatch i　　　　　　　　设置一个观察点，当变量被读出时，程序被暂停&lt;/p&gt;

&lt;p&gt;catch　　　　　　　　　　　　　　　　　　设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常&lt;/p&gt;

&lt;p&gt;tcatch　　　　　　　　　　　　　　　　　　只设置一次捕捉点，当程序停住以后，应点被自动删除&lt;/p&gt;

&lt;p&gt;3.数据命令&lt;/p&gt;

&lt;p&gt;display +表达式　　display a　　用于显示表达式的值，每当程序运行到断点处都会显示表达式的值&lt;/p&gt;

&lt;p&gt;info display　　　　　　用于显示当前所有要显示值的表达式的情况&lt;/p&gt;

&lt;p&gt;delete + display 编号　　delete 3　　用于删除一个要显示值的表达式，被删除的表达式将不被显示&lt;/p&gt;

&lt;p&gt;disable/enable + display 编号　　disable/enable 3　　使一个要显示值的表达式暂时失效/使能&lt;/p&gt;

&lt;p&gt;undisplay + display 编号　　undisplay 3　　用于结束某个表达式值的显示&lt;/p&gt;

&lt;p&gt;whatis + 变量　　whatis i　　显示某个表达式的数据类型&lt;/p&gt;

&lt;p&gt;print(p) + 变量/表达式　　p n　　用于打印变量或表达式的值&lt;/p&gt;

&lt;p&gt;set + 变量 = 变量值　　set i = 3　　改变程序中某个变量的值&lt;/p&gt;

&lt;p&gt;　　在使用print命令时，可以对变量按指定格式进行输出，其命令格式为print /变量名 + 格式&lt;/p&gt;

&lt;p&gt;　　其中常用的变量格式：x：十六进制；d：十进制；u：无符号数；o：八进制；c：字符格式；f：浮点数。&lt;/p&gt;

&lt;p&gt;4.调试运行环境相关命令&lt;/p&gt;

&lt;p&gt;set args　　set args arg1 arg2　　设置运行参数&lt;/p&gt;

&lt;p&gt;show args　　show args　　参看运行参数&lt;/p&gt;

&lt;p&gt;set width + 数目　　set width 70　　设置GDB的行宽&lt;/p&gt;

&lt;p&gt;cd + 工作目录　　cd ../　　切换工作目录&lt;/p&gt;

&lt;p&gt;run　　r/run　　程序开始执行&lt;/p&gt;

&lt;p&gt;step(s)　　s　　进入式（会进入到所调用的子函数中）单步执行，进入函数的前提是，此函数被编译有debug信息&lt;/p&gt;

&lt;p&gt;next(n)　　n　　非进入式（不会进入到所调用的子函数中）单步执行&lt;/p&gt;

&lt;p&gt;finish　　finish　　一直运行到函数返回并打印函数返回时的堆栈地址和返回值及参数值等信息&lt;/p&gt;

&lt;p&gt;until + 行数　　u 3　　运行到函数某一行&lt;/p&gt;

&lt;p&gt;continue&amp;copy;　　c　　执行到下一个断点或程序结束&lt;/p&gt;

&lt;p&gt;return &amp;lt;返回值&amp;gt;　　return 5　　改变程序流程，直接结束当前函数，并将指定值返回&lt;/p&gt;

&lt;p&gt;call + 函数　　call func　　在当前位置执行所要运行的函数&lt;/p&gt;

&lt;p&gt;5.堆栈相关命令&lt;/p&gt;

&lt;p&gt;backtrace/bt　　bt　　用来打印栈帧指针，也可以在该命令后加上要打印的栈帧指针的个数，查看程序执行到此时，是经过哪些函数呼叫的程序，程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）。每个函数及其变量都被分配了一个“帧”，最近调用的函数在 0 号帧中（“底部”帧）&lt;/p&gt;

&lt;p&gt;frame　　frame 1　　用于打印指定栈帧&lt;/p&gt;

&lt;p&gt;info reg　　info reg　　查看寄存器使用情况&lt;/p&gt;

&lt;p&gt;info stack　　info stack　　查看堆栈使用情况&lt;/p&gt;

&lt;p&gt;up/down　　up/down　　跳到上一层/下一层函数&lt;/p&gt;

&lt;p&gt;6.跳转执行&lt;/p&gt;

&lt;p&gt;jump  指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。&lt;/p&gt;

&lt;p&gt;7.信号命令&lt;/p&gt;

&lt;p&gt;signal 　　signal SIGXXX 　　产生XXX信号，如SIGINT。一种速查Linux查询信号的方法：# kill -l&lt;/p&gt;

&lt;p&gt;handle 　　在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几种关键字的一个或多个：
　　nostop/stop
　　　　当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号/GDB会停住你的程序&lt;br /&gt;
　　print/noprint
　　　　当被调试的程序收到信号时，GDB会显示出一条信息/GDB不会告诉你收到信号的信息
　　pass
　　noignore
　　　　当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。
　　nopass
　　ignore
　　　　当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
　　info signals
　　info handle
　　　　可以查看哪些信号被GDB处理，并且可以看到缺省的处理方式&lt;/p&gt;

&lt;p&gt;　　single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。&lt;/p&gt;

&lt;p&gt;8.运行Shell命令&lt;/p&gt;

&lt;p&gt;　　如(gdb)shell ls来运行ls。　　&lt;/p&gt;

&lt;p&gt;9.更多程序运行选项和调试&lt;/p&gt;

&lt;p&gt;1、程序运行参数。
　　set args 可指定运行时参数。（如：set args 10 20 30 40 50）
　　show args 命令可以查看设置好的运行参数。
2、运行环境。
　　path 可设定程序的运行路径。
　　show paths 查看程序的运行路径。&lt;/p&gt;

&lt;p&gt;　　set environment varname [=value] 设置环境变量。如：set env USER=hchen&lt;/p&gt;

&lt;p&gt;　　show environment [varname] 查看环境变量。&lt;/p&gt;

&lt;p&gt;3、工作目录。&lt;/p&gt;

&lt;p&gt;　　cd　　  相当于shell的cd命令。&lt;/p&gt;

&lt;p&gt;　　pwd　　显示当前的所在目录。
4、程序的输入输出。
　　info terminal 显示你程序用到的终端的模式。
　　使用重定向控制程序输出。如：run &amp;gt; outfile
　　tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb&lt;/p&gt;

&lt;p&gt;5、调试已运行的程序&lt;/p&gt;

&lt;p&gt;两种方法：
　　(1)在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在运行的程序。
　　(2)先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。&lt;/p&gt;

&lt;p&gt;6、暂停 / 恢复程序运行　　当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops），如果要恢复程序运行，可以使用c或是continue命令。&lt;/p&gt;

&lt;p&gt;7、线程（Thread Stops）&lt;/p&gt;

&lt;p&gt;如果程序是多线程，可以定义断点是否在所有的线程上，或是在某个特定的线程。
　　break thread
　　break thread if &amp;hellip;
　　linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread 则表示断点设在所有线程上面。还可以为某线程指定断点条件。如：
　　(gdb) break frik.c:13 thread 28 if bartab &amp;gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。&lt;/p&gt;

&lt;p&gt;10.调试core文件&lt;/p&gt;

&lt;p&gt;Core Dump：Core的意思是内存，Dump的意思是扔出来，堆出来。开发和使用Unix程序时，有时程序莫名其妙的down了，却没有任何的提示(有时候会提示core dumped)，这时候可以查看一下有没有形如core.进程号的文件生成，这个文件便是操作系统把程序down掉时的内存内容扔出来生成的, 它可以做为调试程序的参考&lt;/p&gt;

&lt;p&gt;(1)生成Core文件
　　一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。修改后才能生成core文件。&lt;/p&gt;

&lt;p&gt;　　#设置core大小为无限
　　ulimit -c unlimited
　　#设置文件大小为无限
　　ulimit unlimited&lt;/p&gt;

&lt;p&gt;　　这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限&lt;/p&gt;

&lt;p&gt;core文件生成路径:输入可执行文件运行命令的同一路径下。若系统生成的core文件不带其他任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。&lt;/p&gt;

&lt;p&gt;1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。
可通过以下命令修改此文件：
echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/kernel/core_uses_pid&lt;/p&gt;

&lt;p&gt;2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。
可通过以下命令修改此文件：
echo &amp;ldquo;/corefile/core-%e-%p-%t&amp;rdquo; &amp;gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳
以下是参数列表:
    %p - insert pid into filename 添加pid
    %u - insert current uid into filename 添加当前uid
    %g - insert current gid into filename 添加当前gid
    %s - insert signal that caused the coredump into the filename 添加导致产生core的信号
    %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
    %h - insert hostname where the coredump happened into filename 添加主机名
    %e - insert coredumping executable name into filename 添加命令名&lt;/p&gt;

&lt;p&gt;(2)用gdb查看core文件&lt;/p&gt;

&lt;p&gt;　　发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.
　　gdb [exec file] [core file]
　　如:
　　gdb ./test core&lt;/p&gt;

&lt;p&gt;　　或gdb ./a.out
 　　core-file core.xxxx
　　gdb后, 用bt命令backtrace或where查看程序运行到哪里, 来定位core dump的文件-&amp;gt;行.&lt;/p&gt;

&lt;p&gt;　　待调试的可执行文件，在编译的时候需要加-g，core文件才能正常显示出错信息&lt;/p&gt;

&lt;p&gt;　　1）gdb -core=core.xxxx
　　file ./a.out
　　bt
　　2）gdb -c core.xxxx
　　file ./a.out
　　bt&lt;/p&gt;

&lt;p&gt;(3)用gdb实时观察某进程crash信息&lt;/p&gt;

&lt;p&gt;　　启动进程
　　gdb -p PID
　　c
　　运行进程至crash
　　gdb会显示crash信息
　　bt&lt;/p&gt;

&lt;p&gt;#gdb调试命令说明&lt;/p&gt;

&lt;h1 id=&#34;1-对于在应用程序中加入参数进行调试的方法:a705e2985626516966a98e6f6a34e407&#34;&gt;1: 对于在应用程序中加入参数进行调试的方法：&lt;/h1&gt;

&lt;p&gt;直接用 gdb app -p1 -p2 这样进行调试是不行的。
   需要像以下这样使用：
    #gdb app
    (gdb) r -p1 -p2
    或者在运行run命令前使用set args命令：
    （gdb） set args p1 p2
    可以用show args 命令来查看&lt;/p&gt;

&lt;h1 id=&#34;2-加入断点:a705e2985626516966a98e6f6a34e407&#34;&gt;2. 加入断点：&lt;/h1&gt;

&lt;p&gt;break &lt;linenumber&gt;
   break &lt;funcName&gt;
   break +offset
   break -offset
   (在当前行号的前面或后面的offset行停住。)&lt;/p&gt;

&lt;p&gt;break filename:linenum
   在源文件filename的linenum行处停住。&lt;/p&gt;

&lt;p&gt;break filename:function
   在源文件filename的function函数的入口处停住。&lt;/p&gt;

&lt;p&gt;break &amp;hellip; if
  &amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设置     break if i=100，表示当i为100时停住程序。&lt;/p&gt;

&lt;h1 id=&#34;3-查看运行时的堆栈:a705e2985626516966a98e6f6a34e407&#34;&gt;3. 查看运行时的堆栈：&lt;/h1&gt;

&lt;p&gt;使用bt命令&lt;/p&gt;

&lt;h1 id=&#34;4-打印某个变量的值:a705e2985626516966a98e6f6a34e407&#34;&gt;4. 打印某个变量的值：&lt;/h1&gt;

&lt;p&gt;print val&lt;/p&gt;

&lt;h1 id=&#34;5-单步-n:a705e2985626516966a98e6f6a34e407&#34;&gt;5. 单步： n&lt;/h1&gt;

&lt;p&gt;继续运行：　c
　　step
　　单步跟踪，如果有函数调用，他会进入该函数。
　　next
　　同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。
　　set step-mode
　　set step-mode on
　　打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。
　　set step-mod off
　　关闭step-mode模式。
　　finish
　　运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
　　until 或 u
　　当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。&lt;/p&gt;

&lt;h1 id=&#34;6-在gdb中执行shell命令:a705e2985626516966a98e6f6a34e407&#34;&gt;6.在gdb中执行shell命令：&lt;/h1&gt;

&lt;p&gt;　在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
　eg. shell make&lt;/p&gt;

&lt;h1 id=&#34;7-运行环境:a705e2985626516966a98e6f6a34e407&#34;&gt;7. 运行环境&lt;/h1&gt;

&lt;p&gt;可设定程序的运行路径。
  show paths 查看程序的运行路径。
  set environment varname [=value] 设置环境变量。如：set env USER=hchen
  show environment [varname] 查看环境变量。&lt;/p&gt;

&lt;h1 id=&#34;8-观察点-watchpoint:a705e2985626516966a98e6f6a34e407&#34;&gt;8.观察点（WatchPoint）&lt;/h1&gt;

&lt;p&gt;观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程 序。我们有下面的几种方法来设置观察点：
  watch
   为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
  rwatch
   当表达式（变量）expr被读时，停住程序。
  awatch
   当表达式（变量）的值被读或被写时，停住程序。
  info watchpoints
   列出当前所设置了的所有观察点。&lt;/p&gt;

&lt;h1 id=&#34;9-维护breakpoint:a705e2985626516966a98e6f6a34e407&#34;&gt;9. 维护breakpoint&lt;/h1&gt;

&lt;p&gt;clear
    清除所有的已定义的停止点。
   clear func
    清除所有设置在函数上的停止点。
  delete [breakpoints] [range&amp;hellip;]
  删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。
  比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。
  disable [breakpoints] [range&amp;hellip;]
   disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止 点。简写命令是dis.
  enable [breakpoints] [range&amp;hellip;]
   enable所指定的停止点，breakpoints为停止点号。&lt;/p&gt;

&lt;h1 id=&#34;10-程序变量:a705e2985626516966a98e6f6a34e407&#34;&gt;10、程序变量&lt;/h1&gt;

&lt;p&gt;查看文件中某变量的值：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
gdb) p &amp;lsquo;f2.c&amp;rsquo;::x&lt;/p&gt;

&lt;p&gt;查看数组的值
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。&lt;/p&gt;

&lt;h1 id=&#34;10-1-输出格式:a705e2985626516966a98e6f6a34e407&#34;&gt;10-1.输出格式&lt;/h1&gt;

&lt;p&gt;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：&lt;/p&gt;

&lt;p&gt;x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &amp;lsquo;e&amp;rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101&lt;/p&gt;

&lt;h1 id=&#34;11-查看内存:a705e2985626516966a98e6f6a34e407&#34;&gt;11.查看内存&lt;/h1&gt;

&lt;p&gt;使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。
u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。&lt;/p&gt;

&lt;p&gt;n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。&lt;/p&gt;

&lt;h1 id=&#34;12-自动显示:a705e2985626516966a98e6f6a34e407&#34;&gt;12.自动显示&lt;/h1&gt;

&lt;p&gt;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。
display
display/
display/ expr
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。&lt;/p&gt;

&lt;p&gt;格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc&lt;/p&gt;

&lt;p&gt;undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。&lt;/p&gt;

&lt;p&gt;disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。&lt;/p&gt;

&lt;p&gt;info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。&lt;/p&gt;

&lt;h1 id=&#34;13-设置显示选项:a705e2985626516966a98e6f6a34e407&#34;&gt;13. 设置显示选项&lt;/h1&gt;

&lt;p&gt;set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
show print address
查看当前地址显示选项是否打开。&lt;/p&gt;

&lt;p&gt;set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。&lt;/p&gt;

&lt;p&gt;set print array off
show print array&lt;/p&gt;

&lt;p&gt;set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。&lt;/p&gt;

&lt;p&gt;show print elements
查看print elements的选项信息。&lt;/p&gt;

&lt;p&gt;set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。&lt;/p&gt;

&lt;p&gt;set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。&lt;/p&gt;

&lt;h1 id=&#34;14-关于显示源码list:a705e2985626516966a98e6f6a34e407&#34;&gt;14.关于显示源码list&lt;/h1&gt;

&lt;p&gt;以下是list命令的說明。
參數                                     說明
list filename:number  列出某檔案的第幾行，檔案是可省略的。
list [function]                  列出某函數的程式碼
list                                       繼續印出程式碼
list -                                     印出上一次list的程式碼的前一段程式碼(類似向上翻動)
show listsize   顯示現在一次印出幾行
set listsize  設定一次印出幾行&lt;/p&gt;

&lt;p&gt;备常用命令：&lt;/p&gt;

&lt;h2 id=&#34;１-常看源码-list-ｌ:a705e2985626516966a98e6f6a34e407&#34;&gt;１.常看源码：list（ｌ）　&lt;/h2&gt;

&lt;p&gt;　　list　＜linenumber＞　行号
　　list　＜＋offset＞　当前行号的正偏移
　　list　＜－offset＞　当前行号的负偏移
　　list　＜filename：linenumber＞　哪个文件的哪一行
　　list　＜function＞　函数名
　　list　＜filename：function＞　文件的哪个函数
　　list　＜＊address＞　程序运行时语句在内存中的地址&lt;/p&gt;

&lt;h2 id=&#34;２-设置断点-break-ｂ:a705e2985626516966a98e6f6a34e407&#34;&gt;２．设置断点：break（ｂ）&lt;/h2&gt;

&lt;p&gt;　　break　＜function＞　指定函数断点
　　break　＜linenumber＞　指定行号断点
　　break　＜＋offset／－offset＞　当前行号的正／负偏移
　　break　＜filename：linenumber＞　哪个文件的哪一行
　　break　＜＊address＞　运行中的内存地址
　　break　不带参数，下一条指令停止处
　　break &amp;hellip;　if　＜condition＞　在运行中，当condition条件满足时停止。
　　　　ｅｇ．　break　if　ｉ＝100 //当i=100时，立即停止
                 break foo if i=100   //断点设置在foo中，断点条件是i-100, 一点在函数foo中，i的值等于100,被停止。&lt;/p&gt;

&lt;h2 id=&#34;３-查看信息-info:a705e2985626516966a98e6f6a34e407&#34;&gt;３．查看信息： info&lt;/h2&gt;

&lt;p&gt;　　info　break　查看断点信息
    info locals 打印出当前函数中所有局部变量及其值
　　info　stack　查看栈中信息
    info frame 更详细的栈层地址信息
　　info　args　查看参数信息
　　info　registers／info　all－registers　查看（所有）寄存器信息
　　info　sources　查看项目的源代码信息&lt;/p&gt;

&lt;h2 id=&#34;４-维护breakpoint-disable-enable-clear-delete:a705e2985626516966a98e6f6a34e407&#34;&gt;４．维护breakpoint：disable/enable/clear/delete&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; disable(dis) 【breakpoints】 【range...】
   如果没有参数，则停止所有的断点，
 enable 【breakpoints】【range】
 clear &amp;lt;function&amp;gt;/&amp;lt;filename:function&amp;gt;/&amp;lt;linenum&amp;gt;/&amp;lt;filename:linenum&amp;gt;
    清楚已定义的停止点
  delete [breakpoints] [ranga...]
     删除指定的断点
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;５-恢复程序运行:a705e2985626516966a98e6f6a34e407&#34;&gt;５．恢复程序运行：&lt;/h2&gt;

&lt;p&gt;　　continue（c）
　　&lt;/p&gt;

&lt;h2 id=&#34;6-until和finish:a705e2985626516966a98e6f6a34e407&#34;&gt;6.until和finish&lt;/h2&gt;

&lt;p&gt;until 跳出循环比较有用
    help finish
     Execute until selected stack frame returns.
     Upon return, the value returned is printed and put in the value history.
  finish 用来跳出函数比较有用。
    help until
     Execute until the program reaches a source line greater than the current
     or a specified location (same args as break command) within the current frame&lt;/p&gt;

&lt;p&gt;##一、多线程调试&lt;br /&gt;
多线程调试重要就是下面几个命令：&lt;br /&gt;
info thread 查看当前进程的线程。&lt;br /&gt;
thread &lt;ID&gt; 切换调试的线程为指定ID的线程。&lt;br /&gt;
break file.c:100 thread all  在file.c文件第100行处为所有经过这里的线程设置断点。   set scheduler-locking off|on|step，这个是问得最多的。&lt;br /&gt;
  * 在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。&lt;br /&gt;
  * off 不锁定任何线程，也就是所有线程都执行，这是默认值。&lt;br /&gt;
  * on 只有当前被调试程序会执行。&lt;br /&gt;
  * step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;

&lt;p&gt;##二、调试宏
这个问题超多。在GDB下，我们无法print宏定义，因为宏是预编译的。但是我们还是有办法来调试宏，这个需要GCC的配合。&lt;br /&gt;
在GCC编译程序的时候，加上-ggdb3参数，这样，你就可以调试宏了。&lt;br /&gt;
另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。&lt;br /&gt;
info macro – 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。&lt;br /&gt;
macro – 你可以查看宏展开的样子。&lt;/p&gt;

&lt;p&gt;##三、源文件
这个问题问的也是很多的，太多的朋友都说找不到源文件。在这里我想提醒大家做下面的检查：&lt;br /&gt;
编译程序员是否加上了-g参数以包含debug信息。 路径是否设置正确了。使用GDB的directory命令来设置源文件的目录。&lt;br /&gt;
下面给一个调试/bin/ls的示例（ubuntu下）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get sourcecoreutils  
$ sudoapt-get installcoreutils-dbgsym  
$ gdb /bin/ls  
GNU gdb (GDB) 7.1-ubuntu  
(gdb) list main  
1192    ls.c: No such fileor directory.  
inls.c  
(gdb) directory ~/src/coreutils-7.4/src/  
Source directories searched: /home/hchen/src/coreutils-7.4:$cdir:$cwd  
(gdb) list main  
1192        }  
1193    }  
1194  
1195    int  
1196    main (int argc, char **argv)  
1197    {  
1198      int i;  
1199      struct pending *thispend;  
1200      int n_files;  
1201  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##四、条件断点
条件断点是语法是：&lt;code&gt;break  [where] if [condition]&lt;/code&gt;，这种断点真是非常管用。尤其是在一个循环或递归中，或是要监视某个变量。&lt;br /&gt;
注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。&lt;/p&gt;

&lt;p&gt;##五、命令行参数
有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。&lt;br /&gt;
其实，有两种方法：&lt;br /&gt;
- gdb命令行的 –args 参数&lt;br /&gt;
- gdb环境中 set args命令。&lt;/p&gt;

&lt;p&gt;##六、gdb的变量
有时候，在调试程序时，我们不单单只是查看运行时的变量，我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，或是switch的分支语句。使用set命令可以修改程序中的变量。&lt;br /&gt;
另外，你知道gdb中也可以有变量吗？就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set$i = 0

(gdb) p a[$i++]

...  #然后就一路回车下去了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。&lt;/p&gt;

&lt;p&gt;##七、x命令
也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。&lt;br /&gt;
- x/x 以十六进制输出&lt;br /&gt;
- x/d 以十进制输出&lt;br /&gt;
- x/c 以单字符输出&lt;br /&gt;
- x/i  反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）&lt;br /&gt;
- x/s 以字符串输出&lt;/p&gt;

&lt;p&gt;##八、command命令
有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) breakfunc
Breakpoint 1 at 0x3475678: filetest.c, line 12.
(gdb) command1
Type commands forwhen breakpoint 1 is hit, one per line.
End with a line saying just &amp;quot;end&amp;quot;.
&amp;gt;print arg1
&amp;gt;print arg2
&amp;gt;print arg3
&amp;gt;end
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。&lt;/p&gt;

&lt;p&gt;#设置core环境
uname -a 查看机器参数&lt;br /&gt;
ulimit -a 查看默认参数&lt;br /&gt;
ulimit -c 1024  设置core文件大小为1024&lt;br /&gt;
ulimit -c unlimit 设置core文件大小为无限&lt;/p&gt;

&lt;p&gt;多线程如果dump，多为段错误，一般都涉及内存非法读写。可以这样处理，使用下面的命令打开系统开关，让其可以在死掉的时候生成 core文件。&lt;br /&gt;
ulimit -c unlimited&lt;/p&gt;

&lt;p&gt;#线程调试命令
1. (gdb)info threads&lt;br /&gt;
显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。
前面有*的是当前调试的线程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;(gdb)thread ID&lt;br /&gt;
切换当前调试的线程为指定ID的线程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)thread apply ID1 ID2 command&lt;br /&gt;
让一个或者多个线程执行GDB命令command。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)thread apply all command&lt;br /&gt;
让所有被调试线程执行GDB命令command。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)set scheduler-locking off|on|step&lt;br /&gt;
估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;off 不锁定任何线程，也就是所有线程都执行，这是默认值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;on 只有当前被调试程序会执行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//显示线程堆栈信息&lt;br /&gt;
6. (gdb) bt&lt;br /&gt;
察看所有的调用栈&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;(gdb) f 3
调用框层次&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb) i locals&lt;br /&gt;
显示所有当前调用栈的所有变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>内存泄露</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-4</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-4</guid>
      <description>&lt;p&gt;PCIe应用程序调试时，发现程序出现内存泄露，经过自己的摸索，以及向软件同学请教，最终解决了此问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;现象描述&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;应用程序开发环境为VC++,运用其debug功能进行单步调试时，程序总是报出内存泄露的错误，报告内容如下所示：&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;Detected memory leaks!
Dumping objects -&amp;gt;
strcore.cpp(118) : {143} normal block at 0x009A3E60, 53 bytes long.
 Data: &amp;lt;    (   (   F:\p&amp;gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70
Object dump complete.
The thread 0x9BC has exited with code 0 (0x0).
The program &#39;F:\program\SP5301\SP5301GUI\Debug\SP5301GUI.exe&#39; has exited with code 0 (0x0).
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;经过网上查阅相关资料，得知报告中相关参数含义如下：&lt;/p&gt;

&lt;p&gt;118：内存泄露的位置在strcore.cpp中第118行&lt;/p&gt;

&lt;p&gt;143：内存分配编号。 内存可能是在多次分配之后才出现泄露。
    normal block：块类型为普通型。
    0x009A3E60：内存位置。
    53 bytes long：块大小为53字节。
    第四行显示前 16 字节的内容为“&amp;lt; ( (F:\p&amp;gt; 01 00 00 00 28 00 00 00 28 00 00 00 46 3A 5C 70”。&lt;/p&gt;

&lt;p&gt;第五行显示内存泄露的线程，以及返回值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调试过程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然报告中显示内存泄露的位置在strcore.cpp中第118行。但是，此文件不在我的工程文件中。那么它应该是在程序运行时被调用过。而且它可能被多次调用。到底是哪次调用时出现的内存泄露，我们不得而知。为了解决内存泄露问题，准确定位内存泄露的位置是关键。&lt;/p&gt;

&lt;p&gt;首先进入单步调试，然后打开VC++菜单中view-&amp;gt;debug windows-&amp;gt;Memory。通过报告中给出的内存地址0x009A3E60，查看该地址存储的内容为&amp;rdquo;F:\program\SP5301\s6_tfg484_pcie\testdata.txt&amp;rdquo;。结合程序内容，我猜测此字符串应该为我定义的字符串指针filepath。打开watch窗口，查看filepath的值，发现果然与上面看到的一致。于是定位了内存泄露的位置为filepath变量。&lt;/p&gt;

&lt;p&gt;此字符串指针最初是在一个类里面定义的。最后赋给它的值是一个文件的路径。怀疑是该指针最后没有成功释放才导致的内存泄露。于是，我将filepath从类里面移出来，放在函数里面作为局部变量来定义。最终解决了内存泄露问题。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;归纳总结&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。&lt;/p&gt;

&lt;p&gt;常见的内存错误及其对策如下：&lt;/p&gt;

&lt;p&gt;(1)      内存分配未成功，却使用了它。&lt;/p&gt;

&lt;p&gt;编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。&lt;/p&gt;

&lt;p&gt;(2)      内存分配虽然成功，但是尚未初始化就引用它。&lt;/p&gt;

&lt;p&gt;犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。&lt;/p&gt;

&lt;p&gt;(3)      内存分配成功并且已经初始化，但操作越过了内存的边界。&lt;/p&gt;

&lt;p&gt;例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。&lt;/p&gt;

&lt;p&gt;(4)      忘记了释放内存，造成内存泄露。&lt;/p&gt;

&lt;p&gt;含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。&lt;/p&gt;

&lt;p&gt;动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。&lt;/p&gt;

&lt;p&gt;(5)      释放了内存却继续使用它。&lt;/p&gt;

&lt;p&gt;有三种情况：&lt;/p&gt;

&lt;p&gt;A.        程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。&lt;/p&gt;

&lt;p&gt;B.        函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。&lt;/p&gt;

&lt;p&gt;C.        使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。&lt;/p&gt;

&lt;p&gt;在产品的开发中，通过对当前系统消耗内存总量的统计，可以对产品所需内存总量进行精确的评估，从而选择合适的内存芯片与大小，降低产品的成本。在遇到内存泄露类问题时，经常会对此束手无策，本文通过对proc下进程相关的文件进行分析，精确评估系统消耗内存的大小，还可以对内存泄露类问题的解决提供一种定位手段。
       Linux在内存使用上的原则是：如果内存充足，不用白不用，尽量使用内存来缓存一些文件，从而加快进程的运行速度，而当内存不足时，会通过相应的内存回收策略收回cache内存，供进程使用。&lt;/p&gt;

&lt;p&gt;一、系统总内存的分析。
可以从proc目录下的meminfo文件了解到当前系统内存的使用情况汇总，其中可用的物理内存=memfree+buffers+cached，当memfree不够时，内核会通过回写机制(pdflush线程)把cached和buffered内存回写到后备存储器，从而释放相关内存供进程使用，或者通过手动方式显式释放cache内存
       echo 3 &amp;gt; /proc/sys/vm/drop_caches&lt;/p&gt;

&lt;p&gt;下图是海思平台下当前系统内存的总体使用情况，其中可以看到，系统消耗掉了29M的内存，下面继续分析这些内存都是被谁消耗掉了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/meminfo
MemTotal:        68956 kB
MemFree:         18632 kB
Buffers:          4096 kB
Cached:          17260 kB
SwapCached:          0 kB
Active:          21304 kB
Inactive:        19248 kB
SwapTotal:           0 kB
SwapFree:            0 kB
Dirty:               0 kB
Writeback:           0 kB
AnonPages:       19216 kB
Mapped:           2472 kB
Slab:             6900 kB
SReclaimable:      924 kB
SUnreclaim:       5976 kB
PageTables:        460 kB
NFS_Unstable:        0 kB
Bounce:              0 kB
CommitLimit:     62060 kB
Committed_AS:    28864 kB
VmallocTotal:   442368 kB
VmallocUsed:     46984 kB
VmallocChunk:   393212 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、进程使用内存的统计
在32位操作系统中，每个进程拥有4G的虚拟内存空间，其中0~3GB是每个进程的私有用户空间，这个空间对系统中其他进程是不可见的。3~4GB是linux内核空间，由系统所有的进程以及内核所共享的。通过访问/proc/{pid}/下相关文件，可以了解每个线程虚拟内存空间的使用情况，从而了解每个线程所消耗内存的多少。
由于我们的产品都是使用多线程方式实现的，多个线程共享一个进程的用户态虚拟地址空间，虚拟地址空间包含若干区域，主要有如下几个区域：
1、当前执行文件的代码段，该代码段称为text段。
2、执行文件的数据段，主要存储执行文件用到的全局变量，静态变量。
3、存储全局变量和动态产生的数据的堆。
4、用于保存局部变量和实现函数调用的栈。
5、采用mmap方式映射到虚拟地址空间中的内存段&lt;/p&gt;

&lt;p&gt;所以只需要查看任意一个线程的用户态虚拟地址空间分配即可知道属于同一进程的所有线程占用总内存的大小。可以通过查看/proc/{pid}/maps文件来获取相关的虚拟地址空间内容，下文摘列部分典型的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat /proc/568/maps
00008000-0036a000 r-xp 00000000 00:0e 236        /home/hik/hicore
00372000-003a5000 rw-p 00362000 00:0e 236        /home/hik/hicore
003a5000-00e28000 rwxp 003a5000 00:00 0          [heap]
40000000-40005000 r-xp 00000000 01:00 94         /lib/ld-uClibc.so.0
416db000-41770000 rw-s c2005000 00:0f 68         /dev/mem

b51fc000-b5200000 rwxp b51fc000 00:00 0
…….
be1fc000-be200000 rwxp be1fc000 00:00 0
be93b000-be950000 rwxp befeb000 00:00 0          [stack]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一行：从r-xp可知其权限为只读、可执行，该段内存地址对应于执行文件的
代码段，程序的代码段需加载到内存中才可以执行。由于其只读，不会
被修改，所以在整个系统内共享。
第二行：从rw-p可知其权限为可读写，不可执行，该段内存地址对应于执行文件的数据段，存放执行文件所用到的全局变量、静态变量。
第三行：从rwxp可知其权限是可读写，可执行，地址空间向上增长，而且不对应文件，是堆段，进程使用malloc申请的内存放在堆段。每个进程只有一个堆段，不论是主进程，还是不同的线程申请的内存，都反映到到进程的堆段。堆段向上增长，最大可以增长到1GB的位置，即0x40000000，如果大于1GB，glibc将采用mmap的方式，为堆申请一块内存。
第四行：是程序连接的共享库的内存地址。
第五行：是以mmap方式映射的虚拟地址空间。
第六、七行：是线程的栈区地址段，每个线程的栈大小都是16K。
第八行：是进程的栈区。关于栈段，每个线程都有一个，如果进程中有多个线程，则包含多个栈段。&lt;/p&gt;

&lt;p&gt;三、当前系统总内存的统计
    1、进程占用的总内存可以通过上述maps表计算出来。
    2、当系统运行起来以后，会把应用层相关的文件挂载到tmpfs文件系统下，海思系统下这部分大概有13M左右，这部分内存是以cache方式统计出来的，但是这部分内存cache无法通过回收策略或者显式的调用释放掉。
    3、根文件系统ramdisk占用的内存。
    4、当前系统保留内存的大小，可以通过查看/proc/sys/vm/min_free_kbytes来获取或者修改此内存的大小。
    5、当然，当系统运行起来后，还应该留有一定的内存用于在硬盘读写时做cache或者网络负荷比较高时分配skb等，一般需要30M以上。&lt;/p&gt;

&lt;p&gt;四、对调试内存泄露类问题的一些启示
   当进程申请内存时，实际上是glibc中内置的内存管理器接收了该请求，随着进程申请内存的增加，内存管理器会通过系统调用陷入内核，从而为进程分配更多的内存。
针对堆段的管理，内核提供了两个系统调用brk和mmap，brk用于更改堆顶地址，而mmap则为进程分配一块虚拟地址空间。
当进程向glibc申请内存时，如果申请内存的数量大于一个阀值的时候，glibc会采用mmap为进程分配一块虚拟地址空间，而不是采用brk来扩展堆顶的指针。缺省情况下，此阀值是128K，可以通过函数来修改此值。
             #include
             Int mallopt(int param, int value)
Param的取值分别为M_MMAP_THRESHOLD、M_MMAP_MAX。
Value的取值是以字节为单位的。
M_MMAP_THRESHOLD是glibc中申请大块内存阀值，大于该阀值的内存申请，内存管理器将使用mmap系统调用申请内存，如果小于该阀值的内存申请，内存管理器使用brk系统调用扩展堆顶指针。
M_MMAP_MAX是该进程中最多使用mmap分配地址段的数量。&lt;/p&gt;

&lt;p&gt;如果在实际的调试过程中，怀疑某处发生了内存泄露，可以查看该进程的maps表，看进程的堆段或者mmap段的虚拟地址空间是否持续增加，如果是，说明很可能发生了内存泄露，如果mmap段虚拟地址空间持续增加，还可以看到各个段的虚拟地址空间的大小，从而可以确定是申请了多大的内存，对调试内存泄露类问题可以起到很好的定位作用。&lt;/p&gt;

&lt;p&gt;如何检测内存泄漏&lt;/p&gt;

&lt;p&gt;内存泄漏的问题，在百度是遇到最多的，阿里相对少点。与内存泄漏斗争了很久，我总结下常用的一些有效测试方法吧。
　　1、valgrind，这是非常好用的工具，虽然参数很多，输出结果较多，但是只要认真看下，就很容易发现问题，报告是很详细的，不要被吓倒。valgrind检测的内存泄漏是非常准的，可以精确定位到代码行甚至是变量。valgrind基于valginrd core框架，这是个非常有强大的框架，他的作用不仅仅在于检测内存泄漏的，强烈建议测试新手通读下全部的文档。valgind自己也会有误报和漏报，所有具体场景需要具体分析。报告中一旦出现definitely lost的标记，就表示一定会有内存泄漏，泄漏的字节数也会报告出来，可以根据泄漏的内存大小和请求次数计算出到底是那个变量没有释放。
　　2、利用pmap+gdb，pmap可以列出特定进程的所有内存分配的地址和大小，通过gdb就可以直接看这些地址属于什么变量，通过统计这些内存地址的大小，就可以很容易的发现问题。利用自动化的gdb调试工具也可以很方便的定位。
　　3、其他的还包括memprof、商业工具Purify IBM出品，官方宣传说的不错，但是这种不开放的技术，在业界得不到认可，国内大公司一般那都不用，只有人傻钱多的公司在用。
　　4、利用一些trace工具，比如ptrace，strace之类的工具，这些trace工具会追踪特定的api，只需要统计malloc和free的调用次数就可以简单的发现是否有泄漏，但是无法定位代码行。另外还有一个更高深的工具，SystemTap，这个在国内应用还不多，但是非常厉害，可以方便hook程序的关键逻辑并插入探针。从而可以方便的检测内存泄漏。Systemtap目前还不通用，而且安装复杂，暂时不推荐使用，可以关注下，过几年可能会大规模应用。
　　valgrind是首选，因为他的设计就是为了解决所有的c++的内存问题。一些valgrind不能简单发现的，我一般会review代码，然后通过gdb自动调试技术来发现问题。通过valgrind+gdb，可以解决所有的内存泄漏。
　　另外，内存的泄漏也并不完全是没有及时的free，还有可能是其他的原因，比如设计问题等。需要靠一定的开发经验判断。
　　要尽量把静态测试和动态测试尽早的加入到持续集成中，以尽早的发现问题，不然一旦代码复杂，追查的成本就会增大。&lt;/p&gt;

&lt;p&gt;目的：
本文是《一种定位内存泄露的方法（Solaris）》对应的Linux版本，调试器使用gdb。主要介绍实例部分。其他请见《一种定位内存泄露的方法（Solaris）》。&lt;/p&gt;

&lt;p&gt;实例：
模拟new失败的程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdexcept&amp;gt;
class ABC
{
public:
        virtual ~ABC(){}
        int i;
        int j;
};

void f()
{
        for (int i = 0; i &amp;lt; 1000; ++i)
        {
                ABC* p = new ABC;
        }
        throw std::bad_alloc();
}

int main()
{
        f();
        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1） 编译运行此段代码。产生一个core文件
2） 用gdb打开这个core文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb a.out core
(gdb) run
Starting program: /test/new_fail/a.out
terminate called after throwing an instance of &#39;std::bad_alloc&#39;
  what():  std::bad_alloc

Program received signal SIGABRT, Aborted.
0x00007ffff733f645 in raise () from /lib64/libc.so.6
(gdb) info proc
process 10683
cmdline = &#39;/test/new_fail/a.out&#39;
cwd = &#39;/test/new_fail&#39;
exe = &#39;/test/new_fail/a.out&#39;
(gdb) shell pmap 10683
10683: a.out
START               SIZE     RSS     PSS   DIRTY    SWAP PERM MAPPING
0000000000400000      4K      4K      4K      0K      0K r-xp /test/new_fail/a.out
0000000000600000      4K      4K      4K      4K      0K r--p /test/new_fail/a.out
0000000000601000      4K      4K      4K      4K      0K rw-p /test/new_fail/a.out
0000000000602000    132K     32K     32K     32K      0K rw-p [heap]
…（略）
Total:            11468K   1048K    684K    180K      0K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;360K writable-private, 11108K readonly-private, 0K shared, and 1048K referenced&lt;/p&gt;

&lt;p&gt;可以看到heap空间的起始地址是0x0000000000602000，共132K字节，即132*1024=135168字节。
3） 因为是64位应用程序，所以指针占8字节。所以需要遍历的指针个数为135168/8=16896。
4） 将结果输出到日志文件gdb.txt中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set height 0
(gdb) set logging on
Copying output to gdb.txt.
(gdb) x/16896a 0x0000000000602000
gdb.txt的内容：
0x602000:       0x0     0x21
0x602010:       0x400b30 &amp;lt;_ZTV3ABC+16&amp;gt;  0x0
0x602020:       0x0     0x21
0x602030:       0x400b30 &amp;lt;_ZTV3ABC+16&amp;gt;  0x0
….
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5） 过滤gdb.txt：
awk &amp;lsquo;{print $2&amp;rdquo;/n&amp;rdquo;$3}&amp;rsquo; gdb.txt|c++filt|grep vtable&amp;gt;gdb_vtable.txt
gdb_vtable.txt的内容为：
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
&lt;vtable for ABC+16&gt;
….
6） 将gdb_vtable.txt的内容导入到SQLServer中（如果记录不多，可以用Excel代替）。表名为gdb_vtable，第一列Col001为符号。对其分组求和：
select Col001, count(1) quantity from gdb_vtable
group by Col001
order by quantity desc
结果为：
Col001                                                                                    quantity
&lt;vtable for ABC+16&gt;                                                              1000
&lt;vtable for std::bad_alloc@@GLIBCXX_3.4+16&gt;                1
可知core里有1000个ABC，遍历使用ABC的代码，可知存在泄漏。&lt;/p&gt;

&lt;p&gt;linux下调试内存泄露的利器Valgrind&lt;/p&gt;

&lt;p&gt;Valgrind的主要作者Julian Seward刚获得了今年的Google-O&amp;rsquo;Reilly开源大奖之一──Best Tool Maker。让我们一起来看一下他的作品。Valgrind是运行在Linux上一套基于仿真技术的程序调试和分析工具，它包含一个内核──一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务──调试，分析，或测试等。Valgrind可以检测内存泄漏和内存违例，还可以分析cache的使用等，灵活轻巧而又强大，能直穿程序错误的心脏，真可谓是程序员的瑞士军刀。&lt;/p&gt;

&lt;p&gt;更详细的文档可以参考：Valgrind Documentation&lt;/p&gt;

&lt;p&gt;一. Valgrind概观&lt;/p&gt;

&lt;p&gt;Valgrind的最新版是3.2.0，它一般包含下列工具：
1.Memcheck&lt;/p&gt;

&lt;p&gt;最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到， 一切对malloc()/free()/new/delete的调用都会被捕获。所以，它能检测以下问题：&lt;/p&gt;

&lt;p&gt;1.对未初始化内存的使用；&lt;/p&gt;

&lt;p&gt;2.读/写释放后的内存块；&lt;/p&gt;

&lt;p&gt;3.读/写超出malloc分配的内存块；&lt;/p&gt;

&lt;p&gt;4.读/写不适当的栈中内存块；&lt;/p&gt;

&lt;p&gt;5.内存泄漏，指向一块内存的指针永远丢失；&lt;/p&gt;

&lt;p&gt;6.不正确的malloc/free或new/delete匹配；&lt;/p&gt;

&lt;p&gt;7,memcpy()相关函数中的dst和src指针重叠。&lt;/p&gt;

&lt;p&gt;这些问题往往是C/C++程序员最头疼的问题，Memcheck在这里帮上了大忙。
2.Callgrind&lt;/p&gt;

&lt;p&gt;和gprof类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和gprof不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。Callgrind收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行cache模拟。在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。
3.Cachegrind&lt;/p&gt;

&lt;p&gt;Cache分析器，它模拟CPU中的一级缓存I1，Dl和二级缓存，能够精确地指出程序中cache的丢失和命中。如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。
4.Helgrind&lt;/p&gt;

&lt;p&gt;它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。Helgrind实现了名为“Eraser”的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，Helgrind仍然处于实验阶段。
5. Massif&lt;/p&gt;

&lt;p&gt;堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。&lt;/p&gt;

&lt;p&gt;此外，lackey和nulgrind也会提供。Lackey是小型工具，很少用到；Nulgrind只是为开发者展示如何创建一个工具。我们就不做介绍了。
二. 使用Valgrind&lt;/p&gt;

&lt;p&gt;Valgrind的使用非常简单，valgrind命令的格式如下：&lt;/p&gt;

&lt;p&gt;valgrind [valgrind-options] your-prog [your-prog options]&lt;/p&gt;

&lt;p&gt;一些常用的选项如下：&lt;/p&gt;

&lt;p&gt;选项&lt;/p&gt;

&lt;p&gt;作用&lt;/p&gt;

&lt;p&gt;-h &amp;ndash;help&lt;/p&gt;

&lt;p&gt;显示帮助信息。&lt;/p&gt;

&lt;p&gt;&amp;ndash;version&lt;/p&gt;

&lt;p&gt;显示valgrind内核的版本，每个工具都有各自的版本。&lt;/p&gt;

&lt;p&gt;-q &amp;ndash;quiet&lt;/p&gt;

&lt;p&gt;安静地运行，只打印错误信息。&lt;/p&gt;

&lt;p&gt;-v &amp;ndash;verbose&lt;/p&gt;

&lt;p&gt;打印更详细的信息。&lt;/p&gt;

&lt;p&gt;&amp;ndash;tool=&lt;toolname&gt; [default: memcheck]&lt;/p&gt;

&lt;p&gt;最常用的选项。运行valgrind中名为toolname的工具。如果省略工具名，默认运行memcheck。&lt;/p&gt;

&lt;p&gt;&amp;ndash;db-attach=&lt;yes|no&gt; [default: no]&lt;/p&gt;

&lt;p&gt;绑定到调试器上，便于调试错误。&lt;/p&gt;

&lt;p&gt;我们通过例子看一下它的具体使用。我们构造一个存在内存泄漏的C程序，如下：&lt;/p&gt;

&lt;p&gt;[cpp] view plaincopyprint?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;  
#include &amp;lt;stdio.h&amp;gt;  
void f(void)  
{  
    int* x = malloc(10 * sizeof(int));  
    x[10] = 0; // problem 1: heap block overrun  
    } // problem 2: memory leak -- x not freed  
    int main(void)  
    {  
    int i;  
    f();  
    printf(&amp;quot;i=%d\n&amp;quot;,i); //problem 3: use uninitialised value.  
    return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存为memleak.c并编译，然后用valgrind检测。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -Wall -o memleak memleak.c
$ valgrind --tool=memcheck ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到如下错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== Invalid write of size 4
==3649== at 0x80483CF: f (in /home/wangcong/memleak)
==3649== by 0x80483EC: main (in /home/wangcong/memleak)
==3649== Address 0x4024050 is 0 bytes after a block of size 40 alloc&#39;d
==3649== at 0x40051F9: malloc (vg_replace_malloc.c:149)
==3649== by 0x80483C5: f (in /home/wangcong/memleak)
==3649== by 0x80483EC: main (in /home/wangcong/memleak)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的3649是程序运行时的进程号。第一行是告诉我们错误类型，这里是非法写入。下面的是告诉我们错误发生的位置，在main()调用的f()函数中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== Use of uninitialised value of size 4
==3649== at 0xC3A264: _itoa_word (in /lib/libc-2.4.so)
==3649== by 0xC3E25C: vfprintf (in /lib/libc-2.4.so)
==3649== by 0xC442B6: printf (in /lib/libc-2.4.so)
==3649== by 0x80483FF: main (in /home/wangcong/memleak)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个错误是使用未初始化的值，在main()调用的printf()函数中。这里的函数调用关系是通过堆栈跟踪的，所以有时会非常多，尤其是当你使用C++的STL时。其它一些错误都是由于把未初始化的值传递给libc函数而被检测到。在程序运行结束后，valgrind还给出了一个小的总结：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3649== ERROR SUMMARY: 20 errors from 6 contexts (suppressed: 12 from 1)
==3649== malloc/free: in use at exit: 40 bytes in 1 blocks.
==3649== malloc/free: 1 allocs, 0 frees, 40 bytes allocated.
==3649== For counts of detected errors, rerun with: -v
==3649== searching for pointers to 1 not-freed blocks.
==3649== checked 47,256 bytes.
==3649==
==3649== LEAK SUMMARY:
==3649== definitely lost: 40 bytes in 1 blocks.
==3649== possibly lost: 0 bytes in 0 blocks.
==3649== still reachable: 0 bytes in 0 blocks.
==3649== suppressed: 0 bytes in 0 blocks.
==3649== Use --leak-check=full to see details of leaked memory.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以很清楚地看出，分配和释放了多少内存，有多少内存泄漏。这对我们查找内存泄漏十分方便。然后我们重新编译程序并绑定调试器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -Wall -ggdb -o memleak memleak.c
$ valgrind --db-attach=yes --tool=memcheck ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一出现错误，valgrind会自动启动调试器（一般是gdb）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==3893== ---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ---- y
starting debugger
==3893== starting debugger with cmd: /usr/bin/gdb -nw /proc/3895/fd/1014 3895
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出gdb后我们又能回到valgrind继续执行程序。&lt;/p&gt;

&lt;p&gt;还是用上面的程序，我们使用callgrind来分析一下它的效率：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ valgrind --tool=callgrind ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Callgrind会输出很多，而且最后在当前目录下生成一个文件： callgrind.out.pid。用callgrind_annotate来查看它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ callgrind_annotate callgrind.out.3949
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的信息就列出来了。而且，当callgrind运行你的程序时，你还可以使用callgrind_control来观察程序的执行，而且不会干扰它的运行。&lt;/p&gt;

&lt;p&gt;再来看一下cachegrind的表现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ valgrind --tool=cachegrind ./memleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==4073== I refs: 147,500
==4073== I1 misses: 1,189
==4073== L2i misses: 679
==4073== I1 miss rate: 0.80%
==4073== L2i miss rate: 0.46%
==4073==
==4073== D refs: 61,920 (46,126 rd + 15,794 wr)
==4073== D1 misses: 1,759 ( 1,545 rd + 214 wr)
==4073== L2d misses: 1,241 ( 1,062 rd + 179 wr)
==4073== D1 miss rate: 2.8% ( 3.3% + 1.3% )
==4073== L2d miss rate: 2.0% ( 2.3% + 1.1% )
==4073==
==4073== L2 refs: 2,948 ( 2,734 rd + 214 wr)
==4073== L2 misses: 1,920 ( 1,741 rd + 179 wr)
==4073== L2 miss rate: 0.9% ( 0.8% + 1.1% )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的是指令缓存，I1和L2i缓存，的访问信息，包括总的访问次数，丢失次数，丢失率。&lt;/p&gt;

&lt;p&gt;中间的是数据缓存，D1和L2d缓存，的访问的相关信息，下面的L2缓存单独的信息。Cachegrind也生成一个文件，名为cachegrind.out.pid，可以通过cg_annotate来读取。输出是一个更详细的列表。Massif的使用和cachegrind类似，不过它也会生成一个名为massif.pid.ps的PostScript文件，里面只有一幅描述堆栈使用状况的彩图。&lt;/p&gt;

&lt;p&gt;以上只是简单的演示了valgrind的使用，更多的信息可以在它附带的文档中得到，也可以访问valgrind的主页：&lt;a href=&#34;http://www.valgrind.org。学会正确合理地使用valgrind对于调试程序会有很大的帮助。&#34;&gt;http://www.valgrind.org。学会正确合理地使用valgrind对于调试程序会有很大的帮助。&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用GDB调试程序</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-2</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-2</guid>
      <description>&lt;p&gt;#用GDB调试程序
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。
#用GDB调试程序
##GDB概述
————
GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那
种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你
会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，
尺有所短”就是这个道理。
一般来说，GDB主要帮忙你完成下面四个方面的功能：
1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
3、当程序被停住时，可以检查此时你的程序中所发生的事。
4、动态的改变你程序的执行环境。
从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细
节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有
时候，命令行的调试工具却有着图形化工具所不能完成的功能。让我们一一看来。
##一个调试示例
——————
源程序：tst.c
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i&lt;7; i++) {
8 sum+=i; 
9 } 
10 return sum; 
11 } 
12 
13 
14 main() 
15 { 
16 int i; 
17 long result = 0; 
18 for(i=1; i&lt;=100; i++) 
19 { 
20 result += i; 
21 } 
22 
23 printf(&#34;result[1-100] = %d /n&#34;, result ); 
24 printf(&#34;result[1-250] = %d /n&#34;, func(250) ); 
25 } 
编译生成执行文件：（Linux下） 
hchen/test&gt; cc -g tst.c -o tst
使用GDB调试：
hchen/test&amp;gt; gdb tst &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;- 启动GDB
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &amp;ldquo;show copying&amp;rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i386-suse-linux&amp;rdquo;&amp;hellip;
(gdb) l &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; l命令相当于list，从第一行开始例出原码。
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i 7 {
8 sum+=i;
9 }
10 return sum;
(gdb) &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 直接回车表示，重复上一次命令
11 }&lt;/p&gt;

&lt;p&gt;12
13
14 main()
15 {
16 int i;
17 long result = 0;
18 for(i=1; i&amp;lt;=100; i++)
19 {
20 result += i;
(gdb) break 16 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 设置断点，在源程序第16行处。
Breakpoint 1 at 0x8048496: file tst.c, line 16.
(gdb) break func &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 设置断点，在函数func()入口处。
Breakpoint 2 at 0x8048456: file tst.c, line 5.
(gdb) info break &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 查看断点信息。
Num Type Disp Enb Address What
1 breakpoint keep y 0x08048496 in main at tst.c:16
2 breakpoint keep y 0x08048456 in func at tst.c:5
(gdb) r &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 运行程序，run命令简写
Starting program: /home/hchen/test/tst
Breakpoint 1, main () at tst.c:17 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;- 在断点处停住。
17 long result = 0;
(gdb) n &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 单条语句执行，next命令简写。
18 for(i=1; i&amp;lt;=100; i++)
(gdb) n
20 result += i;
(gdb) n
18 for(i=1; i&amp;lt;=100; i++)
(gdb) n
20 result += i;
(gdb) c &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 继续运行程序，continue命令简写。
Continuing.
result[1-100] = 5050 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-程序输出。
Breakpoint 2, func (n=250) at tst.c:5
5 int sum=0,i;
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)
(gdb) p i &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 打印变量i的值，print命令简写。
$1 = 134513808
(gdb) n
8 sum+=i;
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)&lt;/p&gt;

&lt;p&gt;(gdb) p sum
$2 = 1
(gdb) n
8 sum+=i;
(gdb) p i
$3 = 2
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)
(gdb) p sum
$4 = 3
(gdb) bt &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 查看函数堆栈。
#0 func (n=250) at tst.c:5
#1 0x080484e4 in main () at tst.c:24
#2 0x400409ed in __libc_start_main () from /lib/libc.so.6
(gdb) finish &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 退出函数。
Run till exit from #0 func (n=250) at tst.c:5
0x080484e4 in main () at tst.c:24
24 printf(&amp;ldquo;result[1-250] = %d /n&amp;rdquo;, func(250) );
Value returned is $6 = 31375
(gdb) c &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 继续运行。
Continuing.
result[1-250] = 31375 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-程序输出。
Program exited with code 027. &amp;lt;&amp;mdash;&amp;mdash;&amp;ndash;程序退出，调试结束。
(gdb) q &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 退出gdb。
hchen/test&amp;gt;
好了，有了以上的感性认识，还是让我们来系统地认识一下gdb吧。
使用GDB
————
一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必
须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。
如：
&amp;gt; cc -g hello.c -o hello
&amp;gt; g++ -g hello.cpp -o hello
如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用
-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。
启动GDB的方法有以下几种：&lt;/p&gt;

&lt;p&gt;###1、gdb
program也就是你的执行文件，一般在当然目录下。
###2、gdb core
用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
###3、gdb
如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自
动attach上去，并调试他。program应该在PATH环境变量中搜索得到。
GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下
面只例举一些比较常用的参数：
-symbols
-s
从指定文件中读取符号表。
-se file
从指定文件中读取符号表信息，并把他用在可执行文件中。
-core
-c
调试时core dump的core文件。
-directory
-d
加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
#GDB的命令概貌
———————
启动gdb后，就你被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb
的命令可以使用help命令来查看，如下所示：
/home/hchen&amp;gt; gdb
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &amp;ldquo;show copying&amp;rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i386-suse-linux&amp;rdquo;.
(gdb) help&lt;/p&gt;

&lt;p&gt;List of classes of commands:
aliases &amp;ndash; Aliases of other commands
breakpoints &amp;ndash; Making program stop at certain points
data &amp;ndash; Examining data
files &amp;ndash; Specifying and examining files
internals &amp;ndash; Maintenance commands
obscure &amp;ndash; Obscure features
running &amp;ndash; Running the program
stack &amp;ndash; Examining the stack
status &amp;ndash; Status inquiries
support &amp;ndash; Support facilities
tracepoints &amp;ndash; Tracing of program execution without stopping the program
user-defined &amp;ndash; User-defined commands
Type &amp;ldquo;help&amp;rdquo; followed by a class name for a list of commands in that class.
Type &amp;ldquo;help&amp;rdquo; followed by command name for full documentation.
Command name abbreviations are allowed if unambiguous.
(gdb)
gdb的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看
种类中的命令，可以使用help 命令，如：help breakpoints，查看设置断点的所有命令。也
可以直接help 来查看命令的帮助。
gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令
的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐
命令的全称，如果有重复的，那么gdb会把其例出来。
示例一：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func
(gdb) b func
Breakpoint 1 at 0x8048458: file hello.c, line 10.
示例二：敲入b按两次TAB键，你会看到所有b打头的命令：
(gdb) b
backtrace break bt
(gdb)
示例三：只记得函数的前缀，可以这样：
(gdb) b make_ &amp;lt;按TAB键&amp;gt;
（再按下一次TAB键，你会看到:）
make_a_section_from_file make_environ
make_abs_section make_function_type
make_blockvector make_pointer_type&lt;/p&gt;

&lt;p&gt;make_cleanup make_reference_type
make_command make_symbol_completion&lt;em&gt;list
(gdb) b make&lt;/em&gt;
GDB把所有make开头的函数全部例出来给你查看。
示例四：调试C++的程序时，有可以函数名一样。如：
(gdb) b &amp;lsquo;bubble( M-?
bubble(double,double) bubble(int,int)
(gdb) b &amp;lsquo;bubble(
你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思）
要退出gdb时，只用发quit或命令简称q就行了。
GDB中运行UNIX的shell程序
————————————
在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
shell
调用UNIX的shell来执行，环境变量SHELL中定义的UNIX的shell将会被用来执行，如
果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。（在Windows中使用Command.com
或cmd.exe）
还有一个gdb命令是make：
make
可以在gdb中执行make命令来重新build自己的程序。这个命令等价于“shell make ”。
在GDB中运行程序
————————
当以gdb 方式启动gdb后，gdb会在PATH路径和当前目录中搜索的源文件。如要确认gdb
是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。
在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。
###1、程序运行参数。
set args 可指定运行时参数。（如：set args 10 20 30 40 50）
show args 命令可以查看设置好的运行参数。
###2、运行环境。
path
可设定程序的运行路径。
show paths 查看程序的运行路径。&lt;/p&gt;

&lt;p&gt;set environment varname [=value] 设置环境变量。如：set env USER=hchen
show environment [varname] 查看环境变量。
###3、工作目录。
cd
相当于shell的cd命令。
pwd 显示当前的所在目录。
###4、程序的输入输出。
info terminal 显示你程序用到的终端的模式。
使用重定向控制程序输出。如：run &amp;gt; outfile
tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb
#调试已运行的程序
————————
两种方法：
1、在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在
运行的程序。
2、先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用
detach来取消挂接的进程。
#暂停 / 恢复程序运行
—————————
调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序
的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变
量，以及运行时的流程。
当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停
的原因。
在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕
捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可
以使用c或是continue命令。
##一、设置断点（BreakPoint）
我们用break命令来设置断点。正面有几点设置断点的方法：
break
在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函&lt;/p&gt;

&lt;p&gt;数名。
break
在指定行号停住。
break +offset
break -offset
在当前行号的前面或后面的offset行停住。offiset为自然数。
break filename:linenum
在源文件filename的linenum行处停住。
break filename:function
在源文件filename的function函数的入口处停住。
break *address
在程序运行的内存地址处停住。
break
break命令没有参数时，表示在下一条指令处停住。
break &amp;hellip; if
&amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设
置break if i=100，表示当i为100时停住程序。
查看断点时，可使用info命令，如下所示：（注：n表示断点号）
info breakpoints [n]
info break [n]
##二、设置观察点（WatchPoint）
观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马
上停住程序。我们有下面的几种方法来设置观察点：
watch
为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
rwatch
当表达式（变量）expr被读时，停住程序。
awatch
当表达式（变量）的值被读或被写时，停住程序。&lt;/p&gt;

&lt;p&gt;info watchpoints
列出当前所设置了的所有观察点。
##三、设置捕捉点（CatchPoint）
你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++
的异常。设置捕捉点的格式为：
catch
当event发生时，停住程序。event可以是下面的内容：
1、throw 一个C++抛出的异常。（throw为关键字）
2、catch 一个C++捕捉到的异常。（catch为关键字）
3、exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）
4、fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）
5、vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）
6、load 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX
下有用）
7、unload 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在
HP-UX下有用）
tcatch
只设置一次捕捉点，当程序停住以后，应点被自动删除。
##四、维护停止点
上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你
觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来
进行维护。
clear
清除所有的已定义的停止点。
clear
clear
清除所有设置在函数上的停止点。
clear
clear
清除所有设置在指定行上的停止点。
delete [breakpoints] [range&amp;hellip;]
删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range
表示断点号的范围（如：3-7）。其简写命令为d。&lt;/p&gt;

&lt;p&gt;比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要
时，enable即可，就好像回收站一样。
disable [breakpoints] [range&amp;hellip;]
disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的
停止点。简写命令是dis.
enable [breakpoints] [range&amp;hellip;]
enable所指定的停止点，breakpoints为停止点号。
enable [breakpoints] once range&amp;hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。
enable [breakpoints] delete range&amp;hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。
##五、停止条件维护
前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这
是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点
设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以
用condition命令来修改断点的条件。（只有break和watch命令支持if，catch目前暂不支持
if）
condition
修改断点号为bnum的停止条件为expression。
condition
清除断点号为bnum的停止条件。
还有一个比较特殊的维护命令ignore，你可以指定程序运行时，忽略停止条件几次。
ignore
表示忽略断点号为bnum的停止条件count次。
##六、为停止点设定运行命令
我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的
程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于
GDB的自动化调试是一个强大的支持。
commands [bnum]&lt;/p&gt;

&lt;p&gt;&amp;hellip; command-list &amp;hellip;
end
为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的
命令。
例如：
break foo if x&amp;gt;0
commands
printf &amp;ldquo;x is %d/n&amp;rdquo;,x
continue
end
断点设置在函数foo中，断点条件是x&amp;gt;0，如果程序被断住后，也就是，一旦x的值在foo
函数中大于0，GDB会自动打印出x的值，并继续运行程序。
如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个
end就行了。
##七、断点菜单
在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break 不
能告诉GDB要停在哪个函数的入口。当然，你可以使用break 也就是把函数的参数类型告
诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的
断点。你只要输入你菜单列表中的编号就可以了。如：
(gdb) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
&amp;gt; 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the &amp;ldquo;delete&amp;rdquo; command to delete unwanted
breakpoints.
(gdb)&lt;/p&gt;

&lt;p&gt;可见，GDB列出了所有after的重载函数，你可以选一下列表编号就行了。0表示放弃设置
断点，1表示所有函数都设置断点。
##八、恢复程序运行和单步调试
当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。
也可以使用step或next命令单步跟踪程序。
continue [ignore-count]
c [ignore-count]
fg [ignore-count]
恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次
数。continue，c，fg三个命令都是一样的意思。
step
单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug
信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，
加表示执行后面的count条指令，然后再停住。
next
同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面
可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后
再停住。
set step-mode
set step-mode on
打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。
这个参数有很利于查看机器码。
set step-mod off
关闭step-mode模式。
finish
运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
until 或 u
当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
stepi 或 si
nexti 或 ni
单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步
执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单
步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）&lt;/p&gt;

&lt;p&gt;##九、信号（Signals）
信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤
其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT
表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示
子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下
非常重要的一种技术。
GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信
号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。
你可以用GDB的handle命令来完成这一功能。
handle
在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处
理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包
括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。
一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几
种关键字的一个或多个。
nostop
当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信
号。
stop
当被调试的程序收到信号时，GDB会停住你的程序。
print
当被调试的程序收到信号时，GDB会显示出一条信息。
noprint
当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。
pass
noignore
当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程
序会处理。
nopass
ignore
当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
info signals
info handle
查看有哪些信号在被GDB检测中。
##十、线程（Thread Stops）&lt;/p&gt;

&lt;p&gt;如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线
程。GDB很容易帮你完成这一工作。
break thread
break thread if &amp;hellip;
linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是
GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你
不指定thread 则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如：
(gdb) break frik.c:13 thread 28 if bartab &amp;gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体
情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。
#查看栈信息
—————
当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一
个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以
用GDB命令来查看当前的栈中的信息。
下面是一些查看函数调用栈信息的GDB命令：
backtrace
bt
打印当前的函数调用栈的所有信息。如：
(gdb) bt
#0 func (n=250) at tst.c:6
#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2 0x400409ed in &lt;strong&gt;libc_start_main () from /lib/libc.so.6
从上可以看出函数的调用栈信息：&lt;/strong&gt;libc_start_main &amp;ndash;&amp;gt; main() &amp;ndash;&amp;gt; func()
backtrace
bt
n是一个正整数，表示只打印栈顶上n层的栈信息。
backtrace &amp;lt;-n&amp;gt;
bt &amp;lt;-n&amp;gt;
-n表一个负整数，表示只打印栈底下n层的栈信息。
如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈&lt;/p&gt;

&lt;p&gt;就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。
frame
f
n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的
第二层。
up
表示向栈的上面移动n层，可以不打n，表示向上移动一层。
down
表示向栈的下面移动n层，可以不打n，表示向下移动一层。
上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三
个命令：
select-frame 对应于 frame 命令。
up-silently 对应于 up 命令。
down-silently 对应于 down 命令。
查看当前栈层的信息，你可以用以下GDB命令：
frame 或 f
会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数
执行到的语句。
info frame
info f
这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比
如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写
成的、函数参数地址及值、局部变量的地址等等。如：
(gdb) info f
Stack level 0, frame at 0xbffff5d4:
eip = 0x804845d in func (tst.c:6); saved eip 0x8048524
called by frame at 0xbffff60c
source language c.
Arglist at 0xbffff5d4, args: n=250
Locals at 0xbffff5d4, Previous frame&amp;rsquo;s sp is 0x0
Saved registers:
ebp at 0xbffff5d4, eip at 0xbffff5d8
info args&lt;/p&gt;

&lt;p&gt;打印出当前函数的参数名及其值。
info locals
打印出当前函数中所有局部变量及其值。
info catch
打印出当前的函数中的异常处理信息。
#查看源程序
—————
##一、显示源代码
GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程
序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序
停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源
代码的GDB命令吧。
list
显示程序第linenum行的周围的源程序。
list
显示函数名为function的函数的源程序。
list
显示当前行后面的源程序。
list -
显示当前行前面的源程序。
一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当
然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。
set listsize
设置一次显示源代码的行数。
show listsize
查看当前listsize的设置。
list命令还有下面的用法：
list ,&lt;/p&gt;

&lt;p&gt;显示从first行到last行之间的源代码。
list ,
显示从当前行到last行之间的源代码。
list +
往后显示源代码。
一般来说在list后面可以跟以下这们的参数：
行号。
&amp;lt;+offset&amp;gt; 当前行号的正偏移量。
&amp;lt;-offset&amp;gt; 当前行号的负偏移量。
哪个文件的哪一行。
函数名。
哪个文件中的哪个函数。
&amp;lt;*address&amp;gt; 程序运行时的语句在内存中的地址。
##二、搜索源代码
不仅如此，GDB还提供了源代码搜索的命令：
forward-search
search
向前面搜索。
reverse-search
全部搜索。
其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，
还请各位查看相关资料。
##三、指定源文件的路径
某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供
了可以让你指定源文件的路径的命令，以便GDB进行搜索。
directory
dir
加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，
Windows下你可以使用“;”。&lt;/p&gt;

&lt;p&gt;directory
清除所有的自定义的源文件搜索路径信息。
show directories
显示定义了的源文件搜索路径。
##四、源代码的内存
你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函
数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内
存地址，如：
(gdb) info line tst.c:func
Line 5 of &amp;ldquo;tst.c&amp;rdquo; starts at address 0x8048456 and ends at 0x804845d .
还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前
内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。
(gdb) disassemble func
Dump of assembler code for function func:
0x8048450 : push %ebp
0x8048451 : mov %esp,%ebp
0x8048453 : sub $0x18,%esp
0x8048456 : movl $0x0,0xfffffffc(%ebp)
0x804845d : movl $0x1,0xfffffff8(%ebp)
0x8048464 : mov 0xfffffff8(%ebp),%eax
0x8048467 : cmp 0x8(%ebp),%eax
0x804846a : jle 0x8048470
0x804846c : jmp 0x8048480
0x804846e : mov %esi,%esi
0x8048470 : mov 0xfffffff8(%ebp),%eax
0x8048473 : add %eax,0xfffffffc(%ebp)
0x8048476 : incl 0xfffffff8(%ebp)
0x8048479 : jmp 0x8048464
0x804847b : nop
0x804847c : lea 0x0(%esi,1),%esi
0x8048480 : mov 0xfffffffc(%ebp),%edx
0x8048483 : mov %edx,%eax
0x8048485 : jmp 0x8048487
0x8048487 : mov %ebp,%esp
0x8048489 : pop %ebp
0x804848a : ret
End of assembler dump.&lt;/p&gt;

&lt;p&gt;#查看运行时数据
———————
在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令
inspect来查看当前程序的运行数据。print命令的格式是：
print
print /
是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格
式，比如，如果要把表达式按16进制的格式输出，那么就是/x。
##一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据
来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函
数等内容。可惜的是GDB不能使用你在程序中所定义的宏。
表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本
文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）
在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。
@
是一个和数组有关的操作符，在后面会有更详细的说明。
::
指定一个在文件或是一个函数中的变量。
{}
表示一个指向内存地址的类型为type的一个对象。
##二、程序变量
在GDB中，你可以随时查看以下三种变量的值：
1、全局变量（所有文件可见的）
2、静态全局变量（当前文件可见的）
3、局部变量（当前Scope可见的）
如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局
变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函&lt;/p&gt;

&lt;p&gt;数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量
的值时，你可以使用“::”操作符：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看
文件f2.c中的全局变量x的值：
gdb) p &amp;lsquo;f2.c&amp;rsquo;::x
当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所
以你不必担心在调试C++程序时会出现异常。
另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过
的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为
优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB
调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结
果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支
持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决
这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
##三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大
小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右
边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其
保存在变量len中，其输出结果，大约是下面这个样子的：
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。
##四、输出格式&lt;/p&gt;

&lt;p&gt;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。
例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要
做到这样，你可以使用GDB的数据显示格式：
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &amp;lsquo;e&amp;rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101
##五、查看内存
你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是
指令地址，那么格式可以是i。&lt;/p&gt;

&lt;p&gt;u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可
以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当
我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作
一个值取出来。
表示一个内存地址。
n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3
表示三个单位，u表示按十六进制显示。
##六、自动显示
你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显
示。相关的GDB命令是display。
display
display/
display/
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一
个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。
格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc
$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇
编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的
功能。
下面是一些和display相关的GDB命令：
undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以
用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）
disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。&lt;/p&gt;

&lt;p&gt;info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多
少个自动显示设置，其中包括，设置的编号，表达式，是否enable。
##七、设置显示选项
GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。
set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
如：
(gdb) f
#0 set_quotes (lq=0x34c78 &amp;ldquo;&amp;lt;&amp;lt;&amp;ldquo;, rq=0x34c88 &amp;ldquo;&amp;gt;&amp;gt;&amp;rdquo;)
at input.c:530
530 if (lquote != def_lquote)
set print address off
关闭函数的参数地址显示，如：
(gdb) set print addr off
(gdb) f
#0 set_quotes (lq=&amp;rdquo;&amp;lt;&amp;lt;&amp;ldquo;, rq=&amp;rdquo;&amp;gt;&amp;gt;&amp;ldquo;) at input.c:530
530 if (lquote != def_lquote)
show print address
查看当前地址显示选项是否打开。
set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗
号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。
set print array off
show print array
set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的
最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。
show print elements&lt;/p&gt;

&lt;p&gt;查看print elements的选项信息。
set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。
set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：
$1 = {
next = 0x0,
flags = {
sweet = 1,
sour = 1
},
meat = 0x54 &amp;ldquo;Pork&amp;rdquo;
}
set print pretty off
关闭printf pretty这个选项，GDB显示结构体时会如下显示：
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54 &amp;ldquo;Pork&amp;rdquo;}
show print pretty
查看GDB是如何显示结构体的。
set print sevenbit-strings
设置字符显示，是否按“/nnn”的格式显示，如果打开，则字符串或字符数据按/nnn显示，
如“/065”。
show print sevenbit-strings
查看字符显示开关是否打开。
set print union
设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
Bug_forms;
struct thing {
Species it;
union {&lt;/p&gt;

&lt;p&gt;Tree_forms tree;
Bug_forms bug;
} form;
};
struct thing foo = {Tree, {Acorn}};
当打开这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
当关闭这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {&amp;hellip;}}
show print union
查看联合体数据的显示方式
set print object
在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法
调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是
off。
show print object
查看对象选项的设置。
set print static-members
这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是
on。
show print static-members
查看静态数据成员选项设置。
set print vtbl
当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。
show print vtbl
查看虚函数显示格式的选项。
##八、历史记录
当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB
会以$1, $2, $3 &amp;hellip;..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问
以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，
如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。&lt;/p&gt;

&lt;p&gt;##九、GDB环境变量
你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定
义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，
也是以$起头。如：
set $foo = *object_ptr
使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对
其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。
show convenience
该命令查看当前所设置的所有的环境变量。
这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。
例如：
set $i = 0
print bar[$i++]-&amp;gt;contents
于是，当你就不必，print bar[0]-&amp;gt;contents, print bar[1]-&amp;gt;contents地输入命令了。输入这样的
命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功
能。
##十、查看寄存器
要查看寄存器的值，很简单，可以使用如下命令：
info registers
查看寄存器的情况。（除了浮点寄存器）
info all-registers
查看所有寄存器的情况。（包括浮点寄存器）
info registers
查看所指定的寄存器的情况。
寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈
地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前
加一个$符号就可以了。如：p $eip。&lt;/p&gt;

&lt;p&gt;#改变程序的执行
———————
一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地
在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好
的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。
##一、修改变量值
修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。
如：
(gdb) print x=4
x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是
Pascal，那么你可以使用Pascal的语法：x:=4。
在某些时候，很有可能你的变量和GDB中的参数冲突，如：
(gdb) whatis width
type = double
(gdb) p width
$4 = 13
(gdb) set width=47
Invalid syntax in expression.
因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，
此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，
如：
(gdb) set var width=47
另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值
时，最好都使用set var格式的GDB命令。
##二、跳转执行
一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，
也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB
的jump命令来完：
jump&lt;/p&gt;

&lt;p&gt;指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏
移量格式。表式着下一条运行语句从哪里开始。
jump
这里的
是代码行的内存地址。
注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数
时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至
于产生程序Core Dump。所以最好是同一个函数中进行跳转。
熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，
jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行
的地址。如：
set $pc = 0x485
##三、产生信号量
使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便
于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，
这种精确地在某处产生信号非常有利程序的调试。
语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。
single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截
获的，而single命令所发出一信号则是直接发给被调试程序的。
##四、强制函数返回
如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数
忽略还没有执行的语句并返回。
return
return
使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认
作函数的返回值。
##五、强制调用函数&lt;/p&gt;

&lt;p&gt;call
表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返
回值是void，那么就不显示。
另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他
来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返
回值，并把该值存入历史数据中。
#在不同语言中使用GDB
——————————
GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和 Modula-2。一般说
来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”
的，GDB会认为是C程序。文件名后缀为“.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是
C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”
的会认为是汇编语言。
也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令
跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些表达式或
变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针的语法是*p，而在
Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言一同编译成的，那到在调
试过程中，GDB也能根据不同的语言自动地切换语言环境。这种跟着语言环境而改变的功
能，真是体贴开发人员的一种设计。
下面是几个相关于GDB语言环境的命令：
show language
查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默
认的环境。
info frame
查看当前函数的程序语言。
info source
查看当前文件的程序语言。
如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set
language命令即可做到。
当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：&lt;/p&gt;

&lt;p&gt;(gdb) set language
The currently understood settings are:
local or auto Automatic setting based on source file
c Use the C language
c++ Use the C++ language
asm Use the Asm language
chill Use the Chill language
fortran Use the Fortran language
java Use the Java language
modula-2 Use the Modula-2 language
pascal Use the Pascal language
scheme Use the Scheme language
于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。
#后记
——
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。（看到这句话时，希望各位千万再也不要认为
我就是“鄙视图形界面”，和我抬杠了 ）
我是根据版本为5.1.1的GDB所写的这篇文章，所以可能有些功能已被修改，或是又有更
为强劲的功能。而且，我写得非常仓促，写得比较简略，并且，其中我已经看到有许多错别
字了（我用五笔，所以错字让你看不懂），所以，我在这里对我文中的差错表示万分的歉意。
文中所罗列的GDB的功能时，我只是罗列了一些带用的GDB的命令和使用方法，其实，
我这里只讲述的功能大约只占GDB所有功能的60%吧，详细的文档，还是请查看GDB的
帮助和使用手册吧，或许，过段时间，如果我有空，我再写一篇GDB的高级使用。
我个人非常喜欢GDB的自动调试的功能，这个功能真的很强大，试想，我在UNIX下写个
脚本，让脚本自动编译我的程序，被自动调试，并把结果报告出来，调试成功，自动checkin
源码库。一个命令，编译带着调试带着checkin，多爽啊。只是GDB对自动化调试目前支持
还不是很成熟，只能实现半自动化，真心期望着GDB的自动化调试功能的成熟。&lt;/p&gt;

&lt;p&gt;如果各位对GDB或是别的技术问题有兴趣的话，欢迎和我讨论交流。本人目前主要在UNIX
下做产品软件的开发，所以，对UNIX下的软件开发比较熟悉，当然，不单单是技术，对软
件工程实施，软件设计，系统分析，项目管理我也略有心得。欢迎大家找我交流，（QQ是：
753640，MSN是：haoel@hotmail.com）
RelatedEntries：
文件操作 - 10 28, 2003
OSW:12.CVS设置与应用 - 10 28, 2003
MySQL AB Acquires Alzato - 10 24, 2003
cvs - 10 24, 2003
使用CVS进行版本管理 - 10 23, 2003&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用gdb调试程序笔记: 以段错误(Segmental fault)</title>
      <link>http://sun-friderick.github.io/post/2015-11-29-3</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29-3</guid>
      <description>&lt;p&gt;用gdb调试程序笔记: 以段错误(Segmental fault)为例[转]&lt;/p&gt;

&lt;p&gt;1.背景介绍
2.程序中常见的bug分类
3.程序调试器(如gdb)有什么用
4.段错误(Segmental fault)介绍
5.gdb调试入门&lt;/p&gt;

&lt;p&gt;一、背景介绍
这个笔记主要介绍开源的程序调试器(gdb)的入门知识，目的是使unix/linux环境的编程新手能够快速学会使用gdb调试程序的方法，同时也是对我使用gdb的一个经验总结。
本文假设你能使用简单的unix/linux命令并能用gcc(GNU C Compiler， GNU C 语言编译器)编译程序，当然有编程经验更好。：）
为帮助你理解和操作，我将使用我遇到过的真实事例来演示使用gdb调试有缺陷(bug)的程序过程，你看过这篇笔记后能自己动手练一下最好。&lt;/p&gt;

&lt;p&gt;二、程序中常见的缺陷(bug)分类
程序(编译型程序，perl、python，php等脚本程序除外)中常见的bug通常分为两类： 语法错误和逻辑错误，或者编译时错误和运行是错误。
语法错误(编译时错误)是我们在编写源代码时没有按照相关的语言规范(如ANSI C标准)导致编译时出错，编译失败。这种错误的检查和调试一般是比较简单和直接的：因为编译器(如gcc)通常会明确告诉你错误的原因和大致的范围(注意不一定是准确的错误行)。例如下面的一个简单demo.c程序的第8行缺失了一个分号，gcc指示第10行前少了一个分号。这就是一个典型的语法错误。
geekard@geekard:~/test$ cat -n demo.c
     1    #include&lt;stdio.h&gt;
     2&lt;br /&gt;
     3    int
     4    main(){
     5&lt;br /&gt;
     6        int n;
     7&lt;br /&gt;
     8        printf(&amp;ldquo;the n is:%c&amp;rdquo;, n)
     9&lt;br /&gt;
    10        return 0;
    11    }
geekard@geekard:~/test$ gcc demo.c -o demo
demo.c: In function ‘main’:demo.c:10:
error: expected ‘;’ before ‘return’
添加了分号再编译一次，这下没有出现问题，运行程序的结果如下：
geekard@geekard:~/test$ ./demo
the n is:6680564
另外注意这个程序中的变量n，我定义其为整型变量但并没有对其初始化赋值，这就是一个逻辑错误：编译器不会指示这个错误，只有在实际运行或测试时才能发现。
这个小程序只是一个故意的编造，但在实际编程中无论你多高明，经验多丰富，难免会在此处犯些小错误(想想吧：当你需要编写或维护一个成千上万行的代码，这种小概率事件就是确定事件了，：）)，而通常这些错误又是那么的浅显而易于消除，但是手工“除虫”（debug），往往是效率低下且让人厌烦的，本文将就&amp;rdquo;段错误&amp;rdquo;这个内存访问越界的错误谈谈如何使用gdb快速定位这些&amp;rdquo;段错误&amp;rdquo;的语句。&lt;/p&gt;

&lt;p&gt;三、程序调试器(如gdb)有什么用？(参考自gdb的在线帮助手册, 可用命令：man gdb， 或 info gdb查看)&lt;/p&gt;

&lt;p&gt;程序调试器(如gdb)的主要目的是让你能够查看正在执行的程序其内部特性(如执行流程、变量值、函数调用、堆栈等)，也可以程序崩溃时刻或以前都发生了什么。
Gdb对程序的调试能力主要体现在以下四个方面(当然不止这些):&lt;br /&gt;
. 启动你的程序，可以带任何影响其功能(或称行为)的参数。&lt;br /&gt;
. 能够使你的程序在指定条件下在指定的地方(断点)停止运行。&lt;br /&gt;
. 当你的程序在断点处停止时，你可以查看已执行的结果(如变量的值，函数之间的调用情况，执行到那一行代码，下一步该执行哪行代码)&lt;br /&gt;
. 改变你的程序中，你可以实验这种改变所带来的影响(如bug消除了，或者情况变得更糟糕)&lt;/p&gt;

&lt;p&gt;使用gdb，你可以调试C，C++，以及Modula-2语言编写的程序。&lt;/p&gt;

&lt;p&gt;四、段错误(Segmental fault)介绍
在用C/C++语言写程序的时侯，内存管理的绝大部分工作都是需要我们来做的。实际上，内存管理是一个比较繁琐的工作，所以像java和c#等语言采用了内存自动回收机制，避免了内存泄漏。如果程序试图往内存地址0处写东西时，内核就会向其发送段错误信号，如果程序没有捕获该信号，默认的操作时内核终止该程序的运行，例如我写的一个myls程序就遭遇了这种情况：
luck@geekard:~/codes/12.21$ ./myls -ld .
longlist 1, typelist 0, dirlist 1, filename .
Segmentation fault
luck@geekard:~/codes/12.21$&lt;/p&gt;

&lt;p&gt;常见的段错误原因如下：
1）往受到系统保护的内存地址写数据有些内存是内核占用的或者是其他程序正在使用，为了保证系统正常工作，所以会受到系统的保护，而不能任意访问
.2）内存越界(数组越界，变量类型不一致等)
下面我以上面的myls程序出现的错误为例介绍用gdb进行调试的方法和过程。&lt;/p&gt;

&lt;p&gt;五、gdb调试入门&lt;/p&gt;

&lt;p&gt;5.1 调试前的准备
我们首先要启动linux内核提供核心转储(core dump)机制：当程序中出现内存操作错误时，会发生崩溃并产生核心文件（core文件）。使用GDB可以对产生的核心文件进行分析，找出程序是在什么时候崩溃的和在崩溃之前程序都做了些什么。
首先，你的Segmentation Fault错误必须要能重现（废话…）。
然后，依参照下面的步骤来操作：
1）无论你是用Makefile来编译，还是直接在命令行手工输入命令来编译，都应该加上 -g 选项。如：
luck@geekard:~/codes/12.21$ ls
myls-0.0.c  myls-1.0.c  myls-2.0.c
luck@geekard:~/codes/12.21$ gcc -g -o myls myls-0.0.c
luck@geekard:~/codes/12.21$ ls
myls  myls-0.0.c  myls-1.0.c  myls-2.0.c
加了-g选项后，gcc就会在生成的可执行文件(这里-o myls表示输出(output)的可执行文件名时myls)里添加一些调试符号(debugging symbols)，有了这些调试符号后就可以在稍后用gdb调试时列出执行的程序的C源代码了。-g选项增大了文件体积，一般只是在刚开发出的程序调试时使用，当确定无误编译出实际使用的可执行文件时就不需要-g选项了。
2）一般来说，在默认情况下，在程序崩溃时，core文件是不生成的（很多Linux发行版在默认时禁止生成核心文件）。所以，你必须修改这个默认选项，在命令行执行：
ulimit -c unlimited     //unlimited 表示不限制生成的core文件的大小。
3）运行你的程序，不管用什么方法，使之重现Segmentation Fault错误。
luck@geekard:~/codes/12.21$ ./myls -ld .
longlist 1, typelist 0, dirlist 1, filename .
Segmentation fault (core dumped)
4）这时，你会发现在你程序同一目录下，生成了一个文件名为 core的文件，即核心文件。
luck@geekard:~/codes/12.21$ ls
core  myls  myls-0.0.c  myls-1.0.c  myls-2.0.cluck@geekard:~/codes/12.21$
5）用GDB调试它,在命令行执行：
luck@geekard:~/codes/12.21$ gdb ./myls   或者先启动gdb然后在gdb命令提示符中输入这两个文件：&lt;/p&gt;

&lt;p&gt;luck@geekard:~/codes/12.21$ gdb  //不带参数启动gdb调试程序
GNU gdb (GDB) 7.2-ubuntu
Copyright &amp;copy; 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;a href=&#34;http://gnu.org/licenses/gpl.html&#34;&gt;http://gnu.org/licenses/gpl.html&lt;/a&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &amp;ldquo;show copying&amp;rdquo;
and &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i686-linux-gnu&amp;rdquo;.
For bug reporting instructions, please see:
&lt;a href=&#34;http://www.gnu.org/software/gdb/bugs/&#34;&gt;http://www.gnu.org/software/gdb/bugs/&lt;/a&gt;.
(gdb) file ./myls                    //输入file命令和你的可执行文件名和路径，这里为当前目录下的myls文件
Reading symbols from /home/luck/codes/12.21/myls&amp;hellip;done.
(gdb) run -ld ./                       //带参数(这里为 -ld ./)运行r(run)程序，这和在bash命令行上执行：./myls -ld ./效果时一致的。
Starting program: /home/luck/codes/12.21/myls -ld ./
longlist 1, typelist 0, dirlist 1, filename ./            //myls程序的输出&lt;/p&gt;

&lt;p&gt;Program received signal SIGSEGV, Segmentation fault.       //出错后退出
0x0016e78f in vfprintf () from /lib/libc.so.6
(gdb)
从这里我们还发现进程是由于收到了SIGSEGV信号而结束的。通过进一步的查阅文档(man 7 signal)，我们知道SIGSEGV默认handler的动作是打印”段错误&amp;rdquo;的出错信息，并产生Core文件。
查看一下我的当前目录，果然有core文件。&lt;/p&gt;

&lt;p&gt;luck@geekard:~/codes/12.21$ ls
core  myls  myls-0.0.c  myls-1.0.c  myls-2.0.c&lt;/p&gt;

&lt;p&gt;下面我们就用刚才生成的分段错误产生的核心转储文件（core）再次调试程序。接着上一步的(gdb) 提示符，输入以下命令：&lt;/p&gt;

&lt;p&gt;(gdb) core core       //输入core命令和分段错误产生的核心转储文件，这里为当前目录下的core文件
A program is being debugged already.  Kill it? (y or n) y   //按y，重新调试
[New Thread 24884]
warning: Can&amp;rsquo;t read pathname for load map: Input/output error.
Reading symbols from /lib/libc.so.6&amp;hellip;(no debugging symbols found)&amp;hellip;done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2&amp;hellip;(no debugging symbols found)&amp;hellip;done.
Loaded symbols for /lib/ld-linux.so.2&lt;/p&gt;

&lt;p&gt;Core was generated by `./myls -ld .&amp;lsquo;.              //core文件记录了发生错误的程序执行的命令行参数
Program terminated with signal 11, Segmentation fault.
#0  0x002bb78f in vfprintf () from /lib/libc.so.6  //core文件记录了发生错误时程序的退出状态
(gdb)&lt;/p&gt;

&lt;p&gt;从标号为0的行我们并不能看出程序到底在哪出错,所以下一步需要确定发生错误前程序中函数之间的调用关系
(gdb) backtrace    //显示程序的堆栈信息
#0  0x0014f78f in vfprintf () from /lib/libc.so.6
#1  0x0016f4dc in vsprintf () from /lib/libc.so.6
#2  0x00157b4b in sprintf () from /lib/libc.so.6
#3  0x08048c56 in finalprt (file=0x8a9b02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:261
#4  0x080487c3 in detailList (file=0xbfab684d &amp;ldquo;.&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:132
#5  0x08048712 in main (argc=3, argv=0xbfab4804) at myls-0.0.c:89
(gdb)&lt;/p&gt;

&lt;p&gt;可以看出myls程序的函数调用关系为：
main() &amp;mdash;&amp;gt; detailList() &amp;mdash;&amp;gt; finalprt
然后在标号为0-2的行进入了系统的C库函数，所以产生错误的可能在标号3、4、5指明的函数中。
我们先看一下最后调用finalprt()函数时可能发生错误的代码行：&lt;/p&gt;

&lt;p&gt;(gdb) frame 3    //上面以#开头的行称为帧(frame)，这里指定查看第3帧
#3  0x08048c56 in finalprt (file=0x8a9b02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:261
261                    sprintf(str, &amp;ldquo;%c%d    %d,%d  %d  %d  %s&amp;rdquo;, filetype, permission, uid, gid, size, mdate, file);&lt;/p&gt;

&lt;p&gt;可以看到在调用sprintf()函数时可能发生了分段错误(由非法引用内存引起)，而sprintf()的原型为： int sprintf(char *str, const char *format, &amp;hellip;);
最有可能引起错误的地方是其第一个参数：char *str,一个指向字符串数组的指针，我们先把疑点放在这，接下来看一下函数之间相互调用时传递的参数值和函数的内部变量值：
(gdb) backtrace  full  //full参数表示完全显示函数之间相互调用时传递的参数值和函数的内部变量值
#0  0x0014f78f in vfprintf () from /lib/libc.so.6
No symbol table info available.
#1  0x0016f4dc in vsprintf () from /lib/libc.so.6
No symbol table info available.
#2  0x00157b4b in sprintf () from /lib/libc.so.6
No symbol table info available.
#3  0x08048c56 in finalprt (file=0x8a9b02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:261
        str = 0x4d11faec &lt;Address 0x4d11faec out of bounds&gt;
        flag = 65
#4  0x080487c3 in detailList (file=0xbfab684d &amp;ldquo;.&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:132
        ptr = 0x8048e44 &amp;ldquo;longlist %d, typelist %d, dirlist %d, filename %s\n&amp;rdquo;
        dirp = 0x8a9b008
        direntp = 0x8a9b020
#5  0x08048712 in main (argc=3, argv=0xbfab4804) at myls-0.0.c:89
        file = 0xbfab684d &amp;ldquo;.&amp;rdquo;
        ptr = 0x8048d30 &amp;ldquo;U\211\345WVS\350O&amp;rdquo;
        i = 3
        j = 3
        longlist = 1
        dirlist = 1
        typelist = 0
请注意序号3中的内部变量str的值 &lt;Address 0x4d11faec out of bounds&gt;，这表示发生了数组越界，难怪发生了段错误！
现在我们找到原因了：finalprt()中的第261行调用函数sprintf()时向其传递的第一个参数str发生里越界存取，于是内核终止程序的运行。&lt;/p&gt;

&lt;p&gt;下面我们要验证这个判断：在261处设置一个断点，程序运行到断点后单步执行，观察是否会发生错误。&lt;/p&gt;

&lt;p&gt;(gdb) stop                    //停止当前调试
(gdb) break 261              //在第261行设置一个断点
Breakpoint 1 at 0x8048bf1: file myls-0.0.c, line 261.
(gdb) run  -ld ./           //带参数运行程序(myls)
The program being debugged has been started already.
Start it from the beginning? (y or n) y   //当然yes&lt;/p&gt;

&lt;p&gt;Starting program: /home/luck/codes/12.21/myls -ld ./
longlist 1, typelist 0, dirlist 1, filename ./&lt;/p&gt;

&lt;p&gt;Breakpoint 1, finalprt (file=0x804c02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0, longlist=1)   //可以看到程序在第261行停止
    at myls-0.0.c:261
261                    sprintf(str, &amp;ldquo;%c%d    %d,%d  %d  %d  %s&amp;rdquo;, filetype, permission, uid, gid, size, mdate, file);&lt;/p&gt;

&lt;p&gt;(gdb) where                                //显示目前函数之间的调用情况与breaktrace命令功能相似
#0  finalprt (file=0x804c02b &amp;ldquo;..&amp;rdquo;, dirlist=1, typelist=0, longlist=1)
    at myls-0.0.c:261
#1  0x080487c3 in detailList (file=0xbffff830 &amp;ldquo;./&amp;rdquo;, dirlist=1, typelist=0,
    longlist=1) at myls-0.0.c:132
#2  0x08048712 in main (argc=3, argv=0xbffff6e4) at myls-0.0.c:89
(gdb) printf &amp;ldquo;%d\n&amp;rdquo;,filetype             //打印处函数中的变量filetype的值
100
(gdb) list                                //列出断点处前后的相关代码
256    //            if(filetype == &amp;rsquo;d&amp;rsquo;)
257                    sprintf(str, &amp;ldquo;%s\n&amp;rdquo;, file);
258                break;
259            case 0101:
260    //            if(filetype == &amp;rsquo;d&amp;rsquo;)
261                    sprintf(str, &amp;ldquo;%c%d    %d,%d  %d  %d  %s&amp;rdquo;, filetype, permission, uid, gid, size, mdate, file);
262                break;
263            case 0110:
264    //            if(filetype == &amp;rsquo;d&amp;rsquo;)
265                    sprintf(str, &amp;ldquo;%s%c&amp;rdquo;, file, filetype);
(gdb) n                      //然后单步执行代码,立即发生了错误&lt;/p&gt;

&lt;p&gt;Program received signal SIGSEGV, Segmentation fault.
0x0016e78f in vfprintf () from /lib/libc.so.6&lt;/p&gt;

&lt;p&gt;可见在线调试验证了我们的假设，的确时261行的sprintf语句有问题,下面我们看一下261所在的函数finalprt()中变量str的类型
(gdb) list finalprt    //列出函数finalprt()入口附近的源代码
225        *mdate_s = fstat.st_mtime;
226        return 0;
227    }
228&lt;br /&gt;
229    /&lt;em&gt;this function prints all the information&lt;/em&gt;/
230    static char *finalprt(char *file, int dirlist, int typelist, int longlist){
231&lt;br /&gt;
232        char *str;
233        int flag = 0000;
234&lt;br /&gt;
(gdb)
注意第232行的变量定义:str被错误的定义个指向char的指针，而sprintf()的第一个参数要求为一字符型数组的首地址,所以sprintf()调用时会发生内存越界的错误。&lt;/p&gt;

&lt;p&gt;接着考虑下去，以前用windows系统下的ie的时侯，有时打开某些网页，会出现“运行时错误”，这个时侯如果恰好你的机器上又装有windows的编译器的话，他会弹出来一个对话框，问你是否进行调试，如果你选择是，编译器将被打开，并进入调试状态，开始调试。
Linux下如何做到这些呢？
我们可以在要调试的程序中定义一个分段错误信号(SIGSEGV)的处理函数(handler),在该函数中中调用gdb，这样当段错误发生时程序就会自动启动gdb进行调试，一个简单的示例代码如下:&lt;/p&gt;

&lt;p&gt;/**
*段错误时启动调试
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;&lt;/p&gt;

&lt;p&gt;void
dump(int signo){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    char buf[1024];
    char cmd[1024];
    FILE *fh;

    snprintf(buf, sizeof(buf), &amp;quot;/proc/%d/cmdline&amp;quot;, getpid());  //取得进程的命令行文件地址
    if(!(fh = fopen(buf, &amp;quot;r&amp;quot;)))    //打开该文件
            exit(0);
    if(!fgets(buf, sizeof(buf), fh)) //将其内容读到buf数组中
            exit(0);
    fclose(fh);
    if(buf[strlen(buf) - 1] == &#39;\n&#39;) //删除独到的字符串中最后的还行符并保证字符串以空字符结尾
            buf[strlen(buf) - 1] = &#39;\0&#39;;
    snprintf(cmd, sizeof(cmd), &amp;quot;gdb %s %d&amp;quot;, buf, getpid());  //合并命令行参数
    system(cmd);               //执行cmd字符窜 代表的命令

    exit(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;void
dummy_function (void){       //测试函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    unsigned char *ptr = 0x00;
    *ptr = 0x00;        //向内存中0x00地址写数据，产生段错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;int
main (void)
{
        signal(SIGSEGV, &amp;amp;dump);  //捕获信号SIGSEGV，当接收到内核发送的SIGSEGV信号时调用处理函数dump()
        dummy_function ();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
编译运行效果如下:
luck@geekard test $ gcc -g -rdynamic f.c
luck@geekard test $ ./a.out
GNU gdb 6.5
Copyright &amp;copy; 2006 Free Software Foundation, Inc.
。。。。省略。。。。
0xffffe410 in __kernel_vsyscall ()
(gdb) bt
#0  0xffffe410 in __kernel_vsyscall ()
#1  0xb7ee4b53 in waitpid () from /lib/libc.so.6
#2  0xb7e925c9 in strtold_l () from /lib/libc.so.6
#3  0x08048830 in dump (signo=11) at f.c:22&lt;br /&gt;
#4  &lt;signal handler called&gt;
#5  0x0804884c in dummy_function () at f.c:31
#6  0x08048886 in main () at f.c:38
第3个frame指示发生错误的行为f.c中的22行，即为*ptr = 0x00;行。&lt;/p&gt;

&lt;p&gt;好了，以上就是这篇笔记的主要内容，下面总结一下gdb的主要命令：&lt;/p&gt;

&lt;p&gt;ulimit -c unlimited                                                //打开内核的核心转储机制
gcc -g -o outPutName sourceCodeName.c  //编译时加-g选项，使生成的可执行文件中包含调试信息
gdb outPutName core                                       //启动gdb，可以咋命令行上指定要调试程序
or:  gdb  file  outPutName                                //也可以在gdb命令提示符中输入要调试的程序名&lt;br /&gt;
core  core                                                           //指定程序执行错误时内核生成的转储文件
list  [function]|[row-number]                            //查看源代码，可以跟函数名或行号
break [function]|[row-number]                        //设置断点，可以跟函数名或行号
clear [function]|[row-number]                         //清除断点，可以跟函数名或行号或断点号
r     [paramiters]                                                /&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo静态网站生成器中文教程</title>
      <link>http://sun-friderick.github.io/post/2015-01-31</link>
      <pubDate>Sat, 31 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-01-31</guid>
      <description>

&lt;h1 id=&#34;前言:d605f9890f3528aea462ac7515ece633&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt;是什么？官方文档是这样介绍它的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hugo is a general-purpose website framework. Technically speaking, Hugo is a static site generator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hugo是一种通用的网站框架。严格来说，Hugo应该被称作静态网站生成器。&lt;/p&gt;

&lt;p&gt;静态网站生成器从字面上来理解，就是将你的内容生成静态网站。所谓“静态”的含义其实反映在网站页面的生成的时间。一般的web服务器（WordPress, Ghost, Drupal等等）在收到页面请求时，需要调用数据库生成页面（也就是HTML代码），再返回给用户请求。而静态网站则不需要在收到请求后生成页面，而是在整个网站建立起之前就将所有的页面全部生成完成，页面一经生成便称为静态文件，访问时直接返回现成的静态页面，不需要数据库的参与。&lt;/p&gt;

&lt;p&gt;采用静态网站的维护也相当简单，实际上你根本不需要什么维护，完全不用考虑复杂的运行时间，依赖和数据库的问题。再有也不用担心安全性的问题，没有数据库，网站注入什么的也无从下手。&lt;/p&gt;

&lt;p&gt;静态网站最大好处就是访问快速，不用每次重新生成页面。当然，一旦网站有任何更改，静态网站生成器需要重新生成所有的与更改相关的页面。然而对于小型的个人网站，项目主页等等，网站规模很小，重新生成整个网站也是非常快的。Hugo在速度方面做得非常好，Dan Hersam在他这个&lt;a href=&#34;https://www.udemy.com/build-static-sites-in-seconds-with-hugo/&#34;&gt;Hugo教程&lt;/a&gt;里提到，5000篇文章的博客，Hugo生成整个网站只花了6秒，而很多其他的静态网站生成器则需要几分钟的时间。我的博客目前文章只有几十篇，用Hugo生成整个网站只需要0.1秒。官方文档提供的数据是每篇页面的生成时间不到1ms。&lt;/p&gt;

&lt;p&gt;我认为对于个人博客来说，应该将时间花在内容上而不是各种折腾网站。Hugo会将Markdown格式的内容和设置好模版一起，生成漂亮干净的页面。挑选折腾好一个喜爱的模版，在Sublime Text里用Markdown写博客，再敲一行命令生成同步到服务器就OK了。整个体验是不是非常优雅简单还有点geek的味道呢？&lt;/p&gt;

&lt;p&gt;Hugo是用&lt;a href=&#34;http://golang.org/&#34;&gt;Go语言&lt;/a&gt;写的，为什么使用Go，作者&lt;a href=&#34;http://spf13.com&#34;&gt;Steve Francia&lt;/a&gt;的原话是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I looked at existing static site generators like Jekyll, Middleman and nanoc. All had complicated dependencies to install and took far longer to render my blog with hundreds of posts than I felt was acceptable. I wanted a framework to be able to get rapid feedback while making changes to the templates, and the 5+-minute render times was just too slow. In general, they were also very blog minded and didn’t have the ability to have different content types and flexible URLs.&lt;/p&gt;

&lt;p&gt;I wanted to develop a fast and full-featured website framework without dependencies. The Go language seemed to have all of the features I needed in a language. I began developing Hugo in Go and fell in love with the language. I hope you will enjoy using (and contributing to) Hugo as much as I have writing it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结他的一下大意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;吐槽脸：Jekyll以及那一堆静态网站生成器安装麻烦（依赖多），速度又慢，内容类型单一，url死板&lt;/li&gt;
&lt;li&gt;挽袖子状：Go挺萌的符合我对语言的一切幻想，就用它重写一个吧&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我为啥用Hugo？除了以上提到的原因，很重要的一点是&lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo主页&lt;/a&gt;很漂亮，看了一圈静态网站生成器的主页，一眼就被Hugo的美到了，首页的照片里的那个格子小本子应该是&lt;a href=&#34;http://www.paperthinks.com&#34;&gt;Paperthinks&lt;/a&gt;，我正好也在用，有种刚好看到自己桌面的感觉。&lt;/p&gt;

&lt;h1 id=&#34;安装:d605f9890f3528aea462ac7515ece633&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;如果说速度快是Hugo的第一大优点，那么安装简单应该就是Hugo的第二大优点。对于Mac用户，没有brew的话先安装brew，在命令行里敲：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再敲一行安装Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew new Hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以在&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;这里&lt;/a&gt;直接下载对应系统的binary文件，解压就行了。&lt;/p&gt;

&lt;h1 id=&#34;了解hugo:d605f9890f3528aea462ac7515ece633&#34;&gt;了解Hugo&lt;/h1&gt;

&lt;p&gt;首先建立自己的网站，mysite是网站的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入该路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该目录下你可以看到以下几个目录和&lt;code&gt;config.toml&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ▸ archetypes/ 
 ▸ content/
 ▸ layouts/
 ▸ static/
   config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;是网站的配置文件，包括&lt;code&gt;baseurl&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;copyright&lt;/code&gt;等等网站参数。&lt;/p&gt;

&lt;p&gt;这几个文件夹的作用分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes：包括内容类型，在创建新内容时自动生成内容的配置&lt;/li&gt;
&lt;li&gt;content：包括网站内容，全部使用markdown格式&lt;/li&gt;
&lt;li&gt;layouts：包括了网站的模版，决定内容如何呈现&lt;/li&gt;
&lt;li&gt;static：包括了css, js, fonts, media等，决定网站的外观&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hugo提供了一些完整的主题可以使用，下载这些主题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时现成的主题存放在&lt;code&gt;themes/&lt;/code&gt;文件夹中。&lt;/p&gt;

&lt;p&gt;现在我们先熟悉一下Hugo，创建新页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;content/&lt;/code&gt;文件夹可以看到，此时多了一个markdown格式的文件&lt;code&gt;about.md&lt;/code&gt;，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
+++
date = &amp;quot;2015-02-01T18:19:54+08:00&amp;quot;
draft = true
title = &amp;quot;about&amp;quot;

+++

# 关于我
- 2010  HR@RUC
- 2014  CS@ICT, CAS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我在页面中加入了一些内容，然后运行Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -t hyde --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;参数的意思是使用hyde主题渲染我们的页面，注意到&lt;code&gt;about.md&lt;/code&gt;目前是作为草稿，即&lt;code&gt;draft&lt;/code&gt;参数设置为&lt;code&gt;true&lt;/code&gt;，运行Hugo时要加上&lt;code&gt;--buildDrafts&lt;/code&gt;参数才会生成被标记为草稿的页面。
在浏览器输入localhost:1313，就可以看到我们刚刚创建的页面。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/hugo-server-1.png&#34; alt=&#34;hugo-server-1&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;注意观察当前目录下多了一个文件夹&lt;code&gt;public/&lt;/code&gt;，这里面是Hugo生成的整个静态网站，如果使用Github pages来作为博客的Host，你只需要将&lt;code&gt;public/&lt;/code&gt;里的文件上传就可以，这相当于是Hugo的输出。&lt;/p&gt;

&lt;h1 id=&#34;主题选择:d605f9890f3528aea462ac7515ece633&#34;&gt;主题选择&lt;/h1&gt;

&lt;p&gt;进入&lt;code&gt;themes/hyde&lt;/code&gt;文件夹，可以看到熟悉的文件夹名，和主题相关的文件主要是在&lt;code&gt;layouts/&lt;/code&gt;和&lt;code&gt;static/&lt;/code&gt;这两个文件内，选择好一个主题后，可以将&lt;code&gt;themes/&lt;/code&gt;中的文件夹直接复制到&lt;code&gt;mysite/&lt;/code&gt;目录下，覆盖原来的&lt;code&gt;layouts/&lt;/code&gt;, &lt;code&gt;static/&lt;/code&gt;文件夹，此时直接使用\$Hugo server就可以看到主题效果，修改主题也可以直接修改其中的css, js, html等文件。&lt;/p&gt;

&lt;p&gt;我的博客模版是在Hugo作者spf13的&lt;a href=&#34;http://spf13.com&#34;&gt;博客&lt;/a&gt;基础上修改的。第一步，先去他的博客网站源码&lt;a href=&#34;https://github.com/spf13/spf13.com&#34;&gt;主页&lt;/a&gt;把整个项目clone下来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:spf13/spf13.com.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把项目中的&lt;code&gt;static/&lt;/code&gt;和&lt;code&gt;layouts/&lt;/code&gt;文件复制到自己网站的目录下替换原来的文件夹。再次运行Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --buildDrafts -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次没有选择主题，如果选择了主题会将当前的主题覆盖掉。参数&lt;code&gt;-w&lt;/code&gt;意味监视watch，此时如果修改了网站内的信息，会直接显示在浏览器的页面上，不需要重新运行\$hugo server，方便我们进行修改。这是采用了spf13主题的页面：&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/hugo-server-2.png&#34; alt=&#34;hugo-server-2&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;我们尝试在他的主题基础上修改，找到&lt;code&gt;/layouts/partials/subheader.html&lt;/code&gt;文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;header id=&amp;quot;header&amp;quot;&amp;gt;
    &amp;lt;figure&amp;gt;
      &amp;lt;a href=&amp;quot;/&amp;quot; border=0 id=&amp;quot;logolink&amp;quot;&amp;gt;&amp;lt;div class=&amp;quot;icon-spf13-3&amp;quot; id=&amp;quot;logo&amp;quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;/figure&amp;gt;
    &amp;lt;div id=&amp;quot;byline&amp;quot;&amp;gt;by Steve Francia&amp;lt;/div&amp;gt;
    &amp;lt;nav id=&amp;quot;nav&amp;quot;&amp;gt;
    {{ partial &amp;quot;nav.html&amp;quot; . }}
    {{ partial &amp;quot;social.html&amp;quot; . }}
    &amp;lt;/nav&amp;gt;
&amp;lt;/header&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将by Steve Francia换成by myname，再次回到浏览器，可以看到左边侧栏已经发生变化了，你可以根据自己的需要修改对应的文件，当然得懂一点css, html。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/hugo-server-change.png&#34; alt=&#34;hugo-server-change&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;h1 id=&#34;评论功能:d605f9890f3528aea462ac7515ece633&#34;&gt;评论功能&lt;/h1&gt;

&lt;p&gt;个人博客当然不能没有评论，Hugo默认支持&lt;a href=&#34;https://disqus.com/&#34;&gt;Disqus&lt;/a&gt;的评论，需要在模版中添加以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ template &amp;quot;_internal/disqus.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spf13在&lt;code&gt;/layouts/partials/disqus.html&lt;/code&gt;中已经添加好了。&lt;/p&gt;

&lt;p&gt;只需要去Disqus注册一个账号，然后在&lt;code&gt;config.toml&lt;/code&gt;里加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disqusShortname = &amp;quot;yourdisqusShortname&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;-w&lt;/code&gt;参数是不能监测&lt;code&gt;config.toml&lt;/code&gt;里参数变化的，因此需要重新运行Hugo，进入localhost:1313/about，可以看到评论功能。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://sun-friderick.github.io/media/comments.png&#34; alt=&#34;comments&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;h1 id=&#34;代码高亮:d605f9890f3528aea462ac7515ece633&#34;&gt;代码高亮&lt;/h1&gt;

&lt;p&gt;作为码农，代码高亮对于写博客来说当然必不可少。有两种方法：第一种是在生成页面时就生成好代码高亮过的页面；第二种是使用js，用户加载页面时浏览器再进行渲染。&lt;/p&gt;

&lt;p&gt;第一种方法需要使用&lt;a href=&#34;http://pygments.org/&#34;&gt;Pygments&lt;/a&gt;，一个python写的工具。&lt;/p&gt;

&lt;p&gt;安装Pygments：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ pip install Pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有pip的先下载 &lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py&#34;&gt;https://bootstrap.pypa.io/get-pip.py&lt;/a&gt; ，然后安装pip：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pygments的调用采用shortcodes实现，spf13里也写好了，在&lt;code&gt;/layouts/shortcode/highlight.html&lt;/code&gt;里&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ $lang := index .Params 0 }}
{{ highlight .Inner $lang }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要使代码高亮，在你的代码外面加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ % highlight python %}}
your code here.
{{ % /highlight %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里为了避免以上两行被识别为代码高亮的标识，在&lt;code&gt;{{&lt;/code&gt;和&lt;code&gt;%&lt;/code&gt;之间多加了一个空格，实际使用的时候需要把空格去掉。&lt;/p&gt;

&lt;p&gt;第二种方法比较简单，在&lt;code&gt;layouts/partials/header_includes.html&lt;/code&gt;中加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;https://yandex.st/highlightjs/8.0/highlight.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://yandex.st/highlightjs/8.0/styles/default.min.css&amp;quot;&amp;gt;
&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了&lt;a href=&#34;http://yandex.ru/&#34;&gt;Yandex&lt;/a&gt;的&lt;a href=&#34;http://highlightjs.org/&#34;&gt;Highlight.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其他的可以实现代码高亮的js库还有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://highlightjs.org/&#34;&gt;Highlight.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://craig.is/making/rainbows&#34;&gt;Rainbow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alexgorbatchev.com/SyntaxHighlighter/&#34;&gt;Syntax Highlighter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://code.google.com/p/google-code-prettify/&#34;&gt;Google Prettify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;插入图片:d605f9890f3528aea462ac7515ece633&#34;&gt;插入图片&lt;/h1&gt;

&lt;p&gt;图片文件放在&lt;code&gt;static/media&lt;/code&gt;文件中，插入图片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ % img src=&amp;quot;/media/example.jpg&amp;quot; alt=&amp;quot;example&amp;quot; %}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的&lt;code&gt;{{&lt;/code&gt;和&lt;code&gt;%&lt;/code&gt;之间也加上了空格，避免这行代码起作用，实际使用也需要把空格去掉。&lt;/p&gt;

&lt;h1 id=&#34;使用mathjax:d605f9890f3528aea462ac7515ece633&#34;&gt;使用Mathjax&lt;/h1&gt;

&lt;p&gt;在需要渲染公式的页面加入以下代码，比如&lt;code&gt;layouts/_default/single.html&lt;/code&gt;文件，这个文件是对于所有post进行页面生成的模版，如果你希望所有页面都对公式渲染的话，可以加入&lt;code&gt;layouts/partials/footer.html&lt;/code&gt;文件里，保证所有生成的页面都有这几行代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;
  src=&amp;quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mathjax和Markdown会有冲突问题，&lt;a href=&#34;http://doswa.com/2011/07/20/mathjax-in-markdown.html&#34;&gt;这里&lt;/a&gt;提供了解决方案。&lt;/p&gt;

&lt;h1 id=&#34;用github-pages作为网站的host:d605f9890f3528aea462ac7515ece633&#34;&gt;用github pages作为网站的Host&lt;/h1&gt;

&lt;p&gt;Github pages分为两种：一种是项目主页，每个项目都可以有一个；另一种是用户主页，一个用户只能有一个。&lt;/p&gt;

&lt;p&gt;因为用户主页只能有一个，所以建议使用项目主页托管，不过我这里采用了用户主页，反正我也只用一个博客，使用个人主页作为Host也相对更简单一点。&lt;/p&gt;

&lt;p&gt;我们需要创建两个单独的repo，一个用于放Hugo的输入文件，即除了&lt;code&gt;public/&lt;/code&gt;文件夹之外的所有文件，另一个放我们生成的静态网站，也就是&lt;code&gt;public/&lt;/code&gt;的内容。&lt;/p&gt;

&lt;p&gt;步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Github上创建repo &lt;code&gt;&amp;lt;your-project&amp;gt;-hugo&lt;/code&gt;，托管Hugo的输入文件。&lt;/li&gt;
&lt;li&gt;创建repo &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;，用于托管&lt;code&gt;public/&lt;/code&gt;文件夹，注意这里的repo名字一定要用自己的用户名，才会被当作是个人主页。&lt;/li&gt;
&lt;li&gt;clone your-project
&lt;code&gt;
$ git clone &amp;lt;&amp;lt;your-project&amp;gt;-hugo-url&amp;gt;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入your-project 目录
&lt;code&gt;
$ cd &amp;lt;your-project&amp;gt;-hugo
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删掉public目录（这个目录每次运行Hugo都会再次生成，不用担心）
&lt;code&gt;
$ rm -rf public
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把public/目录添加为submodule 与&lt;username&gt;.github.io同步
&lt;code&gt;
$ git submodule add git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加.gitignore文件，文件中写&lt;code&gt;public/&lt;/code&gt;，在同步&lt;code&gt;&amp;lt;your-project&amp;gt;-hugo&lt;/code&gt;时会忽略public文件夹&lt;/li&gt;
&lt;li&gt;下面是写好的一个script &lt;code&gt;deploy.sh&lt;/code&gt;，拷贝过去直接就能用，记得chmod +x deploy.sh加上运行权限。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi

# Push Hugo content 
git add -A
git commit -m &amp;quot;$msg&amp;quot;
git push origin master


# Build the project. 
hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add -A

# Commit changes.

git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back
cd ..

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等一小会儿（10分钟左右），你就能在&lt;a href=&#34;http://username.github.io/&#34;&gt;http://username.github.io/&lt;/a&gt; 这个页面看到你的网站了！每次更新网站或者写了新文章，只需要运行./deploy.sh 发布就搞定了，简单吧？&lt;/p&gt;

&lt;p&gt;Github pages还支持域名绑定，三个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; repo的跟目录下添加&lt;code&gt;CNAME&lt;/code&gt;文件，文件里写上你的域名，不用加http://的开头。&lt;/li&gt;
&lt;li&gt;记下&lt;a href=&#34;http://username.github.io/&#34;&gt;http://username.github.io/&lt;/a&gt; 的ip地址。
&lt;code&gt;
$ ping username.github.io
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在你的域名管理中加上两条A记录，分别是www和@，记录指向&lt;a href=&#34;http://username.github.io/&#34;&gt;http://username.github.io/&lt;/a&gt; 的ip地址，也需要等一小会儿生效。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;更改字体服务商:d605f9890f3528aea462ac7515ece633&#34;&gt;更改字体服务商&lt;/h1&gt;

&lt;p&gt;我的博客模版里用的字体是从googleapis里获取的，国内访问会下载失败，把字体库改成360的。
找到&lt;code&gt;layouts/partials/head_includes.html&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;link href=&#39;http://fonts.googleapis.com/css?family=Fjalla+One|Open+Sans:300&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其中的googleapis替换为useso就行了。&lt;/p&gt;

&lt;p&gt;教程会根据我的博客遇到的问题继续更新。&lt;/p&gt;

&lt;h1 id=&#34;增加网站分析:d605f9890f3528aea462ac7515ece633&#34;&gt;增加网站分析&lt;/h1&gt;

&lt;p&gt;使用网站分析可以帮助我们更好地了解博客的读者和流量来源，我使用了&lt;a href=&#34;http://tongji.baidu.com&#34;&gt;百度统计&lt;/a&gt;和&lt;a href=&#34;http://www.google.cn/webmasters/&#34;&gt;谷歌统计&lt;/a&gt;，注册帐号后只需要按照提示在模板中加入相应的script代码就可以了。&lt;/p&gt;

&lt;h1 id=&#34;写在最后:d605f9890f3528aea462ac7515ece633&#34;&gt;写在最后&lt;/h1&gt;

&lt;p&gt;注意：
 1. 在每篇文章会有个头部：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
date: 2015-11-29T00:30:03+08:00
description: &amp;quot;&amp;quot;
tags: [&amp;quot;gdb&amp;quot;,&amp;quot;gdb调试&amp;quot;,&amp;quot;gdb调试方法&amp;quot;,&amp;quot;多线程调试&amp;quot;,&amp;quot;网站&amp;quot;]
title: &amp;quot;gdb调试方法精粹&amp;quot;
topics: []
draft: false
url: /post/2015-11-29-8
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在最后的url字段属于站内引用，因此每一篇文章的url的值是不能相同的&lt;/p&gt;

&lt;h1 id=&#34;参考:d605f9890f3528aea462ac7515ece633&#34;&gt;参考&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://gohugo.io/overview/introduction/&#34;&gt;Hugo docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ipn.li/kernelpanic/3/&#34;&gt;《内核恐慌》静态网站生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.udemy.com/build-static-sites-in-seconds-with-hugo/&#34;&gt;Build Static Sites in Seconds with Hugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/&#34;&gt;Setting up a custom domain with GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本文转自&lt;a href=&#34;http://nanshu.wang/&#34;&gt;nanshu.wang&lt;/a&gt;的&lt;a href=&#34;http://nanshu.wang/post/2015-01-31/&#34;&gt;gitpage&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
