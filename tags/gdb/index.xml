<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Gdb on Frederick&#39;s blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://sun-friderick.github.io/tags/gdb/</link>
    <language>en-us</language>
    <author>Frederick Sun</author>
    <copyright>Copyright (c) 2015, Frederick Sun; all rights reserved.</copyright>
    <updated>Tue, 01 Dec 2015 00:30:03 CST</updated>
    
    <item>
      <title>用GDB调试程序</title>
      <link>http://sun-friderick.github.io/post/2015-11-31</link>
      <pubDate>Tue, 01 Dec 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-31</guid>
      <description>&lt;p&gt;#用GDB调试程序
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。
#用GDB调试程序
##GDB概述
————
GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那
种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你
会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，
尺有所短”就是这个道理。
一般来说，GDB主要帮忙你完成下面四个方面的功能：
1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
3、当程序被停住时，可以检查此时你的程序中所发生的事。
4、动态的改变你程序的执行环境。
从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细
节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有
时候，命令行的调试工具却有着图形化工具所不能完成的功能。让我们一一看来。
##一个调试示例
——————
源程序：tst.c
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i&lt;7; i++) {
8 sum+=i; 
9 } 
10 return sum; 
11 } 
12 
13 
14 main() 
15 { 
16 int i; 
17 long result = 0; 
18 for(i=1; i&lt;=100; i++) 
19 { 
20 result += i; 
21 } 
22 
23 printf(&#34;result[1-100] = %d /n&#34;, result ); 
24 printf(&#34;result[1-250] = %d /n&#34;, func(250) ); 
25 } 
编译生成执行文件：（Linux下） 
hchen/test&gt; cc -g tst.c -o tst
使用GDB调试：
hchen/test&amp;gt; gdb tst &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;- 启动GDB
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &amp;ldquo;show copying&amp;rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i386-suse-linux&amp;rdquo;&amp;hellip;
(gdb) l &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; l命令相当于list，从第一行开始例出原码。
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i 7 {
8 sum+=i;
9 }
10 return sum;
(gdb) &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 直接回车表示，重复上一次命令
11 }&lt;/p&gt;

&lt;p&gt;12
13
14 main()
15 {
16 int i;
17 long result = 0;
18 for(i=1; i&amp;lt;=100; i++)
19 {
20 result += i;
(gdb) break 16 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 设置断点，在源程序第16行处。
Breakpoint 1 at 0x8048496: file tst.c, line 16.
(gdb) break func &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 设置断点，在函数func()入口处。
Breakpoint 2 at 0x8048456: file tst.c, line 5.
(gdb) info break &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; 查看断点信息。
Num Type Disp Enb Address What
1 breakpoint keep y 0x08048496 in main at tst.c:16
2 breakpoint keep y 0x08048456 in func at tst.c:5
(gdb) r &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 运行程序，run命令简写
Starting program: /home/hchen/test/tst
Breakpoint 1, main () at tst.c:17 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;- 在断点处停住。
17 long result = 0;
(gdb) n &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 单条语句执行，next命令简写。
18 for(i=1; i&amp;lt;=100; i++)
(gdb) n
20 result += i;
(gdb) n
18 for(i=1; i&amp;lt;=100; i++)
(gdb) n
20 result += i;
(gdb) c &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 继续运行程序，continue命令简写。
Continuing.
result[1-100] = 5050 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-程序输出。
Breakpoint 2, func (n=250) at tst.c:5
5 int sum=0,i;
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)
(gdb) p i &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 打印变量i的值，print命令简写。
$1 = 134513808
(gdb) n
8 sum+=i;
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)&lt;/p&gt;

&lt;p&gt;(gdb) p sum
$2 = 1
(gdb) n
8 sum+=i;
(gdb) p i
$3 = 2
(gdb) n
6 for(i=1; i&amp;lt;=n; i++)
(gdb) p sum
$4 = 3
(gdb) bt &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 查看函数堆栈。
#0 func (n=250) at tst.c:5
#1 0x080484e4 in main () at tst.c:24
#2 0x400409ed in __libc_start_main () from /lib/libc.so.6
(gdb) finish &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 退出函数。
Run till exit from #0 func (n=250) at tst.c:5
0x080484e4 in main () at tst.c:24
24 printf(&amp;ldquo;result[1-250] = %d /n&amp;rdquo;, func(250) );
Value returned is $6 = 31375
(gdb) c &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 继续运行。
Continuing.
result[1-250] = 31375 &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;-程序输出。
Program exited with code 027. &amp;lt;&amp;mdash;&amp;mdash;&amp;ndash;程序退出，调试结束。
(gdb) q &amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 退出gdb。
hchen/test&amp;gt;
好了，有了以上的感性认识，还是让我们来系统地认识一下gdb吧。
使用GDB
————
一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必
须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。
如：
&amp;gt; cc -g hello.c -o hello
&amp;gt; g++ -g hello.cpp -o hello
如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用
-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。
启动GDB的方法有以下几种：&lt;/p&gt;

&lt;p&gt;###1、gdb
program也就是你的执行文件，一般在当然目录下。
###2、gdb core
用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
###3、gdb
如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自
动attach上去，并调试他。program应该在PATH环境变量中搜索得到。
GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下
面只例举一些比较常用的参数：
-symbols
-s
从指定文件中读取符号表。
-se file
从指定文件中读取符号表信息，并把他用在可执行文件中。
-core
-c
调试时core dump的core文件。
-directory
-d
加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
#GDB的命令概貌
———————
启动gdb后，就你被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb
的命令可以使用help命令来查看，如下所示：
/home/hchen&amp;gt; gdb
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &amp;ldquo;show copying&amp;rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &amp;ldquo;show warranty&amp;rdquo; for details.
This GDB was configured as &amp;ldquo;i386-suse-linux&amp;rdquo;.
(gdb) help&lt;/p&gt;

&lt;p&gt;List of classes of commands:
aliases &amp;ndash; Aliases of other commands
breakpoints &amp;ndash; Making program stop at certain points
data &amp;ndash; Examining data
files &amp;ndash; Specifying and examining files
internals &amp;ndash; Maintenance commands
obscure &amp;ndash; Obscure features
running &amp;ndash; Running the program
stack &amp;ndash; Examining the stack
status &amp;ndash; Status inquiries
support &amp;ndash; Support facilities
tracepoints &amp;ndash; Tracing of program execution without stopping the program
user-defined &amp;ndash; User-defined commands
Type &amp;ldquo;help&amp;rdquo; followed by a class name for a list of commands in that class.
Type &amp;ldquo;help&amp;rdquo; followed by command name for full documentation.
Command name abbreviations are allowed if unambiguous.
(gdb)
gdb的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看
种类中的命令，可以使用help 命令，如：help breakpoints，查看设置断点的所有命令。也
可以直接help 来查看命令的帮助。
gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令
的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐
命令的全称，如果有重复的，那么gdb会把其例出来。
示例一：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func
(gdb) b func
Breakpoint 1 at 0x8048458: file hello.c, line 10.
示例二：敲入b按两次TAB键，你会看到所有b打头的命令：
(gdb) b
backtrace break bt
(gdb)
示例三：只记得函数的前缀，可以这样：
(gdb) b make_ &amp;lt;按TAB键&amp;gt;
（再按下一次TAB键，你会看到:）
make_a_section_from_file make_environ
make_abs_section make_function_type
make_blockvector make_pointer_type&lt;/p&gt;

&lt;p&gt;make_cleanup make_reference_type
make_command make_symbol_completion&lt;em&gt;list
(gdb) b make&lt;/em&gt;
GDB把所有make开头的函数全部例出来给你查看。
示例四：调试C++的程序时，有可以函数名一样。如：
(gdb) b &amp;lsquo;bubble( M-?
bubble(double,double) bubble(int,int)
(gdb) b &amp;lsquo;bubble(
你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思）
要退出gdb时，只用发quit或命令简称q就行了。
GDB中运行UNIX的shell程序
————————————
在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
shell
调用UNIX的shell来执行，环境变量SHELL中定义的UNIX的shell将会被用来执行，如
果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。（在Windows中使用Command.com
或cmd.exe）
还有一个gdb命令是make：
make
可以在gdb中执行make命令来重新build自己的程序。这个命令等价于“shell make ”。
在GDB中运行程序
————————
当以gdb 方式启动gdb后，gdb会在PATH路径和当前目录中搜索的源文件。如要确认gdb
是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。
在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。
###1、程序运行参数。
set args 可指定运行时参数。（如：set args 10 20 30 40 50）
show args 命令可以查看设置好的运行参数。
###2、运行环境。
path
可设定程序的运行路径。
show paths 查看程序的运行路径。&lt;/p&gt;

&lt;p&gt;set environment varname [=value] 设置环境变量。如：set env USER=hchen
show environment [varname] 查看环境变量。
###3、工作目录。
cd
相当于shell的cd命令。
pwd 显示当前的所在目录。
###4、程序的输入输出。
info terminal 显示你程序用到的终端的模式。
使用重定向控制程序输出。如：run &amp;gt; outfile
tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb
#调试已运行的程序
————————
两种方法：
1、在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在
运行的程序。
2、先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用
detach来取消挂接的进程。
#暂停 / 恢复程序运行
—————————
调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序
的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变
量，以及运行时的流程。
当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停
的原因。
在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕
捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可
以使用c或是continue命令。
##一、设置断点（BreakPoint）
我们用break命令来设置断点。正面有几点设置断点的方法：
break
在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函&lt;/p&gt;

&lt;p&gt;数名。
break
在指定行号停住。
break +offset
break -offset
在当前行号的前面或后面的offset行停住。offiset为自然数。
break filename:linenum
在源文件filename的linenum行处停住。
break filename:function
在源文件filename的function函数的入口处停住。
break *address
在程序运行的内存地址处停住。
break
break命令没有参数时，表示在下一条指令处停住。
break &amp;hellip; if
&amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设
置break if i=100，表示当i为100时停住程序。
查看断点时，可使用info命令，如下所示：（注：n表示断点号）
info breakpoints [n]
info break [n]
##二、设置观察点（WatchPoint）
观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马
上停住程序。我们有下面的几种方法来设置观察点：
watch
为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
rwatch
当表达式（变量）expr被读时，停住程序。
awatch
当表达式（变量）的值被读或被写时，停住程序。&lt;/p&gt;

&lt;p&gt;info watchpoints
列出当前所设置了的所有观察点。
##三、设置捕捉点（CatchPoint）
你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++
的异常。设置捕捉点的格式为：
catch
当event发生时，停住程序。event可以是下面的内容：
1、throw 一个C++抛出的异常。（throw为关键字）
2、catch 一个C++捕捉到的异常。（catch为关键字）
3、exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）
4、fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）
5、vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）
6、load 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX
下有用）
7、unload 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在
HP-UX下有用）
tcatch
只设置一次捕捉点，当程序停住以后，应点被自动删除。
##四、维护停止点
上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你
觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来
进行维护。
clear
清除所有的已定义的停止点。
clear
clear
清除所有设置在函数上的停止点。
clear
clear
清除所有设置在指定行上的停止点。
delete [breakpoints] [range&amp;hellip;]
删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range
表示断点号的范围（如：3-7）。其简写命令为d。&lt;/p&gt;

&lt;p&gt;比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要
时，enable即可，就好像回收站一样。
disable [breakpoints] [range&amp;hellip;]
disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的
停止点。简写命令是dis.
enable [breakpoints] [range&amp;hellip;]
enable所指定的停止点，breakpoints为停止点号。
enable [breakpoints] once range&amp;hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。
enable [breakpoints] delete range&amp;hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。
##五、停止条件维护
前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这
是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点
设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以
用condition命令来修改断点的条件。（只有break和watch命令支持if，catch目前暂不支持
if）
condition
修改断点号为bnum的停止条件为expression。
condition
清除断点号为bnum的停止条件。
还有一个比较特殊的维护命令ignore，你可以指定程序运行时，忽略停止条件几次。
ignore
表示忽略断点号为bnum的停止条件count次。
##六、为停止点设定运行命令
我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的
程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于
GDB的自动化调试是一个强大的支持。
commands [bnum]&lt;/p&gt;

&lt;p&gt;&amp;hellip; command-list &amp;hellip;
end
为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的
命令。
例如：
break foo if x&amp;gt;0
commands
printf &amp;ldquo;x is %d/n&amp;rdquo;,x
continue
end
断点设置在函数foo中，断点条件是x&amp;gt;0，如果程序被断住后，也就是，一旦x的值在foo
函数中大于0，GDB会自动打印出x的值，并继续运行程序。
如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个
end就行了。
##七、断点菜单
在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break 不
能告诉GDB要停在哪个函数的入口。当然，你可以使用break 也就是把函数的参数类型告
诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的
断点。你只要输入你菜单列表中的编号就可以了。如：
(gdb) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
&amp;gt; 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the &amp;ldquo;delete&amp;rdquo; command to delete unwanted
breakpoints.
(gdb)&lt;/p&gt;

&lt;p&gt;可见，GDB列出了所有after的重载函数，你可以选一下列表编号就行了。0表示放弃设置
断点，1表示所有函数都设置断点。
##八、恢复程序运行和单步调试
当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。
也可以使用step或next命令单步跟踪程序。
continue [ignore-count]
c [ignore-count]
fg [ignore-count]
恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次
数。continue，c，fg三个命令都是一样的意思。
step
单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug
信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，
加表示执行后面的count条指令，然后再停住。
next
同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面
可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后
再停住。
set step-mode
set step-mode on
打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。
这个参数有很利于查看机器码。
set step-mod off
关闭step-mode模式。
finish
运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
until 或 u
当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
stepi 或 si
nexti 或 ni
单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步
执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单
步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）&lt;/p&gt;

&lt;p&gt;##九、信号（Signals）
信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤
其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT
表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示
子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下
非常重要的一种技术。
GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信
号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。
你可以用GDB的handle命令来完成这一功能。
handle
在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处
理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包
括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。
一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几
种关键字的一个或多个。
nostop
当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信
号。
stop
当被调试的程序收到信号时，GDB会停住你的程序。
print
当被调试的程序收到信号时，GDB会显示出一条信息。
noprint
当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。
pass
noignore
当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程
序会处理。
nopass
ignore
当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
info signals
info handle
查看有哪些信号在被GDB检测中。
##十、线程（Thread Stops）&lt;/p&gt;

&lt;p&gt;如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线
程。GDB很容易帮你完成这一工作。
break thread
break thread if &amp;hellip;
linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是
GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你
不指定thread 则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如：
(gdb) break frik.c:13 thread 28 if bartab &amp;gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体
情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。
#查看栈信息
—————
当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一
个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以
用GDB命令来查看当前的栈中的信息。
下面是一些查看函数调用栈信息的GDB命令：
backtrace
bt
打印当前的函数调用栈的所有信息。如：
(gdb) bt
#0 func (n=250) at tst.c:6
#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2 0x400409ed in &lt;strong&gt;libc_start_main () from /lib/libc.so.6
从上可以看出函数的调用栈信息：&lt;/strong&gt;libc_start_main &amp;ndash;&amp;gt; main() &amp;ndash;&amp;gt; func()
backtrace
bt
n是一个正整数，表示只打印栈顶上n层的栈信息。
backtrace &amp;lt;-n&amp;gt;
bt &amp;lt;-n&amp;gt;
-n表一个负整数，表示只打印栈底下n层的栈信息。
如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈&lt;/p&gt;

&lt;p&gt;就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。
frame
f
n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的
第二层。
up
表示向栈的上面移动n层，可以不打n，表示向上移动一层。
down
表示向栈的下面移动n层，可以不打n，表示向下移动一层。
上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三
个命令：
select-frame 对应于 frame 命令。
up-silently 对应于 up 命令。
down-silently 对应于 down 命令。
查看当前栈层的信息，你可以用以下GDB命令：
frame 或 f
会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数
执行到的语句。
info frame
info f
这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比
如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写
成的、函数参数地址及值、局部变量的地址等等。如：
(gdb) info f
Stack level 0, frame at 0xbffff5d4:
eip = 0x804845d in func (tst.c:6); saved eip 0x8048524
called by frame at 0xbffff60c
source language c.
Arglist at 0xbffff5d4, args: n=250
Locals at 0xbffff5d4, Previous frame&amp;rsquo;s sp is 0x0
Saved registers:
ebp at 0xbffff5d4, eip at 0xbffff5d8
info args&lt;/p&gt;

&lt;p&gt;打印出当前函数的参数名及其值。
info locals
打印出当前函数中所有局部变量及其值。
info catch
打印出当前的函数中的异常处理信息。
#查看源程序
—————
##一、显示源代码
GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程
序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序
停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源
代码的GDB命令吧。
list
显示程序第linenum行的周围的源程序。
list
显示函数名为function的函数的源程序。
list
显示当前行后面的源程序。
list -
显示当前行前面的源程序。
一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当
然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。
set listsize
设置一次显示源代码的行数。
show listsize
查看当前listsize的设置。
list命令还有下面的用法：
list ,&lt;/p&gt;

&lt;p&gt;显示从first行到last行之间的源代码。
list ,
显示从当前行到last行之间的源代码。
list +
往后显示源代码。
一般来说在list后面可以跟以下这们的参数：
行号。
&amp;lt;+offset&amp;gt; 当前行号的正偏移量。
&amp;lt;-offset&amp;gt; 当前行号的负偏移量。
哪个文件的哪一行。
函数名。
哪个文件中的哪个函数。
&amp;lt;*address&amp;gt; 程序运行时的语句在内存中的地址。
##二、搜索源代码
不仅如此，GDB还提供了源代码搜索的命令：
forward-search
search
向前面搜索。
reverse-search
全部搜索。
其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，
还请各位查看相关资料。
##三、指定源文件的路径
某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供
了可以让你指定源文件的路径的命令，以便GDB进行搜索。
directory
dir
加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，
Windows下你可以使用“;”。&lt;/p&gt;

&lt;p&gt;directory
清除所有的自定义的源文件搜索路径信息。
show directories
显示定义了的源文件搜索路径。
##四、源代码的内存
你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函
数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内
存地址，如：
(gdb) info line tst.c:func
Line 5 of &amp;ldquo;tst.c&amp;rdquo; starts at address 0x8048456 and ends at 0x804845d .
还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前
内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。
(gdb) disassemble func
Dump of assembler code for function func:
0x8048450 : push %ebp
0x8048451 : mov %esp,%ebp
0x8048453 : sub $0x18,%esp
0x8048456 : movl $0x0,0xfffffffc(%ebp)
0x804845d : movl $0x1,0xfffffff8(%ebp)
0x8048464 : mov 0xfffffff8(%ebp),%eax
0x8048467 : cmp 0x8(%ebp),%eax
0x804846a : jle 0x8048470
0x804846c : jmp 0x8048480
0x804846e : mov %esi,%esi
0x8048470 : mov 0xfffffff8(%ebp),%eax
0x8048473 : add %eax,0xfffffffc(%ebp)
0x8048476 : incl 0xfffffff8(%ebp)
0x8048479 : jmp 0x8048464
0x804847b : nop
0x804847c : lea 0x0(%esi,1),%esi
0x8048480 : mov 0xfffffffc(%ebp),%edx
0x8048483 : mov %edx,%eax
0x8048485 : jmp 0x8048487
0x8048487 : mov %ebp,%esp
0x8048489 : pop %ebp
0x804848a : ret
End of assembler dump.&lt;/p&gt;

&lt;p&gt;#查看运行时数据
———————
在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令
inspect来查看当前程序的运行数据。print命令的格式是：
print
print /
是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格
式，比如，如果要把表达式按16进制的格式输出，那么就是/x。
##一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据
来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函
数等内容。可惜的是GDB不能使用你在程序中所定义的宏。
表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本
文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）
在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。
@
是一个和数组有关的操作符，在后面会有更详细的说明。
::
指定一个在文件或是一个函数中的变量。
{}
表示一个指向内存地址的类型为type的一个对象。
##二、程序变量
在GDB中，你可以随时查看以下三种变量的值：
1、全局变量（所有文件可见的）
2、静态全局变量（当前文件可见的）
3、局部变量（当前Scope可见的）
如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局
变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函&lt;/p&gt;

&lt;p&gt;数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量
的值时，你可以使用“::”操作符：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看
文件f2.c中的全局变量x的值：
gdb) p &amp;lsquo;f2.c&amp;rsquo;::x
当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所
以你不必担心在调试C++程序时会出现异常。
另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过
的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为
优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB
调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结
果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支
持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决
这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
##三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大
小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右
边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其
保存在变量len中，其输出结果，大约是下面这个样子的：
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。
##四、输出格式&lt;/p&gt;

&lt;p&gt;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。
例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要
做到这样，你可以使用GDB的数据显示格式：
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &amp;lsquo;e&amp;rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101
##五、查看内存
你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是
指令地址，那么格式可以是i。&lt;/p&gt;

&lt;p&gt;u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可
以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当
我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作
一个值取出来。
表示一个内存地址。
n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3
表示三个单位，u表示按十六进制显示。
##六、自动显示
你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显
示。相关的GDB命令是display。
display
display/
display/
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一
个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。
格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc
$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇
编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的
功能。
下面是一些和display相关的GDB命令：
undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以
用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）
disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。&lt;/p&gt;

&lt;p&gt;info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多
少个自动显示设置，其中包括，设置的编号，表达式，是否enable。
##七、设置显示选项
GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。
set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
如：
(gdb) f
#0 set_quotes (lq=0x34c78 &amp;ldquo;&amp;lt;&amp;lt;&amp;ldquo;, rq=0x34c88 &amp;ldquo;&amp;gt;&amp;gt;&amp;rdquo;)
at input.c:530
530 if (lquote != def_lquote)
set print address off
关闭函数的参数地址显示，如：
(gdb) set print addr off
(gdb) f
#0 set_quotes (lq=&amp;rdquo;&amp;lt;&amp;lt;&amp;ldquo;, rq=&amp;rdquo;&amp;gt;&amp;gt;&amp;ldquo;) at input.c:530
530 if (lquote != def_lquote)
show print address
查看当前地址显示选项是否打开。
set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗
号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。
set print array off
show print array
set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的
最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。
show print elements&lt;/p&gt;

&lt;p&gt;查看print elements的选项信息。
set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。
set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：
$1 = {
next = 0x0,
flags = {
sweet = 1,
sour = 1
},
meat = 0x54 &amp;ldquo;Pork&amp;rdquo;
}
set print pretty off
关闭printf pretty这个选项，GDB显示结构体时会如下显示：
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54 &amp;ldquo;Pork&amp;rdquo;}
show print pretty
查看GDB是如何显示结构体的。
set print sevenbit-strings
设置字符显示，是否按“/nnn”的格式显示，如果打开，则字符串或字符数据按/nnn显示，
如“/065”。
show print sevenbit-strings
查看字符显示开关是否打开。
set print union
设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
Bug_forms;
struct thing {
Species it;
union {&lt;/p&gt;

&lt;p&gt;Tree_forms tree;
Bug_forms bug;
} form;
};
struct thing foo = {Tree, {Acorn}};
当打开这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
当关闭这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {&amp;hellip;}}
show print union
查看联合体数据的显示方式
set print object
在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法
调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是
off。
show print object
查看对象选项的设置。
set print static-members
这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是
on。
show print static-members
查看静态数据成员选项设置。
set print vtbl
当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。
show print vtbl
查看虚函数显示格式的选项。
##八、历史记录
当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB
会以$1, $2, $3 &amp;hellip;..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问
以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，
如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。&lt;/p&gt;

&lt;p&gt;##九、GDB环境变量
你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定
义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，
也是以$起头。如：
set $foo = *object_ptr
使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对
其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。
show convenience
该命令查看当前所设置的所有的环境变量。
这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。
例如：
set $i = 0
print bar[$i++]-&amp;gt;contents
于是，当你就不必，print bar[0]-&amp;gt;contents, print bar[1]-&amp;gt;contents地输入命令了。输入这样的
命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功
能。
##十、查看寄存器
要查看寄存器的值，很简单，可以使用如下命令：
info registers
查看寄存器的情况。（除了浮点寄存器）
info all-registers
查看所有寄存器的情况。（包括浮点寄存器）
info registers
查看所指定的寄存器的情况。
寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈
地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前
加一个$符号就可以了。如：p $eip。&lt;/p&gt;

&lt;p&gt;#改变程序的执行
———————
一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地
在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好
的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。
##一、修改变量值
修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。
如：
(gdb) print x=4
x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是
Pascal，那么你可以使用Pascal的语法：x:=4。
在某些时候，很有可能你的变量和GDB中的参数冲突，如：
(gdb) whatis width
type = double
(gdb) p width
$4 = 13
(gdb) set width=47
Invalid syntax in expression.
因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，
此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，
如：
(gdb) set var width=47
另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值
时，最好都使用set var格式的GDB命令。
##二、跳转执行
一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，
也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB
的jump命令来完：
jump&lt;/p&gt;

&lt;p&gt;指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏
移量格式。表式着下一条运行语句从哪里开始。
jump
这里的
是代码行的内存地址。
注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数
时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至
于产生程序Core Dump。所以最好是同一个函数中进行跳转。
熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，
jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行
的地址。如：
set $pc = 0x485
##三、产生信号量
使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便
于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，
这种精确地在某处产生信号非常有利程序的调试。
语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。
single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截
获的，而single命令所发出一信号则是直接发给被调试程序的。
##四、强制函数返回
如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数
忽略还没有执行的语句并返回。
return
return
使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认
作函数的返回值。
##五、强制调用函数&lt;/p&gt;

&lt;p&gt;call
表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返
回值是void，那么就不显示。
另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他
来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返
回值，并把该值存入历史数据中。
#在不同语言中使用GDB
——————————
GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和 Modula-2。一般说
来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”
的，GDB会认为是C程序。文件名后缀为“.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是
C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”
的会认为是汇编语言。
也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令
跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些表达式或
变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针的语法是*p，而在
Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言一同编译成的，那到在调
试过程中，GDB也能根据不同的语言自动地切换语言环境。这种跟着语言环境而改变的功
能，真是体贴开发人员的一种设计。
下面是几个相关于GDB语言环境的命令：
show language
查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默
认的环境。
info frame
查看当前函数的程序语言。
info source
查看当前文件的程序语言。
如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set
language命令即可做到。
当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：&lt;/p&gt;

&lt;p&gt;(gdb) set language
The currently understood settings are:
local or auto Automatic setting based on source file
c Use the C language
c++ Use the C++ language
asm Use the Asm language
chill Use the Chill language
fortran Use the Fortran language
java Use the Java language
modula-2 Use the Modula-2 language
pascal Use the Pascal language
scheme Use the Scheme language
于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。
#后记
——
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。（看到这句话时，希望各位千万再也不要认为
我就是“鄙视图形界面”，和我抬杠了 ）
我是根据版本为5.1.1的GDB所写的这篇文章，所以可能有些功能已被修改，或是又有更
为强劲的功能。而且，我写得非常仓促，写得比较简略，并且，其中我已经看到有许多错别
字了（我用五笔，所以错字让你看不懂），所以，我在这里对我文中的差错表示万分的歉意。
文中所罗列的GDB的功能时，我只是罗列了一些带用的GDB的命令和使用方法，其实，
我这里只讲述的功能大约只占GDB所有功能的60%吧，详细的文档，还是请查看GDB的
帮助和使用手册吧，或许，过段时间，如果我有空，我再写一篇GDB的高级使用。
我个人非常喜欢GDB的自动调试的功能，这个功能真的很强大，试想，我在UNIX下写个
脚本，让脚本自动编译我的程序，被自动调试，并把结果报告出来，调试成功，自动checkin
源码库。一个命令，编译带着调试带着checkin，多爽啊。只是GDB对自动化调试目前支持
还不是很成熟，只能实现半自动化，真心期望着GDB的自动化调试功能的成熟。&lt;/p&gt;

&lt;p&gt;如果各位对GDB或是别的技术问题有兴趣的话，欢迎和我讨论交流。本人目前主要在UNIX
下做产品软件的开发，所以，对UNIX下的软件开发比较熟悉，当然，不单单是技术，对软
件工程实施，软件设计，系统分析，项目管理我也略有心得。欢迎大家找我交流，（QQ是：
753640，MSN是：haoel@hotmail.com）
RelatedEntries：
文件操作 - 10 28, 2003
OSW:12.CVS设置与应用 - 10 28, 2003
MySQL AB Acquires Alzato - 10 24, 2003
cvs - 10 24, 2003
使用CVS进行版本管理 - 10 23, 2003&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-29</link>
      <pubDate>Sun, 29 Nov 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-29</guid>
      <description>

&lt;p&gt;#gdb 跟踪调试命令整理&lt;/p&gt;

&lt;h1 id=&#34;gdb常用命令:27ab83445e035e5774461847bd2aa236&#34;&gt;gdb常用命令：&lt;/h1&gt;

&lt;p&gt;|                命令        | 描述           | Cool  |&lt;br /&gt;
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-:|&lt;br /&gt;
| backtrace（或bt）    |    查看各级函数调用及参数，运行时的堆栈   |&lt;br /&gt;
| finish                              |    连续运行到当前函数返回为止，然后停下来等待命令    |&lt;br /&gt;
| frame（或f）帧编号  |   选择栈帧       |&lt;br /&gt;
| info（或i） locals       |   查看当前栈帧局部变量的值   |&lt;br /&gt;
| list（或l）                     |    列出源代码，接着上次的位置往下列，每次列10行       |&lt;br /&gt;
| list 行号                          |   列出从第几行开始的源代码        |&lt;br /&gt;
| list 函数名                     |    列出某个函数的源代码   |&lt;br /&gt;
| next（或n）                 |    单步调试，执行下一行语句        |&lt;br /&gt;
| print（或p）                |    打印表达式的值，通过表达式可以修改变量的值或者调用函数     |&lt;br /&gt;
| quit（或q）                 |     退出gdb调试环境  |&lt;br /&gt;
| set var                           |     修改变量的值       |&lt;br /&gt;
| start                               |     开始执行程序，停在main函数第一行语句前面等待命令       |&lt;br /&gt;
| step（或s）                 |     执行下一行语句，如果有函数调用则进入到函数中  |&lt;/p&gt;

&lt;p&gt;#GDB 调试&lt;/p&gt;

&lt;p&gt;要进行调试程序首先要生成一个含有调试信息的执行程序命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc(g++) -g -o 文件名 源文件.c(源文件.cpp)
gcc(g++) -ggdb3 -o 文件名 源文件.c(源文件.cpp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时便会生成一个含有调试信息的可执行文件,然后便可以用 gdb 去调试这个程序了,进入调试程序命令,但是如果用 gdb 去调试一个未包含调试信息的可执行文件则会发生错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb 执行文件名(含调试信息)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#运行 GDB&lt;/p&gt;

&lt;p&gt;##运行 gdb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gdb &amp;lt;program&amp;gt; -- program也就是你的执行文件,一般在当然目录下.
gdb &amp;lt;program&amp;gt; core -- 用 gdb 同时调试一个运行程序和 core 文件,core 是程序非法执行后 core dump 后产生的文件.
gdb &amp;lt;program&amp;gt; &amp;lt;PID&amp;gt; -- 调试正在运行的程序. program 为需要调试的程序文件, PID 为当前正在运行的程序.或是先用 gdb &amp;lt;program&amp;gt; 关联上源代码进入 gdb,后用 attach 命令来挂接进程的 PID.并用 detach 来取消挂接的进程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 启动常用的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从指定文件中读取符号表
    -symbols &amp;lt;file&amp;gt;
    -s &amp;lt;file&amp;gt;
从指定文件中读取符号表信息,并把他用在可执行文件中
    -se file
调试时 core dump 的 core 文件
    -core &amp;lt;file&amp;gt;
    -c &amp;lt;file&amp;gt;
加入一个源文件的搜索路径.默认搜索路径是环境变量中 PATH 所定义的路径
    -directory &amp;lt;directory&amp;gt;
    -d &amp;lt;directory&amp;gt;
设置启动时候参数
    --args arglist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 帮助文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help -- 查看 gdb 的命令种类
help &amp;lt;CmdType&amp;gt; -- 查看 CmdType 种类的 gdb 命令
apropos &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 的相关命令
info &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord 调试信息
show &amp;lt;keyWord&amp;gt; -- 查看关键字 keyWord gdb 本身设置信息
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##gdb 中运行 unix 的 shell 程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shell &amp;lt;command string&amp;gt; -- 调用 unix 的 shell 来执行 &amp;lt;command string&amp;gt;,环境变量 shell 中定义的 unix 的 shell 将会被用来执行 &amp;lt;command string&amp;gt;,如果 shell 没有定义,那就使用 unix 的标准 shell：/bin/sh.(在 windows 中使用 command.com 或 cmd.exe)
make &amp;lt;make-args&amp;gt; -- 等价于 “shell make &amp;lt;make-args&amp;gt;”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##历史记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;当你用 gdb 的 print 查看程序运行时的数据时,你每一个 print 都会被 gdb 记录下来.gdb 会以 $1, $2, $3 ...这样的方式为你每一个 print 命令编上号.于是,你可以使用这个编号访问以前的表达式,如 $1.这个功能所带来的好处是,如果你先前输入了一个比较长的表达式,如果你还想查看这个表达式的值,你可以使用历史记录来访问,省去了重复输入.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##启动程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run &amp;lt;arg ...&amp;gt; -- 启动程序,&amp;lt;arg ...&amp;gt; 为程序运行时候需要输入的参数.也可用 set args 命令去设置运行参数.简写为 r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 环境设置&lt;/p&gt;

&lt;p&gt;##gdb 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置显示选项
    地址
        set print address &amp;lt;on/off&amp;gt; -- 打开地址输出,当程序显示函数信息时,gdb会显出函数的参数地址.系统默认为打开.
        show print address -- 查看 print address 选项信息
    数组元素单独行显示
        set print array &amp;lt;on/off&amp;gt; -- 打开时数组显示时,每个元素占一行,如果不打开的话,每个元素则以逗号分隔.这个选项默认是关闭的.
        show print array -- 查看 print array 选项信息
    显示数组元素显示
        set print elements &amp;lt;number-of-elements&amp;gt; -- 设置数组的显示的最大长度,设置为 0,则表示不限制.
        show print elements -- 查看 print elements 选项信息.
    设置字符串显示
        set print null-stop &amp;lt;on/off&amp;gt; -- 如果打开那么当显示字符串时,遇到结束符则停止显示.这个选项默认为 off.
        show print null-stop -- 查看 print null-stop 选项信息
    设置结构体变量显示
        set print pretty &amp;lt;on/off&amp;gt; -- 结构体优雅显示
        show print pretty -- 查看 gdb 是如何显示结构体的.
    设置字符显示
        set print sevenbit-strings &amp;lt;on/off&amp;gt; -- 符显示,是否按“/nnn”的格式显示,如果打开,则字符串或字符数据按/nnn显示,如“/065”.
        show print sevenbit-strings -- 查看字符显示开关是否打开.
    设置联合体显示
        set print union &amp;lt;on/off&amp;gt; -- 设置显示结构体时,是否显式其内的联合体数据.
        show print union -- 查看联合体数据的显示方式
    设置对象显示
        set print object &amp;lt;on/off&amp;gt; -- 在 C++ 中,如果一个对象指针指向其派生类,如果打开这个选项,gdb 会自动按照虚方法调用的规则显示输出,如果关闭这个选项的话,gdb 就不管虚函数表了.这个选项默认是 off.
        show print object -- 查看对象选项的设置.
    设置静态成员显示
        set print static-members &amp;lt;on/off&amp;gt; -- 这个选项表示,当显示一个 C++ 对象中的内容是,是否显示其中的静态数据成员.默认是 on.
        show print static-members -- 查看静态数据成员选项设置.
    设置虚函数表显示
        set print vtbl &amp;lt;on/off&amp;gt; -- 当此选项打开时,gdb 将用比较规整的格式来显示虚函数表时.其默认是关闭的.
        show print vtbl -- 查看虚函数显示格式的选项.
设置运行程序的相关环境及其参数
    指定源文件的路径
        directory &amp;lt;dirname ... &amp;gt; -- 加一个源文件路径到当前路径的前面.如果你要指定多个路径,UNIX 下你可以使用“:”,Windows 下你可以使用“;”.缩写 dir
        directory -- 清除所有的自定义的源文件搜索路径信息.
        show directories -- 显示定义了的源文件搜索路径.
    运行参数
        set args -- 可指定运行时参数
        show args -- 命令可以查看设置好的运行参数
    运行环境
        path &amp;lt;dir&amp;gt; -- 可设定程序的运行路径
        show paths -- 查看程序的运行路径
        set environment varname=value -- 设置环境变量
        show environment [varname] -- 查看环境变量
    工作目录
        cd &amp;lt;dir&amp;gt; -- 相当于shell的cd命令
        pwd -- 显示当前的所在目录
    程序的输入输出
        info terminal -- 显示你程序用到的终端的模式
        tty -- 命令可以指写输入输出的终端设备
        重定向控制程序输出
    堆栈帧设置
        set backtrace &amp;lt;limit&amp;gt; -- 设置堆栈帧的最大显示数量,默认是没有限制
    调试模式
        set step-mode [on | off] -- step-mode 模式,于是,在进行单步跟踪时,程序不会因为没有debug信息而不停住.这个参数有很利于查看机器码. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 源码查看&lt;/p&gt;

&lt;p&gt;##显示源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list &amp;lt;linenum&amp;gt; -- 显示程序第 linenum 行的周围的源程序.
list &amp;lt;function&amp;gt; -- 显示函数名为 function 的函数的源程序.
list &amp;lt;filename:linenum&amp;gt; -- 哪个文件的哪一行.
list &amp;lt;filename:function&amp;gt; -- 哪个文件中的哪个函数.
list &amp;lt;offset&amp;gt; -- 当前行号的正/负 offset 偏移量那那行.
list -- 显示当前行后面的源程序.
list - -- 显示当前行前面的源程序.
list &amp;lt;first&amp;gt;, &amp;lt;last&amp;gt; -- 显示从 first 行到 last 行之间的源代码.若无 first 则显示从当前行到 last 之间的源代码.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##设置和获得显示源码的行数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set listsize &amp;lt;count&amp;gt; -- 设置一次显示源代码的行数.
show listsize -- 查看当前listsize的设置.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##搜索源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forward-search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
search &amp;lt;regexp&amp;gt; -- 向后面搜索.正则表达式为 regexp 的关键字
reverse-search &amp;lt;regexp&amp;gt; -- 向前面搜索.正则表达式为 regexp 的关键字
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##源代码的内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info line &amp;lt;linenum&amp;gt; -- 查看行号为 linenum 源代码在内存中的地址.
info line &amp;lt;function&amp;gt; -- 查看函数在源代码在内存中的地址.
info line &amp;lt;filename:linenum&amp;gt; -- 查看 filename 文件的第 linenum 行源代码在内存中的地址.
info line &amp;lt;filename:function&amp;gt; -- 查看 filename 文件的 function 函数在源代码在内存中的地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看汇编代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;disassemble -- 查看源程序的当前执行时的机器码,这个命令会把目前内存中的指令 dump 出来.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 停止点设置及维护&lt;/p&gt;

&lt;p&gt;##断点(BreakPoint)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置断点:(threadno 指定了线程的 ID,注意,这个 ID 是 gdb 分配的,可以通过 &amp;quot;info threads&amp;quot; 命令来查看正在运行程序中的线程信息)
    break thread &amp;lt;threadno&amp;gt; -- break命令没有参数时,表示在下一条指令处停住.
    break +offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的后面的 offset 行停住.(offiset 为自然数)
    break -offset thread &amp;lt;threadno&amp;gt; -- 在当前行号的前面的 offset 行停住.(offiset 为自然数)
    break &amp;lt;linenum&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在指定行号停住.
    break filename:linenum thread &amp;lt;threadno&amp;gt; -- 在源文件filename的linenum行处停住.
    break &amp;lt;function&amp;gt; thread &amp;lt;threadno&amp;gt; -- 在进入指定函数时停住.
    break filename:function thread &amp;lt;threadno&amp;gt; --在源文件filename的function函数的入口处停住.
    break *address -- 在程序运行的内存地址处停住.
    break ... thread &amp;lt;threadno&amp;gt; if &amp;lt;condition&amp;gt; -- ...可以是上述的参数,condition表示条件,在条件成立时停住.比如在循环境体中,可以设置break if i=100,表示当i为100时停住程序.
    tbreak -- 设置只停止一次的断点.用法和 break 类似
查看断点
    info breakpoints [n]
    info break [n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##观察点(WatchPoint) &amp;ndash; 观察点一般来观察某个表达式(变量也是一种表达式)的值是否有变化了,如果有变化,马上停住程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设在观察点
    watch &amp;lt;expr&amp;gt; -- 为表达式(变量)expr设置一个观察点.一量表达式值有变化时,马上停住程序.
    rwatch &amp;lt;expr&amp;gt; -- 当表达式(变量)expr被读时,停住程序.
    awatch &amp;lt;expr&amp;gt; -- 当表达式(变量)的值被读或被写时,停住程序.
查看观察点
    info watchpoints -- 列出当前所设置了的所有观察点.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##捕捉点(CatchPoint) &amp;ndash; 设置捕捉点来补捉程序运行时的一些事件.如:载入共享库(动态链接库)或是 C++ 的异常《/p&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置捕捉点
    catch &amp;lt;event&amp;gt; -- 当event发生时,停住程序.event可以是下面的内容：
        throw 一个 C++ 抛出的异常.(throw 为关键字)
        catch 一个 C++ 捕捉到的异常.(catch 为关键字)
        exec 调用系统调用 exec 时.(exec 为关键字,目前此功能只在 HP-UX 下有用)
        fork 调用系统调用 fork 时.(fork 为关键字,目前此功能只在 HP-UX 下有用)
        vfork 调用系统调用 vfork 时.(vfork 为关键字,目前此功能只在 HP-UX 下有用)
        load 或 load &amp;lt;libname&amp;gt; 载入共享库(动态链接库)时.(load 为关键字,目前此功能只在 HP-UX 下有用)
        unload 或 unload &amp;lt;libname&amp;gt; 卸载共享库(动态链接库)时.(unload 为关键字,目前此功能只在 HP-UX 下有用)
    tcatch &amp;lt;event&amp;gt; -- 只设置一次捕捉点,当程序停住以后,应点被自动删除.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##维护停止点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;清除停止点
    clear -- 所有的已定义的停止点.
    clear &amp;lt;function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;filename:function&amp;gt; -- 清除所有设置在函数上的停止点.
    clear &amp;lt;linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
    clear &amp;lt;filename:linenum&amp;gt; -- 清除所有设置在指定行上的停止点.
删除停止点
    delete [range] -- 删除停止点.其简写命令为 d.
禁用停止点
    disable [range] -- 禁用停止点
启用停止点
    enable [range] -- 启用停止点.
    enable once [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable count [rang] -- 启用停止点 count 次,当程序停止后,该停止点马上被 gdb 自动 disable.
    enable delete [rang] -- 启用停止点一次,当程序停止后,该停止点马上被 gdb 自动删除.
停止条件维护 -- 以用 condition 命令来修改断点的条件.(只有break和watch命令支持if,catch目前暂不支持if)
    condition &amp;lt;bnum&amp;gt; &amp;lt;expression&amp;gt; -- 修改断点号为bnum的停止条件为expression.
    condition &amp;lt;bnum&amp;gt; -- 清除断点号为bnum的停止条件.
忽略停止点 N 次
    ignore &amp;lt;bnum&amp;gt; &amp;lt;count&amp;gt; -- 表示忽略断点号为 bnum 的停止条件 count 次.
为停止点设定运行命令
    格式:
    commands [bnum]
           ... command-list ...
           // 为断点号 bnumi写一个命令列表.当程序被该断点停住时,gdb 依次运行命令列表中的命令.
    end
    例如：
    break foo if x&amp;gt;0
    　　commands
           printf &amp;quot;x is %d/n&amp;quot;,x
           continue
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#信号(Signals)&lt;/p&gt;

&lt;p&gt;##添加信号处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle &amp;lt;signal&amp;gt; &amp;lt;keywords...&amp;gt;
在 gdb 中定义一个信号处理.信号 &amp;lt;signal&amp;gt; 可以以 SIG 开头或不以 SIG 开头,可以用定义一个要处理信号的范围(如：SIGIO-SIGKILL,表示处理从 SIGIO 信号到 SIGKILL 的信号,其中包括 SIGIO, SIGIOT, SIGKILL 三个信号),也可以使用关键字 all 来标明要处理所有的信号.一旦被调试的程序接收到信号,运行程序马上会被 gdb 停住,以供调试.其 &amp;lt;keywords&amp;gt; 可以是以下几种关键字的一个或多个.若没有 keywords 则查看奇信号的处理状态
    nostop -- 当被调试的程序收到信号时,gdb 不会停住程序的运行,但会打出消息告诉你收到这种信号.
    stop -- 当被调试的程序收到信号时,gdb 会停住你的程序.
    print -- 当被调试的程序收到信号时,gdb 会显示出一条信息.
    noprint -- 当被调试的程序收到信号时,gdb 不会告诉你收到信号的信息.
    pass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    noignore -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    nopass -- 当被调试的程序收到信号时,gdb 不处理信号.这表示,gdb 会把这个信号交给被调试程序会处理.
    1gnore -- 当被调试的程序收到信号时,gdb 不会让被调试程序来处理这个信号.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看处理信号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info signals -- 查看有哪些信号在被 gdb 检测中.
info handle -- 查看有哪些信号在被 gdb 检测中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 程序调试&lt;/p&gt;

&lt;p&gt;##恢复执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;continue [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
fg [ignore-count] -- ignore-count 表示忽略其后的断点次数.恢复程序运行,直到程序结束,或是下一个断点到来.缩写 c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##单步调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;step &amp;lt;count&amp;gt; -- 单步跟踪,如果有函数调用,它会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
next &amp;lt;count&amp;gt; -- 同样单步跟踪,如果有函数调用,他不会进入该函数.count 表示执行后面 count 条语句,不加则默认为 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跟踪机器指令
       与之一样有相同功能的命令是 “display/i $pc” ,当运行完这个命令后,单步跟踪会在打出程序代码的同时打出机器指令(也就是汇编代码)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stepi 或 si -- 单步跟踪一条机器指令,简写 si
nexti 或 ni -- 单步跟踪一条机器指令,简写 ni
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##函数调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;finish -- 运行程序,直到当前函数完成返回.并打印函数返回时的堆栈地址和返回值及参数值等信息.
return &amp;lt;expression&amp;gt; -- 使函数以 expression 表达式返回出去,忽略还没有执行的语句.若无返回 void 出去
call &amp;lt;expr&amp;gt; -- 表达式中可以一是函数,以此达到强制调用函数的目的.并显示函数的返回值,如果函数返回值是void,那么就不显示.
print 与 printf 也可以做到类似的功能和 call 的不同是,如果函数返回 void,call 则不显示,print 则显示函数返回值,并把该值存入历史数据中.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##循环体调试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until -- 可以运行程序直到退出循环体.简写 u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##修改变量值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print varname=var -- 修改被调试程序运行时的变量值
set var varname=value -- 修改被调试程序运行时的变变量
whatis varname -- 查看变量的类型
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##跳转执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jump &amp;lt;linespec&amp;gt; -- 指定下一条语句的运行点.&amp;lt;linespce&amp;gt; 可以是文件的行号,可以是 file:line 格式,可以是 +num 这种偏移量格式.表式着下一条运行语句从哪里开始.
jump &amp;lt;address&amp;gt; -- 跳转到指定的程序内存地址运行.&amp;lt;address&amp;gt; 是代码行的内存地址.
注意
    jump 指令不会改变当前的程序栈中的内容,所以,当你从一个函数跳到另一个函数时,当函数运行完返回时进行弹栈操作时必然会发生错误.
    jump 命令只是改变了指令寄存器中的值.于是可以使用 “set $pc” 来更改跳转执行的地址.如： set $pc = 0x485
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##产生信号量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;signal &amp;lt;signal&amp;gt; -- 产生一个 signal 信号.UNIX 的系统信号量通常从 1 到 15.所以 &amp;lt;signal&amp;gt; 取值也在这个范围.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#GDB 运行是数据&lt;/p&gt;

&lt;p&gt;##查看运行时数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print /&amp;lt;f&amp;gt; &amp;lt;expr&amp;gt; -- 查看当前程序的运行数据.简写 p.
    &amp;lt;expr&amp;gt; 是表达式
        @ -- 是一个和数组有关的操作符,在后面会有更详细的说明.在 @ 左边是数组的地址,右边是数组的长度,eg: array@len
        :: -- 指定一个在文件或是一个函数中的变量.
        {&amp;lt;type&amp;gt;} &amp;lt;addr&amp;gt; --表示一个指向内存地址&amp;lt;addr&amp;gt;的类型为type的一个对象.
    &amp;lt;f&amp;gt;是输出的格式
        d -- 按十进制格式显示变量.
        u -- 按十六进制格式显示无符号整型.
        o -- 按八进制格式显示变量.
        t -- 按二进制格式显示变量.
        a -- 按十六进制格式显示变量.
        c -- 按字符格式显示变量.
        f -- 按浮点数格式显示变量.
    注意:
        1.若出现变量重名,局部变量会隐藏全局变量.若想查看全局变量的值时,可以使用“::”操作符.
        2.可以通过这种形式指定你所想查看的变量 eg:
            *&#39;filename&#39;::variable
            *function::variable
printf &amp;quot;fmt&amp;quot;,arg,... -- 打印格式化字符灿 fmt.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看内存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;examine/&amp;lt;n/f/u&amp;gt; &amp;lt;addr&amp;gt; -- 来查看内存地址中的值.简写 x
    &amp;lt;n/f/u&amp;gt;
        n 是一个正整数,表示显示内存的长度,也就是说从当前地址向后显示几个地址的内容.
        f 表示显示的格式
            s -- 按字符串格式显示内存地址内容.
            i -- 查看内存地址的机器指令内容
            x -- 按十六进制格式显示地址内容.
            d -- 按十进制格式显示地址内容.
            u -- 按十六进制格式显示无符号整型.
            o -- 按八进制格式显示地址内容.
            t -- 按二进制格式显示地址内容.
            a -- 按十六进制格式显示地址内容.
            c -- 按字符格式显示地址内容.
            f -- 按浮点数格式显示地址内容.
        u 表示从当前地址往后请求的字节数,如果不指定的话,gdb默认是 4 个 bytes.
            b -- 表示单字节
            h -- 表示双字节
            w -- 表示四字节
            g -- 表示八字节
    &amp;lt;addr&amp;gt; 表示一个内存地址.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##自动显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置自动显示
    display/&amp;lt;fmt&amp;gt; &amp;lt;expr&amp;gt; -- 自动显示 expr 表达式
    display/&amp;lt;fmt&amp;gt; &amp;lt;addr&amp;gt; -- 自动显示 addr 地址
        fmt 表示显示的格式
        i -- 输出格式为机器指令码,也就是汇编.
        s -- 输出格式为字符串
删除自动显示
    undisplay &amp;lt;range&amp;gt; -- 删除自动显示
    delete display &amp;lt;range&amp;gt; -- 删除自动显示
启用和禁自动显示
    sable display &amp;lt;range&amp;gt; -- 禁用自动显示
    enable display &amp;lt;range&amp;gt; -- 启动自动显示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看栈信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backtrace &amp;lt;n&amp;gt; -- 擦看函数栈信息,简写 bt
    n 若是正数,只打印栈顶上 n 层的栈信息,
    若是负数,只打印栈顶下 n 层的栈信息,
    若无则打印当前的函数调用栈的所有信息
frame -- 会打印出这些信息:栈的层编号,当前的函数名,函数参数值,函数所在文件及行号,函数执行到的语句.
info frame -- 这个命令会打印出更为详细的当前栈层的信息,只不过,大多数都是运行时的内内地址.
info args -- 打印出当前函数的参数名及其值.
info locals -- 打印出当前函数中所有局部变量及其值.
info catch -- 打印出当前的函数中的异常处理信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##切换函数栈位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;frame &amp;lt;n&amp;gt; -- 切换到第 n 层函数栈位置,简写 f.
p &amp;lt;n&amp;gt; -- 表示上面移动 n 层,可以不打 n,表示向上移动一层.
down &amp;lt;n&amp;gt; -- 表示向栈的下面移动 n 层,可以不打 n,表示向下移动一层.
select-frame &amp;lt;n&amp;gt; -- 类似 frame 命令.不打印出栈层信息.
up-silently &amp;lt;n&amp;gt; -- 类似 up 命令.不打印出栈层信息.
down-silently &amp;lt;n&amp;gt; -- 类似 down 命令.不打印出栈层信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看寄存器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info registers -- 查看寄存器的情况.(除了浮点寄存器)
info all-registers -- 查看所有寄存器的情况.(包括浮点寄存器)
info registers &amp;lt;regname&amp;gt; -- 查看所指定的寄存器的情况.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##线程查看与切换线程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;info threads -- 查看当前线程
thread &amp;lt;threadno&amp;gt; -- 切换到 threadno 的线程,简写 t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;#自定义命令&lt;/p&gt;

&lt;p&gt;##定义一个命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;格式
define comdName
      ...
end
条件语句
if cond_expr
      ...
else
      ...
end
循环语句
while cond_expr
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##定义一个命令的文档信息（在 help cmdName 的时候显示）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document cmdName
      ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##查看自定命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;help user-define -- 查看所有用户自定义的命令
show user cmdName -- 查看用户定义的 cmdName 的命令.
help cmdName -- 查看用户自定义的 cmdName 的帮助文档
show max-user-call-depth -- 查看用户自定义命令的递归最大深度,缺省是 1024
set-user-call-depth &amp;lt;limit&amp;gt;-- 设置用户自定义命令的递归最大深度.
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>gdb多线程调试</title>
      <link>http://sun-friderick.github.io/post/2015-11-31</link>
      <pubDate>Sat, 31 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-11-31</guid>
      <description>&lt;p&gt;gdb对于多线程程序的调试有如下的支持：
　　
　　线程产生通知：在产生新的线程时, gdb会给出提示信息
　　(gdb) r
　　Starting program: /root/thread
　　[New Thread 1073951360 (LWP 12900)]
　　[New Thread 1082342592 (LWP 12907)]&amp;mdash;以下三个为新产生的线程
　　[New Thread 1090731072 (LWP 12908)]
　　[New Thread 1099119552 (LWP 12909)]
　　
　　查看线程：使用info threads可以查看运行的线程。
　　(gdb) info threads
　　 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　* 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb)
　　
　　
　　注意，行首的蓝色文字为gdb分配的线程号，对线程进行切换时，使用该该号码，而不是上文标出的绿色数字。
　　
　　另外，行首的红色星号标识了当前活动的线程
　　
　　切换线程：使用 thread THREADNUMBER 进行切换，THREADNUMBER 为上文提到的线程号。下例显示将活动线程从 1 切换至 4。
　　(gdb) info threads
　　 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　* 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb) thread 4
　　[Switching to thread 4 (Thread 1099119552 (LWP 12940))]#0 0xffffe002 in ?? ()
　　(gdb) info threads
　　* 4 Thread 1099119552 (LWP 12940) 0xffffe002 in ?? ()
　　 3 Thread 1090731072 (LWP 12939) 0xffffe002 in ?? ()
　　 2 Thread 1082342592 (LWP 12938) 0xffffe002 in ?? ()
　　 1 Thread 1073951360 (LWP 12931) main (argc=1, argv=0xbfffda04) at thread.c:21
　　(gdb)
　　
　　
　　 以上即为使用gdb提供的对多线程进行调试的一些基本命令。另外，gdb也提供对线程的断点设置以及对指定或所有线程发布命令的命令。
　　
　　 初次接触gdb下多线程的调试，往往会忽视gdb中活动线程的概念。一般来讲，在使用gdb调试的时候，只有一个线程为活动线程，如果希望得到其他的线程的输出结果，必须使用thread命令切换至指定的线程，才能对该线程进行调试或观察输出结果。&lt;/p&gt;

&lt;p&gt;一直对GDB多线程调试接触不多，最近因为工作有了一些接触，简单作点记录吧。&lt;/p&gt;

&lt;p&gt;先介绍一下GDB多线程调试的基本命令。&lt;/p&gt;

&lt;p&gt;info threads
显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。
前面有*的是当前调试的线程。&lt;/p&gt;

&lt;p&gt;thread ID
切换当前调试的线程为指定ID的线程。&lt;/p&gt;

&lt;p&gt;break thread_test.c:123 thread all
在所有线程中相应的行上设置断点&lt;/p&gt;

&lt;p&gt;thread apply ID1 ID2 command
让一个或者多个线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;thread apply all command
让所有被调试线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;set scheduler-locking off|on|step
估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。
off 不锁定任何线程，也就是所有线程都执行，这是默认值。
on 只有当前被调试程序会执行。
step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;

&lt;p&gt;在介绍完基本的多线程调试命令后，大概介绍一下GDB多线程调试的实现思路。&lt;/p&gt;

&lt;p&gt;比较主要的代码是thread.c，前面介绍的几个命令等都是在其中实现。
thread_list这个表存储了当前可调试的所有线程的信息。
函数add_thread_silent或者add_thread(不同版本GDB不同)用来向thread_list列表增加一个线程的信息。
函数delete_thread用来向thread_list列表删除一个线程的信息。
上面提到的这2个函数会被有线程支持的target调用，用来增加和删除线程，不同的OS对线程的实现差异很大，这么实现比较好的保证了GDB多线程调试支持的扩展性。
函数info_threads_command是被命令info threads调用的，就是显示thread_list列表的信息。
函数thread_command是被命令thread调用，切换当前线程最终调用的函数是switch_to_thread，这个函数会先将当前调试线程变量inferior_ptid，然后对寄存器和frame缓冲进行刷新。
函数thread_apply_command被命令thread apply调用，这个函数的实际实现其实很简单，就是先切换当前线为指定线程，然后调用函数execute_command调用指定函数。&lt;/p&gt;

&lt;p&gt;比较特别的是set scheduler-locking没有实现在thread.c中，而是实现在控制被调试程序执行的文件infrun.c中。
对其的设置会保存到变量scheduler_mode中，而实际使用这个变量的函数只有用来令被调试程序执行的函数resume。在默认情况下， 传递给target_resume的变量是resume_ptid，默认情况下其的值为RESUME_ALL，也就是告诉target程序执行的时候所有 被调试线程都要被执行。而当scheduler_mode设置为只让当前线程执行的时候，resume_ptid将被设置为inferior_ptid， 这就告诉target只有inferior_ptid的线程会被执行。&lt;/p&gt;

&lt;p&gt;最后特别介绍一下Linux下多线程的支持，基本的调试功能在linux-nat.c中，这里有对Linux轻量级别进程本地调试的支持。但是其 在调试多线程程序的时候，还需要对pthread调试的支持，这个功能实现在linux-thread-db.c中。对pthread的调试要通过调用 libthread_db库来支持。
这里有一个单独的target&amp;rdquo;multi-thread&amp;rdquo;，这个target有2点很特别:
第一，一般target的装载是在调用相关to_open函数的时候调用push_target进行装载。而这个target则不同，在其初始化 的时候，就注册了函数thread_db_new_objfile到库文件attach事件中。这样当GDB为调试程序的动态加载库时候attach库文 件的时候，就会调用这个函数thread_db_new_objfile。这样当GDB装载libpthread库的时候，最终会装载 target&amp;rdquo;multi-thread&amp;rdquo;。
第二，这个target并没有像大部分target那样自己实现了全部调试功能，其配合linux-nat.c的代码的功能，这里有一个target多层结构的设计，要介绍的比较多，就不详细介绍了。&lt;/p&gt;

&lt;p&gt;最后介绍一下我最近遇见的一个多线程调试和解决。&lt;/p&gt;

&lt;p&gt;基本问题是在一个Linux环境中，调试多线程程序不正常，info threads看不到多线程的信息。
我先用命令maintenance print target-stack看了一下target的装载情况，发现target&amp;rdquo;multi-thread&amp;rdquo;没有被装载，用GDB对GDB进行调试，发现在 函数check_for_thread_db在调用libthread_db中的函数td_ta_new的时候，返回了TD_NOLIBTHREAD，所 以没有装载target&amp;rdquo;multi-thread&amp;rdquo;。
在时候我就怀疑是不是libpthread有问题，于是检查了一下发现了问题，这个环境中的libpthread是被strip过的，我想可能 就是以为这个影响了td_ta_new对libpthread符号信息的获取。当我换了一个没有strip过的libpthread的时候，问题果然解决 了。
最终我的解决办法是拷贝了一个.debug版本的libpthread到lib目录中，问题解决了。
多线程如果dump，多为段错误，一般都涉及内存非法读写。可以这样处理，使用下面的命令打开系统开关，让其可以在死掉的时候生成core文件。&lt;br /&gt;
ulimit -c unlimited
这样的话死掉的时候就可以在当前目录看到core.pid(pid为进程号)的文件。接着使用gdb:
gdb ./bin ./core.pid
进去后，使用bt查看死掉时栈的情况，在使用frame命令。&lt;/p&gt;

&lt;p&gt;还有就是里面某个线程停住，也没死，这种情况一般就是死锁或者涉及消息接受的超时问题(听人说的，没有遇到过)。遇到这种情况，可以使用：
gcore pid （调试进程的pid号）
手动生成core文件，在使用pstack(linux下好像不好使)查看堆栈的情况。如果都看不出来，就仔细查看代码，看看是不是在if，return，break，continue这种语句操作是忘记解锁，还有嵌套锁的问题，都需要分析清楚了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试命令的使用及总结</title>
      <link>http://sun-friderick.github.io/post/2015-01-31</link>
      <pubDate>Sat, 31 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-01-31</guid>
      <description>

&lt;p&gt;#gdb调试命令的使用及总结
1.基本命令&lt;/p&gt;

&lt;p&gt;1）进入GDB　　#gdb test&lt;/p&gt;

&lt;p&gt;　　test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb) 。&lt;/p&gt;

&lt;p&gt;2）查看源码　　(gdb) l&lt;/p&gt;

&lt;p&gt;　　源码会进行行号提示。&lt;/p&gt;

&lt;p&gt;　　如果需要查看在其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。或者：使用断点或单步运行，到某个函数处使用s进入这个函数。&lt;/p&gt;

&lt;p&gt;3）设置断点　　(gdb) b 6&lt;/p&gt;

&lt;p&gt;　　这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。&lt;/p&gt;

&lt;p&gt;4）查看断点处情况　　(gdb) info b&lt;/p&gt;

&lt;p&gt;　　可以键入&amp;rdquo;info b&amp;rdquo;来查看断点处情况，可以设置多个断点；&lt;/p&gt;

&lt;p&gt;5）运行代码　　(gdb) r&lt;/p&gt;

&lt;p&gt;6）显示变量值　　(gdb) p n&lt;/p&gt;

&lt;p&gt;　　在程序暂停时，键入&amp;rdquo;p 变量名&amp;rdquo;(print)即可；&lt;/p&gt;

&lt;p&gt;　　GDB在显示变量值时都会在对应值之前加上&amp;rdquo;$N&amp;rdquo;标记，它是当前变量值的引用标记，以后若想再次引用此变量，就可以直接写作&amp;rdquo;$N&amp;rdquo;，而无需写冗长的变量名；&lt;/p&gt;

&lt;p&gt;7）观察变量　　(gdb) watch n&lt;/p&gt;

&lt;p&gt;在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令&amp;rdquo;watch&amp;rdquo;来观察变量的变化情况，GDB在&amp;rdquo;n&amp;rdquo;设置了观察点；&lt;/p&gt;

&lt;p&gt;8）单步运行　　(gdb) n&lt;/p&gt;

&lt;p&gt;9）程序继续运行　　(gdb) c&lt;/p&gt;

&lt;p&gt;　　使程序继续往下运行，直到再次遇到断点或程序结束；&lt;/p&gt;

&lt;p&gt;10）退出GDB　　(gdb) q&lt;/p&gt;

&lt;p&gt;2.断点调试&lt;/p&gt;

&lt;p&gt;命令格式　　                      例子             　　　　　　作用&lt;/p&gt;

&lt;p&gt;break + 设置断点的行号　　break n　　　　　　在n行处设置断点&lt;/p&gt;

&lt;p&gt;tbreak + 行号或函数名　　tbreak n/func　　　　设置临时断点，到达后被自动删除&lt;/p&gt;

&lt;p&gt;break + filename + 行号　　break main.c:10　　用于在指定文件对应行设置断点&lt;/p&gt;

&lt;p&gt;break + &lt;0x...&gt;　　break 0x3400a　　　　　　用于在内存某一位置处暂停&lt;/p&gt;

&lt;p&gt;break + 行号 + if + 条件　　break 10 if i==3　　　用于设置条件断点，在循环中使用非常方便&lt;/p&gt;

&lt;p&gt;info breakpoints/watchpoints [n]　　info break　　n表示断点号，查看断点/观察点的情况&lt;/p&gt;

&lt;p&gt;clear + 要清除的断点行号　　clear 10　　　　用于清除对应行的断点，要给出断点的行号，清除时GDB会给出提示&lt;/p&gt;

&lt;p&gt;delete + 要清除的断点编号　　delete 3　　　　用于清除断点和自动显示的表达式的命令，要给出断点的编号，清除时GDB不会给出任何提示&lt;/p&gt;

&lt;p&gt;disable/enable + 断点编号　　disable 3　　　　让所设断点暂时失效/使能，如果要让多个编号处的断点失效/使能，可将编号之间用空格隔开&lt;/p&gt;

&lt;p&gt;awatch/watch + 变量　　awatch/watch i　　　　设置一个观察点，当变量被读出或写入时程序被暂停&lt;/p&gt;

&lt;p&gt;rwatch + 变量　　　　　　rwatch i　　　　　　　　设置一个观察点，当变量被读出时，程序被暂停&lt;/p&gt;

&lt;p&gt;catch　　　　　　　　　　　　　　　　　　设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常&lt;/p&gt;

&lt;p&gt;tcatch　　　　　　　　　　　　　　　　　　只设置一次捕捉点，当程序停住以后，应点被自动删除&lt;/p&gt;

&lt;p&gt;3.数据命令&lt;/p&gt;

&lt;p&gt;display +表达式　　display a　　用于显示表达式的值，每当程序运行到断点处都会显示表达式的值&lt;/p&gt;

&lt;p&gt;info display　　　　　　用于显示当前所有要显示值的表达式的情况&lt;/p&gt;

&lt;p&gt;delete + display 编号　　delete 3　　用于删除一个要显示值的表达式，被删除的表达式将不被显示&lt;/p&gt;

&lt;p&gt;disable/enable + display 编号　　disable/enable 3　　使一个要显示值的表达式暂时失效/使能&lt;/p&gt;

&lt;p&gt;undisplay + display 编号　　undisplay 3　　用于结束某个表达式值的显示&lt;/p&gt;

&lt;p&gt;whatis + 变量　　whatis i　　显示某个表达式的数据类型&lt;/p&gt;

&lt;p&gt;print(p) + 变量/表达式　　p n　　用于打印变量或表达式的值&lt;/p&gt;

&lt;p&gt;set + 变量 = 变量值　　set i = 3　　改变程序中某个变量的值&lt;/p&gt;

&lt;p&gt;　　在使用print命令时，可以对变量按指定格式进行输出，其命令格式为print /变量名 + 格式&lt;/p&gt;

&lt;p&gt;　　其中常用的变量格式：x：十六进制；d：十进制；u：无符号数；o：八进制；c：字符格式；f：浮点数。&lt;/p&gt;

&lt;p&gt;4.调试运行环境相关命令&lt;/p&gt;

&lt;p&gt;set args　　set args arg1 arg2　　设置运行参数&lt;/p&gt;

&lt;p&gt;show args　　show args　　参看运行参数&lt;/p&gt;

&lt;p&gt;set width + 数目　　set width 70　　设置GDB的行宽&lt;/p&gt;

&lt;p&gt;cd + 工作目录　　cd ../　　切换工作目录&lt;/p&gt;

&lt;p&gt;run　　r/run　　程序开始执行&lt;/p&gt;

&lt;p&gt;step(s)　　s　　进入式（会进入到所调用的子函数中）单步执行，进入函数的前提是，此函数被编译有debug信息&lt;/p&gt;

&lt;p&gt;next(n)　　n　　非进入式（不会进入到所调用的子函数中）单步执行&lt;/p&gt;

&lt;p&gt;finish　　finish　　一直运行到函数返回并打印函数返回时的堆栈地址和返回值及参数值等信息&lt;/p&gt;

&lt;p&gt;until + 行数　　u 3　　运行到函数某一行&lt;/p&gt;

&lt;p&gt;continue&amp;copy;　　c　　执行到下一个断点或程序结束&lt;/p&gt;

&lt;p&gt;return &amp;lt;返回值&amp;gt;　　return 5　　改变程序流程，直接结束当前函数，并将指定值返回&lt;/p&gt;

&lt;p&gt;call + 函数　　call func　　在当前位置执行所要运行的函数&lt;/p&gt;

&lt;p&gt;5.堆栈相关命令&lt;/p&gt;

&lt;p&gt;backtrace/bt　　bt　　用来打印栈帧指针，也可以在该命令后加上要打印的栈帧指针的个数，查看程序执行到此时，是经过哪些函数呼叫的程序，程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）。每个函数及其变量都被分配了一个“帧”，最近调用的函数在 0 号帧中（“底部”帧）&lt;/p&gt;

&lt;p&gt;frame　　frame 1　　用于打印指定栈帧&lt;/p&gt;

&lt;p&gt;info reg　　info reg　　查看寄存器使用情况&lt;/p&gt;

&lt;p&gt;info stack　　info stack　　查看堆栈使用情况&lt;/p&gt;

&lt;p&gt;up/down　　up/down　　跳到上一层/下一层函数&lt;/p&gt;

&lt;p&gt;6.跳转执行&lt;/p&gt;

&lt;p&gt;jump  指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。&lt;/p&gt;

&lt;p&gt;7.信号命令&lt;/p&gt;

&lt;p&gt;signal 　　signal SIGXXX 　　产生XXX信号，如SIGINT。一种速查Linux查询信号的方法：# kill -l&lt;/p&gt;

&lt;p&gt;handle 　　在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几种关键字的一个或多个：
　　nostop/stop
　　　　当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号/GDB会停住你的程序&lt;br /&gt;
　　print/noprint
　　　　当被调试的程序收到信号时，GDB会显示出一条信息/GDB不会告诉你收到信号的信息
　　pass
　　noignore
　　　　当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。
　　nopass
　　ignore
　　　　当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
　　info signals
　　info handle
　　　　可以查看哪些信号被GDB处理，并且可以看到缺省的处理方式&lt;/p&gt;

&lt;p&gt;　　single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。&lt;/p&gt;

&lt;p&gt;8.运行Shell命令&lt;/p&gt;

&lt;p&gt;　　如(gdb)shell ls来运行ls。　　&lt;/p&gt;

&lt;p&gt;9.更多程序运行选项和调试&lt;/p&gt;

&lt;p&gt;1、程序运行参数。
　　set args 可指定运行时参数。（如：set args 10 20 30 40 50）
　　show args 命令可以查看设置好的运行参数。
2、运行环境。
　　path 可设定程序的运行路径。
　　show paths 查看程序的运行路径。&lt;/p&gt;

&lt;p&gt;　　set environment varname [=value] 设置环境变量。如：set env USER=hchen&lt;/p&gt;

&lt;p&gt;　　show environment [varname] 查看环境变量。&lt;/p&gt;

&lt;p&gt;3、工作目录。&lt;/p&gt;

&lt;p&gt;　　cd　　  相当于shell的cd命令。&lt;/p&gt;

&lt;p&gt;　　pwd　　显示当前的所在目录。
4、程序的输入输出。
　　info terminal 显示你程序用到的终端的模式。
　　使用重定向控制程序输出。如：run &amp;gt; outfile
　　tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb&lt;/p&gt;

&lt;p&gt;5、调试已运行的程序&lt;/p&gt;

&lt;p&gt;两种方法：
　　(1)在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在运行的程序。
　　(2)先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。&lt;/p&gt;

&lt;p&gt;6、暂停 / 恢复程序运行　　当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops），如果要恢复程序运行，可以使用c或是continue命令。&lt;/p&gt;

&lt;p&gt;7、线程（Thread Stops）&lt;/p&gt;

&lt;p&gt;如果程序是多线程，可以定义断点是否在所有的线程上，或是在某个特定的线程。
　　break thread
　　break thread if &amp;hellip;
　　linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread 则表示断点设在所有线程上面。还可以为某线程指定断点条件。如：
　　(gdb) break frik.c:13 thread 28 if bartab &amp;gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。&lt;/p&gt;

&lt;p&gt;10.调试core文件&lt;/p&gt;

&lt;p&gt;Core Dump：Core的意思是内存，Dump的意思是扔出来，堆出来。开发和使用Unix程序时，有时程序莫名其妙的down了，却没有任何的提示(有时候会提示core dumped)，这时候可以查看一下有没有形如core.进程号的文件生成，这个文件便是操作系统把程序down掉时的内存内容扔出来生成的, 它可以做为调试程序的参考&lt;/p&gt;

&lt;p&gt;(1)生成Core文件
　　一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。修改后才能生成core文件。&lt;/p&gt;

&lt;p&gt;　　#设置core大小为无限
　　ulimit -c unlimited
　　#设置文件大小为无限
　　ulimit unlimited&lt;/p&gt;

&lt;p&gt;　　这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限&lt;/p&gt;

&lt;p&gt;core文件生成路径:输入可执行文件运行命令的同一路径下。若系统生成的core文件不带其他任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。&lt;/p&gt;

&lt;p&gt;1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。
可通过以下命令修改此文件：
echo &amp;ldquo;1&amp;rdquo; &amp;gt; /proc/sys/kernel/core_uses_pid&lt;/p&gt;

&lt;p&gt;2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。
可通过以下命令修改此文件：
echo &amp;ldquo;/corefile/core-%e-%p-%t&amp;rdquo; &amp;gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳
以下是参数列表:
    %p - insert pid into filename 添加pid
    %u - insert current uid into filename 添加当前uid
    %g - insert current gid into filename 添加当前gid
    %s - insert signal that caused the coredump into the filename 添加导致产生core的信号
    %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间
    %h - insert hostname where the coredump happened into filename 添加主机名
    %e - insert coredumping executable name into filename 添加命令名&lt;/p&gt;

&lt;p&gt;(2)用gdb查看core文件&lt;/p&gt;

&lt;p&gt;　　发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.
　　gdb [exec file] [core file]
　　如:
　　gdb ./test core&lt;/p&gt;

&lt;p&gt;　　或gdb ./a.out
 　　core-file core.xxxx
　　gdb后, 用bt命令backtrace或where查看程序运行到哪里, 来定位core dump的文件-&amp;gt;行.&lt;/p&gt;

&lt;p&gt;　　待调试的可执行文件，在编译的时候需要加-g，core文件才能正常显示出错信息&lt;/p&gt;

&lt;p&gt;　　1）gdb -core=core.xxxx
　　file ./a.out
　　bt
　　2）gdb -c core.xxxx
　　file ./a.out
　　bt&lt;/p&gt;

&lt;p&gt;(3)用gdb实时观察某进程crash信息&lt;/p&gt;

&lt;p&gt;　　启动进程
　　gdb -p PID
　　c
　　运行进程至crash
　　gdb会显示crash信息
　　bt&lt;/p&gt;

&lt;p&gt;#gdb调试命令说明&lt;/p&gt;

&lt;h1 id=&#34;1-对于在应用程序中加入参数进行调试的方法:a705e2985626516966a98e6f6a34e407&#34;&gt;1: 对于在应用程序中加入参数进行调试的方法：&lt;/h1&gt;

&lt;p&gt;直接用 gdb app -p1 -p2 这样进行调试是不行的。
   需要像以下这样使用：
    #gdb app
    (gdb) r -p1 -p2
    或者在运行run命令前使用set args命令：
    （gdb） set args p1 p2
    可以用show args 命令来查看&lt;/p&gt;

&lt;h1 id=&#34;2-加入断点:a705e2985626516966a98e6f6a34e407&#34;&gt;2. 加入断点：&lt;/h1&gt;

&lt;p&gt;break &lt;linenumber&gt;
   break &lt;funcName&gt;
   break +offset
   break -offset
   (在当前行号的前面或后面的offset行停住。)&lt;/p&gt;

&lt;p&gt;break filename:linenum
   在源文件filename的linenum行处停住。&lt;/p&gt;

&lt;p&gt;break filename:function
   在源文件filename的function函数的入口处停住。&lt;/p&gt;

&lt;p&gt;break &amp;hellip; if
  &amp;hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设置     break if i=100，表示当i为100时停住程序。&lt;/p&gt;

&lt;h1 id=&#34;3-查看运行时的堆栈:a705e2985626516966a98e6f6a34e407&#34;&gt;3. 查看运行时的堆栈：&lt;/h1&gt;

&lt;p&gt;使用bt命令&lt;/p&gt;

&lt;h1 id=&#34;4-打印某个变量的值:a705e2985626516966a98e6f6a34e407&#34;&gt;4. 打印某个变量的值：&lt;/h1&gt;

&lt;p&gt;print val&lt;/p&gt;

&lt;h1 id=&#34;5-单步-n:a705e2985626516966a98e6f6a34e407&#34;&gt;5. 单步： n&lt;/h1&gt;

&lt;p&gt;继续运行：　c
　　step
　　单步跟踪，如果有函数调用，他会进入该函数。
　　next
　　同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。
　　set step-mode
　　set step-mode on
　　打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。
　　set step-mod off
　　关闭step-mode模式。
　　finish
　　运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
　　until 或 u
　　当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。&lt;/p&gt;

&lt;h1 id=&#34;6-在gdb中执行shell命令:a705e2985626516966a98e6f6a34e407&#34;&gt;6.在gdb中执行shell命令：&lt;/h1&gt;

&lt;p&gt;　在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
　eg. shell make&lt;/p&gt;

&lt;h1 id=&#34;7-运行环境:a705e2985626516966a98e6f6a34e407&#34;&gt;7. 运行环境&lt;/h1&gt;

&lt;p&gt;可设定程序的运行路径。
  show paths 查看程序的运行路径。
  set environment varname [=value] 设置环境变量。如：set env USER=hchen
  show environment [varname] 查看环境变量。&lt;/p&gt;

&lt;h1 id=&#34;8-观察点-watchpoint:a705e2985626516966a98e6f6a34e407&#34;&gt;8.观察点（WatchPoint）&lt;/h1&gt;

&lt;p&gt;观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程 序。我们有下面的几种方法来设置观察点：
  watch
   为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
  rwatch
   当表达式（变量）expr被读时，停住程序。
  awatch
   当表达式（变量）的值被读或被写时，停住程序。
  info watchpoints
   列出当前所设置了的所有观察点。&lt;/p&gt;

&lt;h1 id=&#34;9-维护breakpoint:a705e2985626516966a98e6f6a34e407&#34;&gt;9. 维护breakpoint&lt;/h1&gt;

&lt;p&gt;clear
    清除所有的已定义的停止点。
   clear func
    清除所有设置在函数上的停止点。
  delete [breakpoints] [range&amp;hellip;]
  删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。
  比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。
  disable [breakpoints] [range&amp;hellip;]
   disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止 点。简写命令是dis.
  enable [breakpoints] [range&amp;hellip;]
   enable所指定的停止点，breakpoints为停止点号。&lt;/p&gt;

&lt;h1 id=&#34;10-程序变量:a705e2985626516966a98e6f6a34e407&#34;&gt;10、程序变量&lt;/h1&gt;

&lt;p&gt;查看文件中某变量的值：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
gdb) p &amp;lsquo;f2.c&amp;rsquo;::x&lt;/p&gt;

&lt;p&gt;查看数组的值
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。&lt;/p&gt;

&lt;h1 id=&#34;10-1-输出格式:a705e2985626516966a98e6f6a34e407&#34;&gt;10-1.输出格式&lt;/h1&gt;

&lt;p&gt;一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：&lt;/p&gt;

&lt;p&gt;x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &amp;lsquo;e&amp;rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101&lt;/p&gt;

&lt;h1 id=&#34;11-查看内存:a705e2985626516966a98e6f6a34e407&#34;&gt;11.查看内存&lt;/h1&gt;

&lt;p&gt;使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。
u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。&lt;/p&gt;

&lt;p&gt;n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。&lt;/p&gt;

&lt;h1 id=&#34;12-自动显示:a705e2985626516966a98e6f6a34e407&#34;&gt;12.自动显示&lt;/h1&gt;

&lt;p&gt;你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。
display
display/
display/ expr
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。&lt;/p&gt;

&lt;p&gt;格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc&lt;/p&gt;

&lt;p&gt;undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。&lt;/p&gt;

&lt;p&gt;disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。&lt;/p&gt;

&lt;p&gt;info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。&lt;/p&gt;

&lt;h1 id=&#34;13-设置显示选项:a705e2985626516966a98e6f6a34e407&#34;&gt;13. 设置显示选项&lt;/h1&gt;

&lt;p&gt;set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
show print address
查看当前地址显示选项是否打开。&lt;/p&gt;

&lt;p&gt;set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。&lt;/p&gt;

&lt;p&gt;set print array off
show print array&lt;/p&gt;

&lt;p&gt;set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。&lt;/p&gt;

&lt;p&gt;show print elements
查看print elements的选项信息。&lt;/p&gt;

&lt;p&gt;set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。&lt;/p&gt;

&lt;p&gt;set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。&lt;/p&gt;

&lt;h1 id=&#34;14-关于显示源码list:a705e2985626516966a98e6f6a34e407&#34;&gt;14.关于显示源码list&lt;/h1&gt;

&lt;p&gt;以下是list命令的說明。
參數                                     說明
list filename:number  列出某檔案的第幾行，檔案是可省略的。
list [function]                  列出某函數的程式碼
list                                       繼續印出程式碼
list -                                     印出上一次list的程式碼的前一段程式碼(類似向上翻動)
show listsize   顯示現在一次印出幾行
set listsize  設定一次印出幾行&lt;/p&gt;

&lt;p&gt;备常用命令：&lt;/p&gt;

&lt;h2 id=&#34;１-常看源码-list-ｌ:a705e2985626516966a98e6f6a34e407&#34;&gt;１.常看源码：list（ｌ）　&lt;/h2&gt;

&lt;p&gt;　　list　＜linenumber＞　行号
　　list　＜＋offset＞　当前行号的正偏移
　　list　＜－offset＞　当前行号的负偏移
　　list　＜filename：linenumber＞　哪个文件的哪一行
　　list　＜function＞　函数名
　　list　＜filename：function＞　文件的哪个函数
　　list　＜＊address＞　程序运行时语句在内存中的地址&lt;/p&gt;

&lt;h2 id=&#34;２-设置断点-break-ｂ:a705e2985626516966a98e6f6a34e407&#34;&gt;２．设置断点：break（ｂ）&lt;/h2&gt;

&lt;p&gt;　　break　＜function＞　指定函数断点
　　break　＜linenumber＞　指定行号断点
　　break　＜＋offset／－offset＞　当前行号的正／负偏移
　　break　＜filename：linenumber＞　哪个文件的哪一行
　　break　＜＊address＞　运行中的内存地址
　　break　不带参数，下一条指令停止处
　　break &amp;hellip;　if　＜condition＞　在运行中，当condition条件满足时停止。
　　　　ｅｇ．　break　if　ｉ＝100 //当i=100时，立即停止
                 break foo if i=100   //断点设置在foo中，断点条件是i-100, 一点在函数foo中，i的值等于100,被停止。&lt;/p&gt;

&lt;h2 id=&#34;３-查看信息-info:a705e2985626516966a98e6f6a34e407&#34;&gt;３．查看信息： info&lt;/h2&gt;

&lt;p&gt;　　info　break　查看断点信息
    info locals 打印出当前函数中所有局部变量及其值
　　info　stack　查看栈中信息
    info frame 更详细的栈层地址信息
　　info　args　查看参数信息
　　info　registers／info　all－registers　查看（所有）寄存器信息
　　info　sources　查看项目的源代码信息&lt;/p&gt;

&lt;h2 id=&#34;４-维护breakpoint-disable-enable-clear-delete:a705e2985626516966a98e6f6a34e407&#34;&gt;４．维护breakpoint：disable/enable/clear/delete&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt; disable(dis) 【breakpoints】 【range...】
   如果没有参数，则停止所有的断点，
 enable 【breakpoints】【range】
 clear &amp;lt;function&amp;gt;/&amp;lt;filename:function&amp;gt;/&amp;lt;linenum&amp;gt;/&amp;lt;filename:linenum&amp;gt;
    清楚已定义的停止点
  delete [breakpoints] [ranga...]
     删除指定的断点
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;５-恢复程序运行:a705e2985626516966a98e6f6a34e407&#34;&gt;５．恢复程序运行：&lt;/h2&gt;

&lt;p&gt;　　continue（c）
　　&lt;/p&gt;

&lt;h2 id=&#34;6-until和finish:a705e2985626516966a98e6f6a34e407&#34;&gt;6.until和finish&lt;/h2&gt;

&lt;p&gt;until 跳出循环比较有用
    help finish
     Execute until selected stack frame returns.
     Upon return, the value returned is printed and put in the value history.
  finish 用来跳出函数比较有用。
    help until
     Execute until the program reaches a source line greater than the current
     or a specified location (same args as break command) within the current frame&lt;/p&gt;

&lt;p&gt;##一、多线程调试&lt;br /&gt;
多线程调试重要就是下面几个命令：&lt;br /&gt;
info thread 查看当前进程的线程。&lt;br /&gt;
thread &lt;ID&gt; 切换调试的线程为指定ID的线程。&lt;br /&gt;
break file.c:100 thread all  在file.c文件第100行处为所有经过这里的线程设置断点。   set scheduler-locking off|on|step，这个是问得最多的。&lt;br /&gt;
  * 在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。&lt;br /&gt;
  * off 不锁定任何线程，也就是所有线程都执行，这是默认值。&lt;br /&gt;
  * on 只有当前被调试程序会执行。&lt;br /&gt;
  * step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;

&lt;p&gt;##二、调试宏
这个问题超多。在GDB下，我们无法print宏定义，因为宏是预编译的。但是我们还是有办法来调试宏，这个需要GCC的配合。&lt;br /&gt;
在GCC编译程序的时候，加上-ggdb3参数，这样，你就可以调试宏了。&lt;br /&gt;
另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。&lt;br /&gt;
info macro – 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。&lt;br /&gt;
macro – 你可以查看宏展开的样子。&lt;/p&gt;

&lt;p&gt;##三、源文件
这个问题问的也是很多的，太多的朋友都说找不到源文件。在这里我想提醒大家做下面的检查：&lt;br /&gt;
编译程序员是否加上了-g参数以包含debug信息。 路径是否设置正确了。使用GDB的directory命令来设置源文件的目录。&lt;br /&gt;
下面给一个调试/bin/ls的示例（ubuntu下）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get sourcecoreutils  
$ sudoapt-get installcoreutils-dbgsym  
$ gdb /bin/ls  
GNU gdb (GDB) 7.1-ubuntu  
(gdb) list main  
1192    ls.c: No such fileor directory.  
inls.c  
(gdb) directory ~/src/coreutils-7.4/src/  
Source directories searched: /home/hchen/src/coreutils-7.4:$cdir:$cwd  
(gdb) list main  
1192        }  
1193    }  
1194  
1195    int  
1196    main (int argc, char **argv)  
1197    {  
1198      int i;  
1199      struct pending *thispend;  
1200      int n_files;  
1201  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##四、条件断点
条件断点是语法是：&lt;code&gt;break  [where] if [condition]&lt;/code&gt;，这种断点真是非常管用。尤其是在一个循环或递归中，或是要监视某个变量。&lt;br /&gt;
注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。&lt;/p&gt;

&lt;p&gt;##五、命令行参数
有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。&lt;br /&gt;
其实，有两种方法：&lt;br /&gt;
- gdb命令行的 –args 参数&lt;br /&gt;
- gdb环境中 set args命令。&lt;/p&gt;

&lt;p&gt;##六、gdb的变量
有时候，在调试程序时，我们不单单只是查看运行时的变量，我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，或是switch的分支语句。使用set命令可以修改程序中的变量。&lt;br /&gt;
另外，你知道gdb中也可以有变量吗？就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) set$i = 0

(gdb) p a[$i++]

...  #然后就一路回车下去了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。&lt;/p&gt;

&lt;p&gt;##七、x命令
也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。&lt;br /&gt;
- x/x 以十六进制输出&lt;br /&gt;
- x/d 以十进制输出&lt;br /&gt;
- x/c 以单字符输出&lt;br /&gt;
- x/i  反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）&lt;br /&gt;
- x/s 以字符串输出&lt;/p&gt;

&lt;p&gt;##八、command命令
有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) breakfunc
Breakpoint 1 at 0x3475678: filetest.c, line 12.
(gdb) command1
Type commands forwhen breakpoint 1 is hit, one per line.
End with a line saying just &amp;quot;end&amp;quot;.
&amp;gt;print arg1
&amp;gt;print arg2
&amp;gt;print arg3
&amp;gt;end
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。&lt;/p&gt;

&lt;p&gt;#设置core环境
uname -a 查看机器参数&lt;br /&gt;
ulimit -a 查看默认参数&lt;br /&gt;
ulimit -c 1024  设置core文件大小为1024&lt;br /&gt;
ulimit -c unlimit 设置core文件大小为无限&lt;/p&gt;

&lt;p&gt;多线程如果dump，多为段错误，一般都涉及内存非法读写。可以这样处理，使用下面的命令打开系统开关，让其可以在死掉的时候生成 core文件。&lt;br /&gt;
ulimit -c unlimited&lt;/p&gt;

&lt;p&gt;#线程调试命令
1. (gdb)info threads&lt;br /&gt;
显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。
前面有*的是当前调试的线程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;(gdb)thread ID&lt;br /&gt;
切换当前调试的线程为指定ID的线程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)thread apply ID1 ID2 command&lt;br /&gt;
让一个或者多个线程执行GDB命令command。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)thread apply all command&lt;br /&gt;
让所有被调试线程执行GDB命令command。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb)set scheduler-locking off|on|step&lt;br /&gt;
估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;off 不锁定任何线程，也就是所有线程都执行，这是默认值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;on 只有当前被调试程序会执行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;//显示线程堆栈信息&lt;br /&gt;
6. (gdb) bt&lt;br /&gt;
察看所有的调用栈&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;(gdb) f 3
调用框层次&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(gdb) i locals&lt;br /&gt;
显示所有当前调用栈的所有变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>gdb调试方法精粹</title>
      <link>http://sun-friderick.github.io/post/2015-01-31</link>
      <pubDate>Sat, 31 Jan 2015 00:30:03 CST</pubDate>
      <author>Frederick Sun</author>
      <guid>http://sun-friderick.github.io/post/2015-01-31</guid>
      <description>&lt;p&gt;#一、多线程调试
###1. 多线程调试,最重要的几个命令:
info threads                        查看当前进程的线程。
                                          GDB会为每个线程分配一个ID, 后面操作线程的时候会用到这个ID.
                                          前面有*的是当前调试的线程.
thread                      切换调试的线程为指定ID的线程。
break file.c:100 thread all    在file.c文件第100行处为所有经过这里的线程设置断点。
set scheduler-locking off|on|step&lt;br /&gt;
      在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的,
      怎么只让被调试程序执行呢？
      通过这个命令就可以实现这个需求。
         off      不锁定任何线程，也就是所有线程都执行，这是默认值。
         on       只有当前被调试程序会执行。
         step     在单步的时候，除了next过一个函数的情况
                  (熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，
                  只有当前线程会执行。
thread apply ID1 ID2 command        让一个或者多个线程执行GDB命令command
thread apply all command            让所有被调试线程执行GDB命令command。&lt;/p&gt;

&lt;p&gt;###2. 使用示例:
线程产生通知：在产生新的线程时, gdb会给出提示信息
&amp;gt;(gdb) r
Starting program: /root/thread
[New Thread 1073951360 (LWP 12900)]
[New Thread 1082342592 (LWP 12907)]&amp;mdash;以下三个为新产生的线程
[New Thread 1090731072 (LWP 12908)]
[New Thread 1099119552 (LWP 12909)]&lt;/p&gt;

&lt;p&gt;查看线程：使用info threads可以查看运行的线程。
&amp;gt;(gdb) info threads
  4 Thread 1099119552 (LWP 12940)   0xffffe002 in ?? ()
  3 Thread 1090731072 (LWP 12939)   0xffffe002 in ?? ()
  2 Thread 1082342592 (LWP 12938)   0xffffe002 in ?? ()
* 1 Thread 1073951360 (LWP 12931)   main (argc=1, argv=0xbfffda04) at thread.c:21
(gdb)&lt;/p&gt;

&lt;p&gt;注意，行首为gdb分配的线程ID号，对线程进行切换时，使用该ID号码。
另外，行首的星号标识了当前活动的线程
切换线程：
使用 thread THREADNUMBER 进行切换，THREADNUMBER 为上文提到的线程ID号。
下例显示将活动线程从 1 切换至 4。
&amp;gt;(gdb) info threads
   4 Thread 1099119552 (LWP 12940)   0xffffe002 in ?? ()
   3 Thread 1090731072 (LWP 12939)   0xffffe002 in ?? ()
   2 Thread 1082342592 (LWP 12938)   0xffffe002 in ?? ()
* 1 Thread 1073951360 (LWP 12931)   main (argc=1, argv=0xbfffda04) at thread.c:21
(gdb) thread 4
[Switching to thread 4 (Thread 1099119552 (LWP 12940))]#0   0xffffe002 in ?? ()
(gdb) info threads
* 4 Thread 1099119552 (LWP 12940)   0xffffe002 in ?? ()
   3 Thread 1090731072 (LWP 12939)   0xffffe002 in ?? ()
   2 Thread 1082342592 (LWP 12938)   0xffffe002 in ?? ()
   1 Thread 1073951360 (LWP 12931)   main (argc=1, argv=0xbfffda04) at thread.c:21
(gdb)&lt;/p&gt;

&lt;p&gt;以上即为使用gdb提供的对多线程进行调试的一些基本命令。
另外，gdb也提供对线程的断点设置以及对指定或所有线程发布命令的命令&lt;/p&gt;

&lt;p&gt;#二、调试宏
在GDB下, 我们无法print宏定义，因为宏是预编译的。
但是我们还是有办法来调试宏，这个需要GCC的配合。
在GCC编译程序的时候，加上
  -ggdb3   参数，这样，你就可以调试宏了。&lt;/p&gt;

&lt;p&gt;另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。
info macro   查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。
macro         查看宏展开的样子。&lt;/p&gt;

&lt;p&gt;#三、源文件
GDB时,提示找不到源文件。
需要做下面的检查:
编译程序员是否加上了 -g参数 以包含debug信息。
路径是否设置正确了。
使用GDB的directory命令来设置源文件的目录。&lt;/p&gt;

&lt;p&gt;下面给一个调试/bin/ls的示例(ubuntu下)
&amp;gt;$ apt-get source coreutils
$ sudo apt-get install coreutils-dbgsym
$ gdb /bin/ls
GNU gdb (GDB) 7.1-ubuntu
(gdb) list main
1192    ls.c: No such file or directory.
in ls.c
(gdb) directory ~/src/coreutils-7.4/src/
Source directories searched: /home/hchen/src/coreutils-7.4:$cdir:$cwd
(gdb) list main
1192        }
1193    }
1194
1195    int
1196    main (int argc, char **argv)
1197    {
1198      int i;
1199      struct pending *thispend;
1200      int n_files;
1201&lt;/p&gt;

&lt;p&gt;#四、条件断点
条件断点是语法是：
  break  [where] if [condition]
这种断点真是非常管用。
尤其是在一个循环或递归中，或是要监视某个变量。
注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。&lt;/p&gt;

&lt;p&gt;#五、命令行参数
有时候，我们需要调试的程序需要有命令行参数, 有三种方法：
gdb命令行的 -args 参数
gdb环境中   set args命令。
gdb环境中   run 参数&lt;/p&gt;

&lt;p&gt;#六、gdb的变量
有时候，在调试程序时，我们不单单只是查看运行时的变量，
我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，
或是switch的分支语句。使用set命令可以修改程序中的变量。
另外，你知道gdb中也可以有变量吗？
就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：
(gdb) set $i = 0
(gdb) p a[$i++]
&amp;hellip;  #然后就一路回车下去了
当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。&lt;/p&gt;

&lt;p&gt;#七、x命令
也许，你很喜欢用p命令。
所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。
x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。
x/x 以十六进制输出
x/d 以十进制输出
x/c 以单字符输出
x/i  反汇编 – 通常，我们会使用 x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）
x/s 以字符串输出&lt;/p&gt;

&lt;p&gt;#八、command命令
如何自动化调试。
这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。
下面是一个示例：
&amp;gt;(gdb) break func
&amp;gt;Breakpoint 1 at 0x3475678: file test.c, line 12.
&amp;gt;(gdb) command 1
&amp;gt;Type commands for when breakpoint 1 is hit, one per line.
&amp;gt;End with a line saying just &amp;ldquo;end&amp;rdquo;.
&amp;gt;print arg1
&amp;gt;print arg2
&amp;gt;print arg3
&amp;gt;end
&amp;gt;(gdb)&lt;/p&gt;

&lt;p&gt;当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
