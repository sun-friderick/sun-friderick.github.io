<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="gdb, gdb调试命令, 调试命令的使用, gdb调试, gdb使用, 教程, gdb总结, ">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="gdb调试命令的使用及总结 : frederick.sun"/>
<meta property="og:site_name" content="nanshu wang blog"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="http://sun-friderick.github.io/post/2015-11-31">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2015-12-01"/>
<meta property="article:modified_time" content="2015-12-01"/>



<meta property="article:tag" content="gdb">
<meta property="article:tag" content="gdb调试命令">
<meta property="article:tag" content="调试命令的使用">
<meta property="article:tag" content="gdb调试">
<meta property="article:tag" content="gdb使用">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="gdb总结">





    <base href="http://sun-friderick.github.io/">
    <title> gdb调试命令的使用及总结 - frederick.sun </title>
    <link rel="canonical" href="http://sun-friderick.github.io/post/2015-11-31">
    

    <link href='http://fonts.useso.com/css?family=Fjalla+One|Open+Sans:300' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/static/css/style.css">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?a79535ca63291dc820e3ecefa615aad1";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

</head>

<body lang="en" itemscope itemtype="http://schema.org/Article">
<header id="header">
	<nav id="nav">
	<div id="title"><a href="/">Frederick Sun</a></div>
    <div><a href=mailto: mrsun.echo@gmail.com target="_blank" class="mailto"> </span> <span class="icon-mail"></span>eric</a></div>
	</nav>
    <nav id="nav">
    	        <ul id="mainnav">
            <li>
                <a href="/bar-work/">
                <span class="icon"> <i aria-hidden="true" class="icon-console"></i></span> 
                <span> 工作 </span>
            </a>
            </li>
            <li>
            <a href="/bar-technology/">
                <span class="icon"> <i aria-hidden="true" class="icon-stats"></i></span>
                <span> 技术 </span>
            </a>
            </li>
            <li>
            <a href="/bar-favor/">
                <span class="icon"> <i aria-hidden="true" class="icon-leaf"></i></span>
                <span> 爱好 </span>
            </a>
            </li>
            
            <li>
            <a href="/bar-living/">
                <span class="icon"> <i aria-hidden="true" class="icon-quill"></i></span>
                <span> 生活 </span>
            </a>
            </li>
            
            <li>
            <a href="/tags/">
                <span class="icon"> <i aria-hidden="true" class="icon-pencil"></i></span>
                <span> Tags </span>
            </a>
            </li>
            
            <li>
            <a href="/about">
                <span class="icon"> <i aria-hidden="true" class="icon-heart"></i></span>
                <span> 关于 </span>
            </a>
            </li>
        </ul>

    </nav>
    <nav id="nav">
       	        <ul id="social">
            
            <li id="share">
                <span class="title"> 友链 </span>
                <div class="dropdown share">
                    <ul class="social">
                      <li> <a href="http://xgezhang.com" target="_blank" title="xge技术博客" class="twitter">xge</a> </li>
                      <li> <a href="http://spf13.com" target="_blank" title="spf13 is Steve Francis" class="facebook">spf13</a> </li>
                      <li> <a href="http://libaier.net" target="_blank" title="Libaier" class="rss">Libaier</a> </li>
                      <li> <a href="http://read.douban.com/column/195295/" target="_blank" title="100个故事" class="douban">一百个故事</a></li>
                      <li> <a href="http://zhangwenli.com/blog/" target="_blank" title="羡辙杂俎" class="yangzhe">羡辙杂俎</a></li>
	      <li> <a href="http://nanshu.wang/" target="_blank" title="Hugo博客" class="hugo">Hugo博客</a></li>
                    </ul>
                <span class="icon icon-bubbles"> </span> <span class="subcount"></span> </div>
            </li>
                
            <li id="follow">
                <span class="title"> 驻留地 </span>
                <div class="dropdown follow">
                    <ul class="social">
                    
                        <li> <a href="http://weibo.com/2235647167/profile/" target="_blank" title="微博" class="weibo">微博</a> </li>
                        <li> <a href="http://www.doc88.com/123_echo_" target="_blank" title="道客巴巴" class="doc88">道客巴巴</a> </li>
                        <li> <a href="http://www.zhihu.com/people/eric-sun-11" target="_blank" title="知乎" class="zhihu">知乎</a> </li>
                        <li> <a href="http://github.com/sun-friderick/" target="_blank" title="GitHub" class="github">GitHub</a> </li>                         
                        <li> <a href="http://www.cnblogs.com/sun-frederick/" target="_blank" title="博客园" class="cnblogs"> 博客园</a></li>
                        <li> <a href="http://instagram.com/ainedrag22" target="_blank" title="Instagram" class="instagram">Instagram</a> </li>
                        
                    </ul>
                <span class="icon icon-rocket"> </span> <span class="subcount"></span> </div>
            </li>
            
            
        </ul>

	</nav>
</header>



<section id="main">
  <h1 itemprop="name" >gdb调试命令的使用及总结</h1>
  

<aside id="meta">

    <div>
        <section id="datecount">
          <h4 id="date"> Tue Dec 1, 2015 </h4>
          
        </section>
        
        <ul id="tags">
          
            <li> <a href="http://sun-friderick.github.io//tags/gdb">gdb</a> </li>
          
            <li> <a href="http://sun-friderick.github.io//tags/gdb%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4">gdb调试命令</a> </li>
          
            <li> <a href="http://sun-friderick.github.io//tags/%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">调试命令的使用</a> </li>
          
            <li> <a href="http://sun-friderick.github.io//tags/gdb%E8%B0%83%E8%AF%95">gdb调试</a> </li>
          
            <li> <a href="http://sun-friderick.github.io//tags/gdb%E4%BD%BF%E7%94%A8">gdb使用</a> </li>
          
            <li> <a href="http://sun-friderick.github.io//tags/%E6%95%99%E7%A8%8B">教程</a> </li>
          
            <li> <a href="http://sun-friderick.github.io//tags/gdb%E6%80%BB%E7%BB%93">gdb总结</a> </li>
          
        </ul>
    </div>

</aside>

<meta itemprop="wordCount" content="2209">
<meta itemprop="datePublished" content="2015-12-01">
<meta itemprop="url" content="http://sun-friderick.github.io/post/2015-11-31">


  <div>
        <article itemprop="articleBody" id="content">
           <p>#用GDB调试程序
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。
#用GDB调试程序
##GDB概述
————
GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那
种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你
会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，
尺有所短”就是这个道理。
一般来说，GDB主要帮忙你完成下面四个方面的功能：
1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
3、当程序被停住时，可以检查此时你的程序中所发生的事。
4、动态的改变你程序的执行环境。
从上面看来，GDB和一般的调试工具没有什么两样，基本上也是完成这些功能，不过在细
节上，你会发现GDB这个调试工具的强大，大家可能比较习惯了图形化的调试工具，但有
时候，命令行的调试工具却有着图形化工具所不能完成的功能。让我们一一看来。
##一个调试示例
——————
源程序：tst.c
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i<7; i++) {
8 sum+=i; 
9 } 
10 return sum; 
11 } 
12 
13 
14 main() 
15 { 
16 int i; 
17 long result = 0; 
18 for(i=1; i<=100; i++) 
19 { 
20 result += i; 
21 } 
22 
23 printf("result[1-100] = %d /n", result ); 
24 printf("result[1-250] = %d /n", func(250) ); 
25 } 
编译生成执行文件：（Linux下） 
hchen/test> cc -g tst.c -o tst
使用GDB调试：
hchen/test&gt; gdb tst &lt;&mdash;&mdash;&mdash;- 启动GDB
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &ldquo;show copying&rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &ldquo;show warranty&rdquo; for details.
This GDB was configured as &ldquo;i386-suse-linux&rdquo;&hellip;
(gdb) l &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; l命令相当于list，从第一行开始例出原码。
1 #include
2
3 int func(int n)
4 {
5 int sum=0,i;
6 for(i=0; i 7 {
8 sum+=i;
9 }
10 return sum;
(gdb) &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 直接回车表示，重复上一次命令
11 }</p>

<p>12
13
14 main()
15 {
16 int i;
17 long result = 0;
18 for(i=1; i&lt;=100; i++)
19 {
20 result += i;
(gdb) break 16 &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 设置断点，在源程序第16行处。
Breakpoint 1 at 0x8048496: file tst.c, line 16.
(gdb) break func &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 设置断点，在函数func()入口处。
Breakpoint 2 at 0x8048456: file tst.c, line 5.
(gdb) info break &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; 查看断点信息。
Num Type Disp Enb Address What
1 breakpoint keep y 0x08048496 in main at tst.c:16
2 breakpoint keep y 0x08048456 in func at tst.c:5
(gdb) r &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 运行程序，run命令简写
Starting program: /home/hchen/test/tst
Breakpoint 1, main () at tst.c:17 &lt;&mdash;&mdash;&mdash;- 在断点处停住。
17 long result = 0;
(gdb) n &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 单条语句执行，next命令简写。
18 for(i=1; i&lt;=100; i++)
(gdb) n
20 result += i;
(gdb) n
18 for(i=1; i&lt;=100; i++)
(gdb) n
20 result += i;
(gdb) c &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 继续运行程序，continue命令简写。
Continuing.
result[1-100] = 5050 &lt;&mdash;&mdash;&mdash;-程序输出。
Breakpoint 2, func (n=250) at tst.c:5
5 int sum=0,i;
(gdb) n
6 for(i=1; i&lt;=n; i++)
(gdb) p i &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 打印变量i的值，print命令简写。
$1 = 134513808
(gdb) n
8 sum+=i;
(gdb) n
6 for(i=1; i&lt;=n; i++)</p>

<p>(gdb) p sum
$2 = 1
(gdb) n
8 sum+=i;
(gdb) p i
$3 = 2
(gdb) n
6 for(i=1; i&lt;=n; i++)
(gdb) p sum
$4 = 3
(gdb) bt &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 查看函数堆栈。
#0 func (n=250) at tst.c:5
#1 0x080484e4 in main () at tst.c:24
#2 0x400409ed in __libc_start_main () from /lib/libc.so.6
(gdb) finish &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 退出函数。
Run till exit from #0 func (n=250) at tst.c:5
0x080484e4 in main () at tst.c:24
24 printf(&ldquo;result[1-250] = %d /n&rdquo;, func(250) );
Value returned is $6 = 31375
(gdb) c &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 继续运行。
Continuing.
result[1-250] = 31375 &lt;&mdash;&mdash;&mdash;-程序输出。
Program exited with code 027. &lt;&mdash;&mdash;&ndash;程序退出，调试结束。
(gdb) q &lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 退出gdb。
hchen/test&gt;
好了，有了以上的感性认识，还是让我们来系统地认识一下gdb吧。
使用GDB
————
一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必
须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。
如：
&gt; cc -g hello.c -o hello
&gt; g++ -g hello.cpp -o hello
如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用
-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。
启动GDB的方法有以下几种：</p>

<p>###1、gdb
program也就是你的执行文件，一般在当然目录下。
###2、gdb core
用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。
###3、gdb
如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自
动attach上去，并调试他。program应该在PATH环境变量中搜索得到。
GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。我在下
面只例举一些比较常用的参数：
-symbols
-s
从指定文件中读取符号表。
-se file
从指定文件中读取符号表信息，并把他用在可执行文件中。
-core
-c
调试时core dump的core文件。
-directory
-d
加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。
#GDB的命令概貌
———————
启动gdb后，就你被带入gdb的调试环境中，就可以使用gdb的命令开始调试程序了，gdb
的命令可以使用help命令来查看，如下所示：
/home/hchen&gt; gdb
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type &ldquo;show copying&rdquo; to see the conditions.
There is absolutely no warranty for GDB. Type &ldquo;show warranty&rdquo; for details.
This GDB was configured as &ldquo;i386-suse-linux&rdquo;.
(gdb) help</p>

<p>List of classes of commands:
aliases &ndash; Aliases of other commands
breakpoints &ndash; Making program stop at certain points
data &ndash; Examining data
files &ndash; Specifying and examining files
internals &ndash; Maintenance commands
obscure &ndash; Obscure features
running &ndash; Running the program
stack &ndash; Examining the stack
status &ndash; Status inquiries
support &ndash; Support facilities
tracepoints &ndash; Tracing of program execution without stopping the program
user-defined &ndash; User-defined commands
Type &ldquo;help&rdquo; followed by a class name for a list of commands in that class.
Type &ldquo;help&rdquo; followed by command name for full documentation.
Command name abbreviations are allowed if unambiguous.
(gdb)
gdb的命令很多，gdb把之分成许多个种类。help命令只是例出gdb的命令种类，如果要看
种类中的命令，可以使用help 命令，如：help breakpoints，查看设置断点的所有命令。也
可以直接help 来查看命令的帮助。
gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令
的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐
命令的全称，如果有重复的，那么gdb会把其例出来。
示例一：在进入函数func时，设置一个断点。可以敲入break func，或是直接就是b func
(gdb) b func
Breakpoint 1 at 0x8048458: file hello.c, line 10.
示例二：敲入b按两次TAB键，你会看到所有b打头的命令：
(gdb) b
backtrace break bt
(gdb)
示例三：只记得函数的前缀，可以这样：
(gdb) b make_ &lt;按TAB键&gt;
（再按下一次TAB键，你会看到:）
make_a_section_from_file make_environ
make_abs_section make_function_type
make_blockvector make_pointer_type</p>

<p>make_cleanup make_reference_type
make_command make_symbol_completion<em>list
(gdb) b make</em>
GDB把所有make开头的函数全部例出来给你查看。
示例四：调试C++的程序时，有可以函数名一样。如：
(gdb) b &lsquo;bubble( M-?
bubble(double,double) bubble(int,int)
(gdb) b &lsquo;bubble(
你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思）
要退出gdb时，只用发quit或命令简称q就行了。
GDB中运行UNIX的shell程序
————————————
在gdb环境中，你可以执行UNIX的shell的命令，使用gdb的shell命令来完成：
shell
调用UNIX的shell来执行，环境变量SHELL中定义的UNIX的shell将会被用来执行，如
果SHELL没有定义，那就使用UNIX的标准shell：/bin/sh。（在Windows中使用Command.com
或cmd.exe）
还有一个gdb命令是make：
make
可以在gdb中执行make命令来重新build自己的程序。这个命令等价于“shell make ”。
在GDB中运行程序
————————
当以gdb 方式启动gdb后，gdb会在PATH路径和当前目录中搜索的源文件。如要确认gdb
是否读到源文件，可使用l或list命令，看看gdb是否能列出源代码。
在gdb中，运行程序使用r或是run命令。程序的运行，你有可能需要设置下面四方面的事。
###1、程序运行参数。
set args 可指定运行时参数。（如：set args 10 20 30 40 50）
show args 命令可以查看设置好的运行参数。
###2、运行环境。
path
可设定程序的运行路径。
show paths 查看程序的运行路径。</p>

<p>set environment varname [=value] 设置环境变量。如：set env USER=hchen
show environment [varname] 查看环境变量。
###3、工作目录。
cd
相当于shell的cd命令。
pwd 显示当前的所在目录。
###4、程序的输入输出。
info terminal 显示你程序用到的终端的模式。
使用重定向控制程序输出。如：run &gt; outfile
tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb
#调试已运行的程序
————————
两种方法：
1、在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在
运行的程序。
2、先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用
detach来取消挂接的进程。
#暂停 / 恢复程序运行
—————————
调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序
的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变
量，以及运行时的流程。
当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停
的原因。
在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕
捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）。如果要恢复程序运行，可
以使用c或是continue命令。
##一、设置断点（BreakPoint）
我们用break命令来设置断点。正面有几点设置断点的方法：
break
在进入指定函数时停住。C++中可以使用class::function或function(type,type)格式来指定函</p>

<p>数名。
break
在指定行号停住。
break +offset
break -offset
在当前行号的前面或后面的offset行停住。offiset为自然数。
break filename:linenum
在源文件filename的linenum行处停住。
break filename:function
在源文件filename的function函数的入口处停住。
break *address
在程序运行的内存地址处停住。
break
break命令没有参数时，表示在下一条指令处停住。
break &hellip; if
&hellip;可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环境体中，可以设
置break if i=100，表示当i为100时停住程序。
查看断点时，可使用info命令，如下所示：（注：n表示断点号）
info breakpoints [n]
info break [n]
##二、设置观察点（WatchPoint）
观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马
上停住程序。我们有下面的几种方法来设置观察点：
watch
为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序。
rwatch
当表达式（变量）expr被读时，停住程序。
awatch
当表达式（变量）的值被读或被写时，停住程序。</p>

<p>info watchpoints
列出当前所设置了的所有观察点。
##三、设置捕捉点（CatchPoint）
你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++
的异常。设置捕捉点的格式为：
catch
当event发生时，停住程序。event可以是下面的内容：
1、throw 一个C++抛出的异常。（throw为关键字）
2、catch 一个C++捕捉到的异常。（catch为关键字）
3、exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）
4、fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）
5、vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）
6、load 或 load 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX
下有用）
7、unload 或 unload 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在
HP-UX下有用）
tcatch
只设置一次捕捉点，当程序停住以后，应点被自动删除。
##四、维护停止点
上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你
觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来
进行维护。
clear
清除所有的已定义的停止点。
clear
clear
清除所有设置在函数上的停止点。
clear
clear
清除所有设置在指定行上的停止点。
delete [breakpoints] [range&hellip;]
删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range
表示断点号的范围（如：3-7）。其简写命令为d。</p>

<p>比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要
时，enable即可，就好像回收站一样。
disable [breakpoints] [range&hellip;]
disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的
停止点。简写命令是dis.
enable [breakpoints] [range&hellip;]
enable所指定的停止点，breakpoints为停止点号。
enable [breakpoints] once range&hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。
enable [breakpoints] delete range&hellip;
enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。
##五、停止条件维护
前面在说到设置断点时，我们提到过可以设置一个条件，当条件成立时，程序自动停止，这
是一个非常强大的功能，这里，我想专门说说这个条件的相关维护命令。一般来说，为断点
设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以
用condition命令来修改断点的条件。（只有break和watch命令支持if，catch目前暂不支持
if）
condition
修改断点号为bnum的停止条件为expression。
condition
清除断点号为bnum的停止条件。
还有一个比较特殊的维护命令ignore，你可以指定程序运行时，忽略停止条件几次。
ignore
表示忽略断点号为bnum的停止条件count次。
##六、为停止点设定运行命令
我们可以使用GDB提供的command命令来设置停止点的运行命令。也就是说，当运行的
程序在被停止住时，我们可以让其自动运行一些别的命令，这很有利行自动化调试。对基于
GDB的自动化调试是一个强大的支持。
commands [bnum]</p>

<p>&hellip; command-list &hellip;
end
为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的
命令。
例如：
break foo if x&gt;0
commands
printf &ldquo;x is %d/n&rdquo;,x
continue
end
断点设置在函数foo中，断点条件是x&gt;0，如果程序被断住后，也就是，一旦x的值在foo
函数中大于0，GDB会自动打印出x的值，并继续运行程序。
如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个
end就行了。
##七、断点菜单
在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break 不
能告诉GDB要停在哪个函数的入口。当然，你可以使用break 也就是把函数的参数类型告
诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的
断点。你只要输入你菜单列表中的编号就可以了。如：
(gdb) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
&gt; 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the &ldquo;delete&rdquo; command to delete unwanted
breakpoints.
(gdb)</p>

<p>可见，GDB列出了所有after的重载函数，你可以选一下列表编号就行了。0表示放弃设置
断点，1表示所有函数都设置断点。
##八、恢复程序运行和单步调试
当程序被停住了，你可以用continue命令恢复程序的运行直到程序结束，或下一个断点到来。
也可以使用step或next命令单步跟踪程序。
continue [ignore-count]
c [ignore-count]
fg [ignore-count]
恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次
数。continue，c，fg三个命令都是一样的意思。
step
单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug
信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，
加表示执行后面的count条指令，然后再停住。
next
同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面
可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后
再停住。
set step-mode
set step-mode on
打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。
这个参数有很利于查看机器码。
set step-mod off
关闭step-mode模式。
finish
运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。
until 或 u
当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
stepi 或 si
nexti 或 ni
单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步
执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单
步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p>

<p>##九、信号（Signals）
信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤
其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT
表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示
子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下
非常重要的一种技术。
GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信
号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。
你可以用GDB的handle命令来完成这一功能。
handle
在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处
理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包
括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。
一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几
种关键字的一个或多个。
nostop
当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信
号。
stop
当被调试的程序收到信号时，GDB会停住你的程序。
print
当被调试的程序收到信号时，GDB会显示出一条信息。
noprint
当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。
pass
noignore
当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程
序会处理。
nopass
ignore
当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。
info signals
info handle
查看有哪些信号在被GDB检测中。
##十、线程（Thread Stops）</p>

<p>如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线
程。GDB很容易帮你完成这一工作。
break thread
break thread if &hellip;
linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是
GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你
不指定thread 则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如：
(gdb) break frik.c:13 thread 28 if bartab &gt; lim
当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体
情况。而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。
#查看栈信息
—————
当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一
个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以
用GDB命令来查看当前的栈中的信息。
下面是一些查看函数调用栈信息的GDB命令：
backtrace
bt
打印当前的函数调用栈的所有信息。如：
(gdb) bt
#0 func (n=250) at tst.c:6
#1 0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30
#2 0x400409ed in <strong>libc_start_main () from /lib/libc.so.6
从上可以看出函数的调用栈信息：</strong>libc_start_main &ndash;&gt; main() &ndash;&gt; func()
backtrace
bt
n是一个正整数，表示只打印栈顶上n层的栈信息。
backtrace &lt;-n&gt;
bt &lt;-n&gt;
-n表一个负整数，表示只打印栈底下n层的栈信息。
如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈</p>

<p>就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。
frame
f
n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的
第二层。
up
表示向栈的上面移动n层，可以不打n，表示向上移动一层。
down
表示向栈的下面移动n层，可以不打n，表示向下移动一层。
上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三
个命令：
select-frame 对应于 frame 命令。
up-silently 对应于 up 命令。
down-silently 对应于 down 命令。
查看当前栈层的信息，你可以用以下GDB命令：
frame 或 f
会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数
执行到的语句。
info frame
info f
这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比
如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写
成的、函数参数地址及值、局部变量的地址等等。如：
(gdb) info f
Stack level 0, frame at 0xbffff5d4:
eip = 0x804845d in func (tst.c:6); saved eip 0x8048524
called by frame at 0xbffff60c
source language c.
Arglist at 0xbffff5d4, args: n=250
Locals at 0xbffff5d4, Previous frame&rsquo;s sp is 0x0
Saved registers:
ebp at 0xbffff5d4, eip at 0xbffff5d8
info args</p>

<p>打印出当前函数的参数名及其值。
info locals
打印出当前函数中所有局部变量及其值。
info catch
打印出当前的函数中的异常处理信息。
#查看源程序
—————
##一、显示源代码
GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程
序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序
停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看查看源
代码的GDB命令吧。
list
显示程序第linenum行的周围的源程序。
list
显示函数名为function的函数的源程序。
list
显示当前行后面的源程序。
list -
显示当前行前面的源程序。
一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行，当
然，你也可以定制显示的范围，使用下面命令可以设置一次显示源程序的行数。
set listsize
设置一次显示源代码的行数。
show listsize
查看当前listsize的设置。
list命令还有下面的用法：
list ,</p>

<p>显示从first行到last行之间的源代码。
list ,
显示从当前行到last行之间的源代码。
list +
往后显示源代码。
一般来说在list后面可以跟以下这们的参数：
行号。
&lt;+offset&gt; 当前行号的正偏移量。
&lt;-offset&gt; 当前行号的负偏移量。
哪个文件的哪一行。
函数名。
哪个文件中的哪个函数。
&lt;*address&gt; 程序运行时的语句在内存中的地址。
##二、搜索源代码
不仅如此，GDB还提供了源代码搜索的命令：
forward-search
search
向前面搜索。
reverse-search
全部搜索。
其中，就是正则表达式，也主一个字符串的匹配模式，关于正则表达式，我就不在这里讲了，
还请各位查看相关资料。
##三、指定源文件的路径
某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供
了可以让你指定源文件的路径的命令，以便GDB进行搜索。
directory
dir
加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，
Windows下你可以使用“;”。</p>

<p>directory
清除所有的自定义的源文件搜索路径信息。
show directories
显示定义了的源文件搜索路径。
##四、源代码的内存
你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函
数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内
存地址，如：
(gdb) info line tst.c:func
Line 5 of &ldquo;tst.c&rdquo; starts at address 0x8048456 and ends at 0x804845d .
还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前
内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。
(gdb) disassemble func
Dump of assembler code for function func:
0x8048450 : push %ebp
0x8048451 : mov %esp,%ebp
0x8048453 : sub $0x18,%esp
0x8048456 : movl $0x0,0xfffffffc(%ebp)
0x804845d : movl $0x1,0xfffffff8(%ebp)
0x8048464 : mov 0xfffffff8(%ebp),%eax
0x8048467 : cmp 0x8(%ebp),%eax
0x804846a : jle 0x8048470
0x804846c : jmp 0x8048480
0x804846e : mov %esi,%esi
0x8048470 : mov 0xfffffff8(%ebp),%eax
0x8048473 : add %eax,0xfffffffc(%ebp)
0x8048476 : incl 0xfffffff8(%ebp)
0x8048479 : jmp 0x8048464
0x804847b : nop
0x804847c : lea 0x0(%esi,1),%esi
0x8048480 : mov 0xfffffffc(%ebp),%edx
0x8048483 : mov %edx,%eax
0x8048485 : jmp 0x8048487
0x8048487 : mov %ebp,%esp
0x8048489 : pop %ebp
0x804848a : ret
End of assembler dump.</p>

<p>#查看运行时数据
———————
在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令
inspect来查看当前程序的运行数据。print命令的格式是：
print
print /
是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格
式，比如，如果要把表达式按16进制的格式输出，那么就是/x。
##一、表达式
print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据
来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函
数等内容。可惜的是GDB不能使用你在程序中所定义的宏。
表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本
文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）
在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。
@
是一个和数组有关的操作符，在后面会有更详细的说明。
::
指定一个在文件或是一个函数中的变量。
{}
表示一个指向内存地址的类型为type的一个对象。
##二、程序变量
在GDB中，你可以随时查看以下三种变量的值：
1、全局变量（所有文件可见的）
2、静态全局变量（当前文件可见的）
3、局部变量（当前Scope可见的）
如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局
变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函</p>

<p>数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量
的值时，你可以使用“::”操作符：
file::variable
function::variable
可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看
文件f2.c中的全局变量x的值：
gdb) p &lsquo;f2.c&rsquo;::x
当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所
以你不必担心在调试C++程序时会出现异常。
另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过
的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为
优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB
调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结
果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支
持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决
这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
##三、数组
有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大
小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右
边则你你想查看内存的长度。例如，你的程序中有这样的语句：
int *array = (int *) malloc (len * sizeof (int));
于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：
p *array@len
@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其
保存在变量len中，其输出结果，大约是下面这个样子的：
(gdb) p *array@len
$1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}
如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。
##四、输出格式</p>

<p>一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。
例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要
做到这样，你可以使用GDB的数据显示格式：
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
(gdb) p i
$21 = 101
(gdb) p/a i
$22 = 0x65
(gdb) p/c i
$23 = 101 &lsquo;e&rsquo;
(gdb) p/f i
$24 = 1.41531145e-43
(gdb) p/x i
$25 = 0x65
(gdb) p/t i
$26 = 1100101
##五、查看内存
你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
x/
n、f、u是可选的参数。
n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是
指令地址，那么格式可以是i。</p>

<p>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可
以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当
我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作
一个值取出来。
表示一个内存地址。
n/f/u三个参数可以一起使用。例如：
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3
表示三个单位，u表示按十六进制显示。
##六、自动显示
你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显
示。相关的GDB命令是display。
display
display/
display/
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一
个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。
格式i和s同样被display支持，一个非常有用的命令是：
display/i $pc
$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇
编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的
功能。
下面是一些和display相关的GDB命令：
undisplay
delete display
删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以
用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）
disable display
enable display
disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p>

<p>info display
查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多
少个自动显示设置，其中包括，设置的编号，表达式，是否enable。
##七、设置显示选项
GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。
set print address
set print address on
打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，
如：
(gdb) f
#0 set_quotes (lq=0x34c78 &ldquo;&lt;&lt;&ldquo;, rq=0x34c88 &ldquo;&gt;&gt;&rdquo;)
at input.c:530
530 if (lquote != def_lquote)
set print address off
关闭函数的参数地址显示，如：
(gdb) set print addr off
(gdb) f
#0 set_quotes (lq=&rdquo;&lt;&lt;&ldquo;, rq=&rdquo;&gt;&gt;&ldquo;) at input.c:530
530 if (lquote != def_lquote)
show print address
查看当前地址显示选项是否打开。
set print array
set print array on
打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗
号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。
set print array off
show print array
set print elements
这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的
最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。
show print elements</p>

<p>查看print elements的选项信息。
set print null-stop
如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。
set print pretty on
如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：
$1 = {
next = 0x0,
flags = {
sweet = 1,
sour = 1
},
meat = 0x54 &ldquo;Pork&rdquo;
}
set print pretty off
关闭printf pretty这个选项，GDB显示结构体时会如下显示：
$1 = {next = 0x0, flags = {sweet = 1, sour = 1}, meat = 0x54 &ldquo;Pork&rdquo;}
show print pretty
查看GDB是如何显示结构体的。
set print sevenbit-strings
设置字符显示，是否按“/nnn”的格式显示，如果打开，则字符串或字符数据按/nnn显示，
如“/065”。
show print sevenbit-strings
查看字符显示开关是否打开。
set print union
设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：
typedef enum {Tree, Bug} Species;
typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
typedef enum {Caterpillar, Cocoon, Butterfly}
Bug_forms;
struct thing {
Species it;
union {</p>

<p>Tree_forms tree;
Bug_forms bug;
} form;
};
struct thing foo = {Tree, {Acorn}};
当打开这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}
当关闭这个开关时，执行 p foo 命令后，会如下显示：
$1 = {it = Tree, form = {&hellip;}}
show print union
查看联合体数据的显示方式
set print object
在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法
调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是
off。
show print object
查看对象选项的设置。
set print static-members
这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是
on。
show print static-members
查看静态数据成员选项设置。
set print vtbl
当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。
show print vtbl
查看虚函数显示格式的选项。
##八、历史记录
当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB
会以$1, $2, $3 &hellip;..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问
以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，
如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。</p>

<p>##九、GDB环境变量
你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定
义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，
也是以$起头。如：
set $foo = *object_ptr
使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对
其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。
show convenience
该命令查看当前所设置的所有的环境变量。
这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。
例如：
set $i = 0
print bar[$i++]-&gt;contents
于是，当你就不必，print bar[0]-&gt;contents, print bar[1]-&gt;contents地输入命令了。输入这样的
命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功
能。
##十、查看寄存器
要查看寄存器的值，很简单，可以使用如下命令：
info registers
查看寄存器的情况。（除了浮点寄存器）
info all-registers
查看所有寄存器的情况。（包括浮点寄存器）
info registers
查看所指定的寄存器的情况。
寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈
地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前
加一个$符号就可以了。如：p $eip。</p>

<p>#改变程序的执行
———————
一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地
在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好
的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。
##一、修改变量值
修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。
如：
(gdb) print x=4
x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是
Pascal，那么你可以使用Pascal的语法：x:=4。
在某些时候，很有可能你的变量和GDB中的参数冲突，如：
(gdb) whatis width
type = double
(gdb) p width
$4 = 13
(gdb) set width=47
Invalid syntax in expression.
因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，
此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，
如：
(gdb) set var width=47
另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值
时，最好都使用set var格式的GDB命令。
##二、跳转执行
一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，
也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB
的jump命令来完：
jump</p>

<p>指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏
移量格式。表式着下一条运行语句从哪里开始。
jump
这里的
是代码行的内存地址。
注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数
时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至
于产生程序Core Dump。所以最好是同一个函数中进行跳转。
熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，
jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行
的地址。如：
set $pc = 0x485
##三、产生信号量
使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便
于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，
这种精确地在某处产生信号非常有利程序的调试。
语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。
single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截
获的，而single命令所发出一信号则是直接发给被调试程序的。
##四、强制函数返回
如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数
忽略还没有执行的语句并返回。
return
return
使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认
作函数的返回值。
##五、强制调用函数</p>

<p>call
表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返
回值是void，那么就不显示。
另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他
来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返
回值，并把该值存入历史数据中。
#在不同语言中使用GDB
——————————
GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和 Modula-2。一般说
来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”
的，GDB会认为是C程序。文件名后缀为“.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是
C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”
的会认为是汇编语言。
也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令
跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些表达式或
变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针的语法是*p，而在
Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言一同编译成的，那到在调
试过程中，GDB也能根据不同的语言自动地切换语言环境。这种跟着语言环境而改变的功
能，真是体贴开发人员的一种设计。
下面是几个相关于GDB语言环境的命令：
show language
查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默
认的环境。
info frame
查看当前函数的程序语言。
info source
查看当前文件的程序语言。
如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set
language命令即可做到。
当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：</p>

<p>(gdb) set language
The currently understood settings are:
local or auto Automatic setting based on source file
c Use the C language
c++ Use the C++ language
asm Use the Asm language
chill Use the Chill language
fortran Use the Fortran language
java Use the Java language
modula-2 Use the Modula-2 language
pascal Use the Pascal language
scheme Use the Scheme language
于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。
#后记
——
GDB是一个强大的命令行调试工具。大家知道命令行的强大就是在于，其可以形成执行序
列，形成脚本。UNIX下的软件全是命令行的，这给程序开发提代供了极大的便利，命令行
软件的优势在于，它们可以非常容易的集成在一起，使用几个简单的已有工具的命令，就可
以做出一个非常强大的功能。
于是UNIX下的软件比Windows下的软件更能有机地结合，各自发挥各自的长处，组合成
更为强劲的功能。而Windows下的图形软件基本上是各自为营，互相不能调用，很不利于
各种软件的相互集成。在这里并不是要和Windows做个什么比较，所谓“寸有所长，尺有
所短”，图形化工具还是有不如命令行的地方。（看到这句话时，希望各位千万再也不要认为
我就是“鄙视图形界面”，和我抬杠了 ）
我是根据版本为5.1.1的GDB所写的这篇文章，所以可能有些功能已被修改，或是又有更
为强劲的功能。而且，我写得非常仓促，写得比较简略，并且，其中我已经看到有许多错别
字了（我用五笔，所以错字让你看不懂），所以，我在这里对我文中的差错表示万分的歉意。
文中所罗列的GDB的功能时，我只是罗列了一些带用的GDB的命令和使用方法，其实，
我这里只讲述的功能大约只占GDB所有功能的60%吧，详细的文档，还是请查看GDB的
帮助和使用手册吧，或许，过段时间，如果我有空，我再写一篇GDB的高级使用。
我个人非常喜欢GDB的自动调试的功能，这个功能真的很强大，试想，我在UNIX下写个
脚本，让脚本自动编译我的程序，被自动调试，并把结果报告出来，调试成功，自动checkin
源码库。一个命令，编译带着调试带着checkin，多爽啊。只是GDB对自动化调试目前支持
还不是很成熟，只能实现半自动化，真心期望着GDB的自动化调试功能的成熟。</p>

<p>如果各位对GDB或是别的技术问题有兴趣的话，欢迎和我讨论交流。本人目前主要在UNIX
下做产品软件的开发，所以，对UNIX下的软件开发比较熟悉，当然，不单单是技术，对软
件工程实施，软件设计，系统分析，项目管理我也略有心得。欢迎大家找我交流，（QQ是：
753640，MSN是：haoel@hotmail.com）
RelatedEntries：
文件操作 - 10 28, 2003
OSW:12.CVS设置与应用 - 10 28, 2003
MySQL AB Acquires Alzato - 10 24, 2003
cvs - 10 24, 2003
使用CVS进行版本管理 - 10 23, 2003</p>

        </article>
  </div>
</section>

<aside id=comments>
    <div><h2> Comments </h2></div>
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'frederick-sun';
    var disqus_identifier = 'http:\/\/sun-friderick.github.io\/post\/2015-11-31';
    var disqus_title = 'gdb调试命令的使用及总结';
    var disqus_url = 'http:\/\/sun-friderick.github.io\/post\/2015-11-31';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</aside>

<footer>
  <div>
    <p>
    &copy; 2015 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Frederick Sun.</span></span>
        Powered by <a href="http://hugo.spf13.com">Hugo</a>.
        Theme by <a href="http://spf13.com">Steve Francia</a>.
    </p>
  </div>
</footer>
<script type="text/javascript">
(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>






<style> 
    BODY {
        min-height:800px;
    }
    #goTopBtn {
        POSITION: fixed; TEXT-ALIGN: center; LINE-HEIGHT: 50px; WIDTH: 50px; BOTTOM: 35px; HEIGHT: 50px; FONT-SIZE: 12px; CURSOR: pointer; RIGHT: 0px; _position: absolute; _right: auto;
    }
</style>
<script type="text/javascript">
    function goTopEx() { 
        var obj = document.getElementById("goTopBtn"); 
        function getScrollTop() { 
            return document.documentElement.scrollTop + document.body.scrollTop; 
        } 
        function setScrollTop(value) { 
            if (document.documentElement.scrollTop) { 
                document.documentElement.scrollTop = value; 
            } else { 
                document.body.scrollTop = value; 
            } 
        } 
        window.onscroll = function() { 
            getScrollTop() > 0 ? obj.style.display = "": obj.style.display = "none"; 
        } 
        obj.onclick = function() { 
            var goTop = setInterval(scrollMove, 10); 
            function scrollMove() { 
                setScrollTop(getScrollTop() / 1.1); 
            if (getScrollTop() < 1) 
                clearInterval(goTop); 
            } 
        } 
    } 
</script>
<div style="display: none" id="goTopBtn"><img src='/media/top.gif' /></div>
<script type="text/javascript">goTopEx();</script>


</body>
</html>


<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</body>